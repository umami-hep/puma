{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"PUMA: Plotting UMami Api","text":"<p>The Python package <code>puma</code> provides a plotting API for commonly used plots in flavour tagging.</p> ROC curves Histogram plots Variable vs efficiency"},{"location":"#installation","title":"Installation","text":"<p><code>puma</code> can be installed from PyPI or using the latest code from this repository.</p>"},{"location":"#install-latest-release-from-pypi","title":"Install latest release from PyPI","text":"<pre><code>pip install puma-hep\n</code></pre> <p>The installation from PyPI only allows to install tagged releases, meaning you can not install the latest code from this repo using the above command. If you just want to use a stable release of <code>puma</code>, this is the way to go.</p>"},{"location":"#install-latest-version-from-github","title":"Install latest version from GitHub","text":"<pre><code>pip install https://github.com/umami-hep/puma/archive/main.tar.gz\n</code></pre> <p>This will install the latest version of <code>puma</code>, i.e. the current version from the <code>main</code> branch (no matter if it is a release/tagged commit). If you plan on contributing to <code>puma</code> and/or want the latest version possible, this is what you want.</p>"},{"location":"#docker-images","title":"Docker images","text":"<p>The Docker images are built on GitHub and contain the latest version from the <code>main</code> branch.</p> <p>The container registry with all available tags can be found here.</p> <p>The <code>puma:latest</code> image is based on <code>python:3.11.10-bullseye</code> and is meant for users who want to use the latest version of <code>puma</code>. For each release, there is a corresponding tagged image. You can start an interactive shell in a container with your current working directory mounted into the container by using one of the commands provided below.</p> <p>On a machine with Docker installed:</p> <pre><code>docker run -it --rm -v $PWD:/puma_container -w /puma_container gitlab-registry.cern.ch/aft/training-images/puma-images/puma:latest bash\n</code></pre> <p>On a machine/cluster with singularity installed:</p> <pre><code>singularity shell -B $PWD docker://gitlab-registry.cern.ch/aft/training-images/puma-images/puma:latest\n</code></pre> <p>The images are automatically updated via GitHub and pushed to this repository registry.</p>"},{"location":"api/fraction_scan/","title":"Fraction Scan","text":""},{"location":"api/fraction_scan/#puma.fraction_scan.get_fx_values","title":"<code>puma.fraction_scan.get_fx_values</code>","text":"<p>Calculate the fraction values which are to be tested.</p> <p>Parameters:</p> Name Type Description Default <code>resolution</code> <code>int</code> <p>Resolution of the fraction values, by default 100</p> <code>100</code> <p>Returns:</p> Type Description <code>numpy.ndarray</code> <p>Array with the fraction values that are to be used.</p> Source code in <code>puma/fraction_scan.py</code> <pre><code>def get_fx_values(resolution: int = 100) -&gt; np.ndarray:\n    \"\"\"Calculate the fraction values which are to be tested.\n\n    Parameters\n    ----------\n    resolution : int, optional\n        Resolution of the fraction values, by default 100\n\n    Returns\n    -------\n    np.ndarray\n        Array with the fraction values that are to be used.\n    \"\"\"\n    return np.concatenate((\n        np.logspace(-3, -1, resolution // 2),\n        np.linspace(0.1, 1.0, resolution // 2),\n    ))\n</code></pre>"},{"location":"api/fraction_scan/#puma.fraction_scan.get_efficiency","title":"<code>puma.fraction_scan.get_efficiency</code>","text":"<p>Calculate the efficiency for a given set of scores that are above a certain threshold.</p> <p>Parameters:</p> Name Type Description Default <code>scores</code> <code>numpy.ndarray</code> <p>Array of the output scores.</p> required <code>fx</code> <code>float</code> <p>Cut threshold for which needs to be passed.</p> required <p>Returns:</p> Type Description <code>float</code> <p>Efficiency (in percent) how many scores pass the threshold.</p> Source code in <code>puma/fraction_scan.py</code> <pre><code>def get_efficiency(scores: np.ndarray, fx: float) -&gt; float:\n    \"\"\"Calculate the efficiency for a given set of scores that are above a certain threshold.\n\n    Parameters\n    ----------\n    scores : np.ndarray\n        Array of the output scores.\n    fx : float\n        Cut threshold for which needs to be passed.\n\n    Returns\n    -------\n    float\n        Efficiency (in percent) how many scores pass the threshold.\n    \"\"\"\n    return np.sum(scores &gt; fx) / len(scores)\n</code></pre>"},{"location":"api/fraction_scan/#puma.fraction_scan.get_optimal_fraction_value","title":"<code>puma.fraction_scan.get_optimal_fraction_value</code>","text":"<p>After calculating a fraction scan, find the optimal fraction value.</p> <p>Parameters:</p> Name Type Description Default <code>fraction_scan</code> <code>numpy.ndarray</code> <p>2D array of efficiency (or rejection) scores for each fraction value.</p> required <code>fraction_space</code> <code>numpy.ndarray</code> <p>1D array of fraction values.</p> required <code>rej</code> <code>bool</code> <p>If True, find the maximum rejection values else find the minimum efficiency values, by default False.</p> <code>False</code> <p>Returns:</p> Type Description <code>tuple[numpy.ndarray, numpy.ndarray]</code> <p>Returns the optimal fraction value (index) and the actual value.</p> Source code in <code>puma/fraction_scan.py</code> <pre><code>def get_optimal_fraction_value(\n    fraction_scan: np.ndarray,\n    fraction_space: np.ndarray,\n    rej: bool = False,\n) -&gt; tuple[np.ndarray, np.ndarray]:\n    \"\"\"After calculating a fraction scan, find the optimal fraction value.\n\n    Parameters\n    ----------\n    fraction_scan : np.ndarray\n        2D array of efficiency (or rejection) scores for each fraction value.\n    fraction_space : np.ndarray\n        1D array of fraction values.\n    rej : bool, optional\n        If True, find the maximum rejection values else find the minimum efficiency values, by\n        default False.\n\n    Returns\n    -------\n    tuple[np.ndarray, np.ndarray]\n        Returns the optimal fraction value (index) and the actual value.\n    \"\"\"\n    # normalise x- and y-axes\n    xs, ys = fraction_scan[:, 0], fraction_scan[:, 1]\n    xs /= max(xs)\n    ys /= max(ys)\n\n    # if rej=True get maximum distance to origin\n    opt_idx = np.argmax(xs**2 + ys**2) if rej else np.argmin(xs**2 + ys**2)\n\n    return opt_idx, fraction_space[opt_idx]\n</code></pre>"},{"location":"api/histogram/","title":"Histogram","text":""},{"location":"api/histogram/#puma.histogram.Histogram","title":"<code>puma.histogram.Histogram</code>","text":"<p>               Bases: <code>puma.plot_base.PlotLineObject</code></p> <p>Histogram class storing info about histogram and allows to calculate ratio w.r.t other histograms.</p> <p>Parameters:</p> Name Type Description Default <code>values</code> <code>numpy.ndarray | None</code> <p>Input data for the histogram. If bin_edges is specified (not None) then this array is treated as the bin heights. By default None</p> <code>None</code> <code>bins</code> <code>int | numpy.ndarray | list | None</code> <p>If bins is an int, it defines the number of equal-width bins in the given range. If bins is a sequence, it defines a monotonically increasing array of bin edges, including the rightmost edge, allowing for non-uniform bin widths (like in numpy.histogram). By default None</p> <code>None</code> <code>bins_range</code> <code>tuple | None</code> <p>Tuple of two floats, specifying the range for the binning. If bins_range is specified and bins is an integer, equal-width bins from bins_range[0] to bins_range[1] are used for the histogram (like in numpy.histogram). By default None</p> <code>None</code> <code>bin_edges</code> <code>numpy.ndarray</code> <p>If specified, the histogram is considered \"filled\": the array given to values is treated as if it was the bin heights corresponding to these bin_edges and the \"weights\" input is ignored. By default None.</p> <code>None</code> <code>weights</code> <code>numpy.ndarray</code> <p>Weights for the input data. Has to be an array of same length as the input data with a weight for each entry. If not specified, weight 1 will be given to each entry. The uncertainties are calculated as the square root of the squared weights (for each bin separately). By default None.</p> <code>None</code> <code>sum_squared_weights</code> <code>numpy.ndarray</code> <p>Only considered if the histogram is considered filled (i.e bin_edges is specified). It is the sum_squared_weights per bin. By default None.</p> <code>None</code> <code>ratio_group</code> <code>str | None</code> <p>Name of the ratio group this histogram is compared with. The ratio group allows you to compare different groups of histograms within one plot. By default None</p> <code>None</code> <code>flavour</code> <code>ftag.Label | None</code> <p>If set, the correct colour and a label prefix will be extracted from <code>puma.utils.global_config</code> set for this histogram. Allowed values are e.g. \"bjets\", \"cjets\", \"ujets\", \"bbjets\", ... By default None</p> <code>None</code> <code>add_flavour_label</code> <code>bool</code> <p>Set to False to suppress the automatic addition of the flavour label prefix in the label of the curve (i.e. \"b-jets\" in the case of b-jets). This is ignored if <code>flavour</code> is not set. By default True</p> <code>True</code> <code>histtype</code> <code>str</code> <p><code>histtype</code> parameter which is handed to matplotlib.hist() when plotting the histograms. Supported values are \"bar\", \"barstacked\", \"step\", \"stepfilled\". By default \"step\"</p> <code>'step'</code> <code>norm</code> <code>bool</code> <p>Specify if the histograms are normalised, this means that histograms are divided by the total numer of counts. Therefore, the sum of the bin counts is equal to one, but NOT the area under the curve, which would be sum(bin_counts * bin_width). By default True.</p> <code>True</code> <code>underoverflow</code> <code>bool</code> <p>Option to include under- and overflow values in outermost bins, by default True.</p> <code>True</code> <code>is_data</code> <code>bool</code> <p>Decide, if the plot object will be treated as data (black dots, no stacking), by default False</p> <code>False</code> <code>discrete_vals</code> <code>list | None</code> <p>List of values if a variable only has discrete values. If discrete_vals is specified only the bins containing these values are plotted. By default None.</p> <code>None</code> <code>**kwargs</code> <code>typing.Any</code> <p>Keyword arguments passed to <code>puma.plot_base.PlotLineObject</code></p> <code>{}</code> <p>Raises:</p> Type Description <code>ValueError</code> <p>If input data is not of type np.ndarray or list If weights are specified but have different length as the input values</p> <code>TypeError</code> <p>If the input data for the histogram are invalid</p> Source code in <code>puma/histogram.py</code> <pre><code>def __init__(\n    self,\n    values: np.ndarray | None = None,\n    bins: int | np.ndarray | list | None = None,\n    bins_range: tuple | None = None,\n    bin_edges: np.ndarray = None,\n    weights: np.ndarray = None,\n    sum_squared_weights: np.ndarray = None,\n    ratio_group: str | None = None,\n    flavour: Label | None = None,\n    add_flavour_label: bool = True,\n    histtype: str = \"step\",\n    norm: bool = True,\n    underoverflow: bool = True,\n    is_data: bool = False,\n    discrete_vals: list | None = None,\n    **kwargs: Any,\n) -&gt; None:\n    super().__init__(**kwargs)\n\n    if isinstance(values, (np.ndarray, list, pd.core.series.Series)):\n        values = np.array(values)\n        if len(values) == 0:\n            logger.warning(\"Histogram is empty.\")\n    else:\n        raise TypeError(\n            \"Invalid type of histogram input data. Allowed values are \"\n            \"numpy.ndarray, list, pandas.core.series.Series\"\n        )\n    if weights is not None and len(values) != len(weights):\n        raise ValueError(\"`values` and `weights` are not of same length.\")\n\n    if bin_edges is None and sum_squared_weights is not None:\n        logger.warning(\n            \"The Histogram has no bin edges defined and is thus not considered filled. \"\n            \"Parameter `sum_squared_weights` is ignored.\"\n        )\n\n    elif bin_edges is not None and bins is not None:\n        logger.warning(\"When bin_edges are provided, bins are not considered!\")\n\n    elif bin_edges is None and bins is None:\n        raise ValueError(\"You need to define either `bins` or `bin_edges`!\")\n\n    self.bins = bins\n    self.bins_range = bins_range\n    self.bin_edges = bin_edges\n    self.sum_squared_weights = sum_squared_weights\n    self.kwargs = kwargs\n\n    # This attribute allows to know how to histogram it\n    self.filled = self.bin_edges is not None\n\n    # Ensure that the flavour is an instance of Flavour\n    self.flavour = flavour\n\n    # Set the inputs as attributes\n    self.weights = weights if weights is not None else np.ones_like(values)\n    self.sum_of_weights = float(np.sum(self.weights))\n    self.ratio_group = ratio_group\n    self.add_flavour_label = add_flavour_label\n    self.histtype = histtype\n    self.norm = norm\n    self.underoverflow = underoverflow\n    self.is_data = is_data\n    self.discrete_vals = cast(list, discrete_vals)\n\n    # Define the key (like a name) for the Histogram object. Will be set later\n    # by the actual histogram plot\n    self.key: str | None = None\n\n    # Set the label\n    label = kwargs[\"label\"] if \"label\" in kwargs and kwargs[\"label\"] is not None else \"\"\n\n    # If flavour was specified, extract configuration from global config\n    if self.flavour is not None:\n        if not isinstance(self.flavour, Label):\n            raise TypeError(\n                f\"'flavour' must be an instance of Label! You gave {type(self.flavour)}\"\n            )\n\n        # Use globally defined flavour colour if not specified\n        if self.colour is None:\n            self.colour = self.flavour.colour\n            logger.debug(\"Histogram colour was set to %s\", self.colour)\n\n        # Add globally defined flavour label if not suppressed\n        if (\n            self.add_flavour_label\n            and self.label\n            and not self.label.startswith(f\"{self.flavour.label}\")\n        ):\n            self.label = f\"{self.flavour.label} {label}\"\n\n        else:\n            self.label = label\n        logger.debug(\"Histogram label was set to %s\", {self.label})\n\n    # Histogram the input values\n    self.bin_edges, self.hist, self.unc, self.band = hist_w_unc(\n        arr=values,\n        bins=self.bins,\n        filled=self.filled,\n        bins_range=self.bins_range,\n        normed=self.norm,\n        weights=self.weights,\n        bin_edges=self.bin_edges,\n        sum_squared_weights=self.sum_squared_weights,\n        underoverflow=self.underoverflow,\n    )\n\n    # Discretise the bins if wanted\n    if self.discrete_vals is not None:\n        self.get_discrete_values()\n</code></pre>"},{"location":"api/histogram/#puma.histogram.Histogram.args_to_store","title":"<code>args_to_store</code>  <code>property</code>","text":"<p>Returns the arguments that need to be stored/loaded.</p> <p>Returns:</p> Type Description <code>dict[str, typing.Any]</code> <p>Dict with the arguments</p>"},{"location":"api/histogram/#puma.histogram.Histogram.divide","title":"<code>divide</code>","text":"<p>Calculate ratio between two class objects.</p> <p>Parameters:</p> Name Type Description Default <code>other</code> <code>puma.histogram.Histogram</code> <p>Second histogram object to calculate ratio with</p> required <p>Returns:</p> Type Description <code>numpy.ndarray</code> <p>Ratio</p> <code>numpy.ndarray</code> <p>Ratio error</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If binning is not identical between 2 objects If hist attribute is not set for one of the two histograms If bin_edges attribute is not set for one of the two histograms</p> Source code in <code>puma/histogram.py</code> <pre><code>def divide(self, other: Histogram) -&gt; tuple[np.ndarray, np.ndarray]:\n    \"\"\"Calculate ratio between two class objects.\n\n    Parameters\n    ----------\n    other : Histogram\n        Second histogram object to calculate ratio with\n\n    Returns\n    -------\n    np.ndarray\n        Ratio\n    np.ndarray\n        Ratio error\n\n    Raises\n    ------\n    ValueError\n        If binning is not identical between 2 objects\n        If hist attribute is not set for one of the two histograms\n        If bin_edges attribute is not set for one of the two histograms\n    \"\"\"\n    try:\n        np.all(self.bin_edges == other.bin_edges)\n\n    except ValueError as err:\n        raise ValueError(\"The binning of the two given objects do not match.\") from err\n\n    # Bins where the reference histogram is empty/zero, are given a ratio of np.inf\n    # which means that the ratio plot will not have any entry in these bins.\n    ratio, ratio_unc = hist_ratio(\n        numerator=self.hist,\n        denominator=other.hist,\n        numerator_unc=self.unc,\n        step=False,\n    )\n    # To use the matplotlib.step() function later on, the first bin is duplicated\n    ratio = np.append(np.array([ratio[0]]), ratio)\n    ratio_unc = np.append(np.array([ratio_unc[0]]), ratio_unc)\n\n    return (ratio, ratio_unc)\n</code></pre>"},{"location":"api/histogram/#puma.histogram.Histogram.divide_data_mc","title":"<code>divide_data_mc</code>","text":"<p>Similar as divide, but the second item doesn't need to be a histogram object.</p> <p>Parameters:</p> Name Type Description Default <code>ref_hist</code> <code>numpy.ndarray</code> <p>Hist weights of the reference.</p> required <p>Returns:</p> Type Description <code>tuple</code> <p>Tuple of the ratios and ratio uncertaintes for the bins</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the binning of the two histograms doesn't match</p> Source code in <code>puma/histogram.py</code> <pre><code>def divide_data_mc(\n    self,\n    ref_hist: np.ndarray,\n) -&gt; tuple[np.ndarray, np.ndarray]:\n    \"\"\"\n    Similar as divide, but the second item doesn't need to be a histogram object.\n\n    Parameters\n    ----------\n    ref_hist : np.ndarray\n        Hist weights of the reference.\n\n    Returns\n    -------\n    tuple\n        Tuple of the ratios and ratio uncertaintes for the bins\n\n    Raises\n    ------\n    ValueError\n        If the binning of the two histograms doesn't match\n    \"\"\"\n    try:\n        self.hist + ref_hist\n    except ValueError as err:\n        raise ValueError(\"The binning of the two given objects do not match.\") from err\n\n    # Bins where the reference histogram is empty/zero, are given a ratio of np.inf\n    # which means that the ratio plot will not have any entry in these bins.\n    ratio, ratio_unc = hist_ratio(\n        numerator=self.hist,\n        denominator=ref_hist,\n        numerator_unc=self.unc,\n        step=False,\n    )\n    # To use the matplotlib.step() function later on, the first bin is duplicated\n    ratio = np.append(np.array([ratio[0]]), ratio)\n    ratio_unc = np.append(np.array([ratio_unc[0]]), ratio_unc)\n\n    return (ratio, ratio_unc)\n</code></pre>"},{"location":"api/histogram/#puma.histogram.Histogram.get_discrete_values","title":"<code>get_discrete_values</code>","text":"<p>Get discrete values of a variable and adjust the bins accordingly.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the bin width is larger than 1 such that potentially not all discrete values are in a seperate bin If the number of bins is set to 1 such that no values can be distinguished</p> Source code in <code>puma/histogram.py</code> <pre><code>def get_discrete_values(self) -&gt; None:\n    \"\"\"Get discrete values of a variable and adjust the bins accordingly.\n\n    Raises\n    ------\n    ValueError\n        If the bin width is larger than 1 such that potentially not\n        all discrete values are in a seperate bin\n        If the number of bins is set to 1 such that no values can be\n        distinguished\n    \"\"\"\n    assert self.discrete_vals is not None\n    if len(self.bin_edges) &gt; 1:\n        if abs(self.bin_edges[1] - self.bin_edges[0]) &lt;= 1:\n            indice = [\n                i\n                for i in range(len(self.bin_edges) - 1)\n                for discrete_val in self.discrete_vals\n                if self.bin_edges[i] &lt;= discrete_val &lt; self.bin_edges[i + 1]\n            ]\n            self.hist = self.hist[indice]\n            self.unc = self.unc[indice]\n            self.band = self.band[indice]\n            bins = np.linspace(0, len(self.discrete_vals), len(self.discrete_vals) + 1)\n            self.bin_edges = bins\n\n        else:\n            raise ValueError(\n                \"Bin width is larger than 1. Choose a binning with a bin\"\n                \" width&lt;= 1 to plot only discrete values.\"\n            )\n    else:\n        raise ValueError(\n            \"Choose a binning with more than one bin in order to plot only discrete values.\"\n        )\n</code></pre>"},{"location":"api/histogram/#puma.histogram.Histogram.update","title":"<code>update</code>","text":"<p>Update the existing histogram with new values.</p> <p>Parameters:</p> Name Type Description Default <code>values</code> <code>numpy.ndarray</code> <p>New values that are to be added.</p> required <code>weights</code> <code>numpy.ndarray | None</code> <p>Weights for each entry in values. Must be the same shape/size as values. If None, each value in values will be weighted the same, by default None</p> <code>None</code> Source code in <code>puma/histogram.py</code> <pre><code>def update(self, values: np.ndarray, weights: np.ndarray | None = None) -&gt; None:\n    \"\"\"Update the existing histogram with new values.\n\n    Parameters\n    ----------\n    values : np.ndarray\n        New values that are to be added.\n    weights : np.ndarray | None, optional\n        Weights for each entry in values. Must be the same shape/size as values.\n        If None, each value in values will be weighted the same, by default None\n    \"\"\"\n    # Replace the weights if None\n    if weights is None:\n        weights = np.ones_like(values)\n\n    # Check that the weights are a np.ndarray\n    assert isinstance(weights, np.ndarray)\n\n    # Call the hist_w_unc function for the new values\n    _, incoming_hist, incoming_unc, _ = hist_w_unc(\n        arr=values,\n        bins=self.bins,\n        filled=self.filled,\n        bins_range=self.bins_range,\n        normed=self.norm,\n        weights=weights,\n        bin_edges=self.bin_edges,\n        sum_squared_weights=self.sum_squared_weights,\n        underoverflow=self.underoverflow,\n    )\n\n    # Get the new sum_of_weights\n    incoming_sum_of_weights = float(np.sum(weights))\n\n    if self.norm:\n        self.hist = (\n            self.hist * self.sum_of_weights + incoming_hist * incoming_sum_of_weights\n        ) / (self.sum_of_weights + incoming_sum_of_weights)\n        self.unc = np.sqrt(\n            (self.unc * self.sum_of_weights) ** 2\n            + (incoming_unc * incoming_sum_of_weights) ** 2\n        ) / (self.sum_of_weights + incoming_sum_of_weights)\n\n    else:\n        self.hist += incoming_hist\n        self.unc = np.sqrt(self.unc**2 + incoming_unc**2)\n\n    self.sum_of_weights += incoming_sum_of_weights\n    self.band = self.hist - self.unc\n</code></pre>"},{"location":"api/histogram/#puma.histogram.HistogramPlot","title":"<code>puma.histogram.HistogramPlot</code>","text":"<p>               Bases: <code>puma.plot_base.PlotBase</code></p> <p>Histogram plot class.</p> <p>Parameters:</p> Name Type Description Default <code>logy</code> <code>bool</code> <p>Set log scale on y-axis, by default False.</p> <code>False</code> <code>bin_width_in_ylabel</code> <code>bool</code> <p>Specify if the bin width should be added to the ylabel, by default False</p> <code>False</code> <code>grid</code> <code>bool</code> <p>Set the grid for the plots, by default False</p> <code>False</code> <code>stacked</code> <code>bool</code> <p>Decide, if all histograms (which are not data) are stacked, by default False</p> <code>False</code> <code>histtype</code> <code>str</code> <p>If stacked is used, define the type of histogram you would like to have, default is \"bar\"</p> <code>'bar'</code> <code>**kwargs</code> <code>typing.Any</code> <p>Keyword arguments from <code>puma.PlotObject</code></p> <code>{}</code> <p>Raises:</p> Type Description <code>ValueError</code> <p>If n_ratio_panels &gt; 1</p> Source code in <code>puma/histogram.py</code> <pre><code>def __init__(\n    self,\n    logy: bool = False,\n    bin_width_in_ylabel: bool = False,\n    grid: bool = False,\n    stacked: bool = False,\n    histtype: str = \"bar\",\n    **kwargs: Any,\n) -&gt; None:\n    super().__init__(grid=grid, **kwargs)\n    self.logy = logy\n    self.bin_width_in_ylabel = bin_width_in_ylabel\n    self.stacked = stacked\n    self.histtype = histtype\n    self.plot_objects: dict[str, Histogram] = {}\n    self.add_order: list[str] = []\n    self.reference_object: list[str] = []\n\n    if self.n_ratio_panels &gt; 1:\n        raise ValueError(\"Not more than one ratio panel supported.\")\n    self.initialise_figure()\n</code></pre>"},{"location":"api/histogram/#puma.histogram.HistogramPlot.add","title":"<code>add</code>","text":"<p>Adding histogram object to figure.</p> <p>Parameters:</p> Name Type Description Default <code>histogram</code> <code>puma.histogram.Histogram</code> <p>Histogram curve</p> required <code>key</code> <code>str | None</code> <p>Unique identifier for histogram, by default None</p> <code>None</code> <code>reference</code> <code>bool</code> <p>If this histogram is used as reference for ratio calculation, by default False</p> <code>False</code> <p>Raises:</p> Type Description <code>KeyError</code> <p>If unique identifier key is used twice</p> Source code in <code>puma/histogram.py</code> <pre><code>def add(\n    self,\n    histogram: Histogram,\n    key: str | None = None,\n    reference: bool = False,\n) -&gt; None:\n    \"\"\"Adding histogram object to figure.\n\n    Parameters\n    ----------\n    histogram : Histogram\n        Histogram curve\n    key : str | None, optional\n        Unique identifier for histogram, by default None\n    reference : bool, optional\n        If this histogram is used as reference for ratio calculation, by default\n        False\n\n    Raises\n    ------\n    KeyError\n        If unique identifier key is used twice\n    \"\"\"\n    # If key not defined, set it to a numerical value\n    key = cast(str, key if key is not None else f\"{len(self.plot_objects) + 1}\")\n\n    # Check that key is not double used\n    if key in self.plot_objects:\n        raise KeyError(f\"Duplicated key {key} already used for unique identifier.\")\n\n    # Add key to histogram object\n    histogram.key = key\n    logger.debug(\"Adding histogram %s\", key)\n\n    # Set linestyle\n    if histogram.linestyle is None:\n        if histogram.is_data is True:\n            histogram.linestyle = \"None\"\n        else:\n            histogram.linestyle = \"-\"\n    # Set marker\n    if histogram.marker is None:\n        if histogram.is_data is True:\n            histogram.marker = \".\"\n        else:\n            histogram.marker = \"\"\n    # Set colours\n    if histogram.colour is None:\n        histogram.colour = get_good_colours()[len(self.plot_objects)]\n    # Set alpha\n    if histogram.alpha is None:\n        histogram.alpha = 1\n    # Set linewidth\n    if histogram.linewidth is None:\n        histogram.linewidth = 1.6\n    # Set markersize\n    if histogram.markersize is None:\n        histogram.markersize = 10\n\n    self.plot_objects[key] = histogram\n    self.add_order.append(key)\n    if reference is True:\n        self.set_reference(key)\n</code></pre>"},{"location":"api/histogram/#puma.histogram.HistogramPlot.add_bin_width_to_ylabel","title":"<code>add_bin_width_to_ylabel</code>","text":"<p>Adds the bin width to the ylabel of a histogram plot. If the bin with is smaller than 0.01, scientific notation will be used.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If plotting_done is False (therefore <code>bins</code> is not yet calculated)</p> Source code in <code>puma/histogram.py</code> <pre><code>def add_bin_width_to_ylabel(self):\n    \"\"\"Adds the bin width to the ylabel of a histogram plot. If the bin with is\n    smaller than 0.01, scientific notation will be used.\n\n    Raises\n    ------\n    ValueError\n        If plotting_done is False (therefore `bins` is not yet calculated)\n    \"\"\"\n    if self.plotting_done is False:\n        raise ValueError(\n            \"`add_bin_width_to_ylabel` should be called after plotting, since bins \"\n            \"are calculated during plotting.\"\n        )\n\n    bin_width = abs(self.bin_edges[1] - self.bin_edges[0])\n    if bin_width &lt; 1e-2:\n        self.ylabel = f\"{self.ylabel} / {bin_width:.0e}\"\n    else:\n        self.ylabel = f\"{self.ylabel} / {bin_width:.2f}\"\n    self.set_ylabel(self.axis_top)\n</code></pre>"},{"location":"api/histogram/#puma.histogram.HistogramPlot.draw","title":"<code>draw</code>","text":"<p>Draw figure.</p> <p>Parameters:</p> Name Type Description Default <code>labelpad</code> <code>int | None</code> <p>Spacing in points from the axes bounding box including ticks and tick labels, by default \"ratio\"</p> <code>None</code> Source code in <code>puma/histogram.py</code> <pre><code>def draw(self, labelpad: int | None = None) -&gt; None:\n    \"\"\"Draw figure.\n\n    Parameters\n    ----------\n    labelpad : int | None, optional\n        Spacing in points from the axes bounding box including\n        ticks and tick labels, by default \"ratio\"\n    \"\"\"\n    plt_handles = self.plot()\n\n    if self.n_ratio_panels &gt; 0:\n        self.plot_ratios()\n\n    self.set_xlim(\n        self.bin_edges[0] if self.xmin is None else self.xmin,\n        self.bin_edges[-1] if self.xmax is None else self.xmax,\n    )\n    self.set_log()\n    self.set_y_lim()\n    self.set_xlabel()\n    self.set_tick_params()\n    self.set_ylabel(self.axis_top)\n\n    if self.n_ratio_panels &gt; 0:\n        assert isinstance(self.ylabel_ratio, list)\n        self.set_ylabel(\n            self.ratio_axes[0],\n            self.ylabel_ratio[0],\n            align=\"center\",\n            labelpad=labelpad,\n        )\n\n    if self.bin_width_in_ylabel is True:\n        self.add_bin_width_to_ylabel()\n\n    legend_axis = self.axis_top\n\n    self.make_legend(plt_handles, ax_mpl=legend_axis)\n    self.set_title()\n\n    if self.apply_atlas_style:\n        self.atlasify()\n</code></pre>"},{"location":"api/histogram/#puma.histogram.HistogramPlot.get_reference_histo","title":"<code>get_reference_histo</code>","text":"<p>Get reference histogram from list of references.</p> <p>Parameters:</p> Name Type Description Default <code>histo</code> <code>puma.histogram.Histogram</code> <p>Histogram we want to calculate the ratio for</p> required <p>Returns:</p> Name Type Description <code>reference_histo</code> <code>puma.histogram.Histogram</code> <p>The reference histogram</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If no reference histo was found or multiple matches.</p> Source code in <code>puma/histogram.py</code> <pre><code>def get_reference_histo(self, histo: Histogram) -&gt; Histogram | None:\n    \"\"\"Get reference histogram from list of references.\n\n    Parameters\n    ----------\n    histo : Histogram\n        Histogram we want to calculate the ratio for\n\n    Returns\n    -------\n    reference_histo : Histogram\n        The reference histogram\n\n    Raises\n    ------\n    ValueError\n        If no reference histo was found or multiple matches.\n    \"\"\"\n    matches = 0\n    reference_histo = None\n\n    for key in self.reference_object:\n        reference_candidate = self.plot_objects[key]\n        if histo.ratio_group is not None:\n            if histo.ratio_group == reference_candidate.ratio_group:\n                matches += 1\n                reference_histo = reference_candidate\n        else:\n            matches += 1\n            reference_histo = reference_candidate\n\n    if matches != 1:\n        raise ValueError(\n            f\"Found {matches} matching reference candidates, but only one match is allowed.\"\n        )\n\n    logger.debug(\"Reference histogram for '%s' is '%s'\", histo.key, reference_histo.key)\n\n    return reference_histo\n</code></pre>"},{"location":"api/histogram/#puma.histogram.HistogramPlot.plot","title":"<code>plot</code>","text":"<p>Plotting curves. This also generates the bins of the histograms that are added to the plot. Plot objects are drawn in the same order as they were added to the plot.</p> <p>Parameters:</p> Name Type Description Default <code>**kwargs</code> <code>typing.Any</code> <p>Keyword arguments passed to matplotlib.axes.Axes.hist()</p> <code>{}</code> <p>Returns:</p> Type Description <code>puma.line_plot_2d.Line2D</code> <p>matplotlib Line2D object</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If specified bins type is not supported.</p> Source code in <code>puma/histogram.py</code> <pre><code>def plot(self, **kwargs: Any):\n    \"\"\"Plotting curves. This also generates the bins of the histograms that are\n    added to the plot. Plot objects are drawn in the same order as they were added\n    to the plot.\n\n    Parameters\n    ----------\n    **kwargs : Any\n        Keyword arguments passed to matplotlib.axes.Axes.hist()\n\n    Returns\n    -------\n    Line2D\n        matplotlib Line2D object\n\n    Raises\n    ------\n    ValueError\n        If specified bins type is not supported.\n    \"\"\"\n    # Get the settings from the to-be-plotted Histogram objects\n    norm_list = [iter_histo.norm for iter_histo in self.plot_objects.values()]\n    bin_edges_list = [iter_histo.bin_edges for iter_histo in self.plot_objects.values()]\n\n    # Check consistency of norm setting\n    self.norm = norm_list[0]\n    if any(n != self.norm for n in norm_list):\n        raise ValueError(\"Histogram objects have different settings for 'norm'!\")\n\n    # Check consistency of bin_edges\n    self.bin_edges = bin_edges_list[0]\n    if any(not np.array_equal(e, self.bin_edges) for e in bin_edges_list):\n        raise ValueError(\"Histogram objects have different 'bin_edges'!\")\n\n    if self.ylabel is not None and self.norm and \"norm\" not in self.ylabel.lower():\n        logger.warning(\n            \"You are plotting normalised distributions but 'norm' is not \"\n            \"included in your y-label.\"\n        )\n\n    if self.norm is True and self.stacked is True:\n        raise ValueError(\n            \"Stacked plots and normalised plots at the same time are not available.\"\n        )\n\n    # Init the plt_handles list\n    plt_handles = []\n\n    # Stacked dict for the stacked histogram\n    self.stacked_dict: dict[str, Any] = {\n        \"x\": [],\n        \"bins\": [],\n        \"weights\": [],\n        \"color\": [],\n        \"unc\": None,\n    }\n\n    for key in self.add_order:\n        elem = self.plot_objects[key]\n\n        # If discrete values were used, adapt the x-axis ticks\n        if elem.discrete_vals is not None:\n            self.axis_top.set_xticks(elem.bin_edges[:-1] + 0.5)\n            self.axis_top.set_xticklabels(elem.discrete_vals, rotation=33)\n\n        # Check if the histogram is data\n        if elem.is_data is True:\n            # Plot data\n            self.axis_top.errorbar(\n                x=(elem.bin_edges[:-1] + elem.bin_edges[1:]) / 2,\n                y=elem.hist,\n                yerr=elem.unc if self.draw_errors else 0,\n                color=elem.colour,\n                label=elem.label,\n                alpha=elem.alpha,\n                linewidth=elem.linewidth,\n                linestyle=elem.linestyle,\n                marker=elem.marker,\n                markersize=elem.markersize,\n            )\n\n            plt_handles.append(\n                mpl.lines.Line2D(\n                    [],\n                    [],\n                    color=elem.colour,\n                    label=elem.label,\n                    alpha=elem.alpha,\n                    linewidth=elem.linewidth,\n                    linestyle=elem.linestyle,\n                    marker=elem.marker,\n                )\n            )\n\n        elif self.stacked:\n            self.stacked_dict[\"x\"].append(elem.bin_edges[:-1])\n            self.stacked_dict[\"bins\"].append(elem.bin_edges)\n            self.stacked_dict[\"weights\"].append(elem.hist)\n            self.stacked_dict[\"color\"].append(elem.colour)\n\n            if self.stacked_dict[\"unc\"] is None:\n                self.stacked_dict[\"unc\"] = elem.unc\n\n            else:\n                self.stacked_dict[\"unc\"] = np.sqrt(self.stacked_dict[\"unc\"] ** 2 + elem.unc**2)\n\n            # Add the element to the legend with a \"bar\"\n            plt_handles.append(\n                mpl.patches.Patch(\n                    color=elem.colour,\n                    label=elem.label,\n                    alpha=elem.alpha,\n                )\n            )\n\n        else:\n            # Plot histogram\n            self.axis_top.hist(\n                x=elem.bin_edges[:-1],\n                bins=elem.bin_edges,\n                weights=elem.hist,\n                histtype=elem.histtype,\n                color=elem.colour,\n                label=elem.label,\n                alpha=elem.alpha,\n                linewidth=elem.linewidth,\n                linestyle=elem.linestyle,\n                **kwargs,\n            )\n\n            # Plot histogram uncertainty\n            if self.draw_errors:\n                bottom_error = np.array([elem.band[0], *elem.band.tolist()])\n                top_error = elem.band + 2 * elem.unc\n                top_error = np.array([top_error[0], *top_error.tolist()])\n                self.axis_top.fill_between(\n                    x=elem.bin_edges,\n                    y1=bottom_error,\n                    y2=top_error,\n                    color=elem.colour,\n                    alpha=0.3,\n                    zorder=1,\n                    step=\"pre\",\n                    edgecolor=\"none\",\n                )\n\n            # Add standard \"Line\" to legend\n            plt_handles.append(\n                mpl.lines.Line2D(\n                    [],\n                    [],\n                    color=elem.colour,\n                    label=elem.label,\n                    alpha=elem.alpha,\n                    linewidth=elem.linewidth,\n                    linestyle=elem.linestyle,\n                    marker=elem.marker,\n                )\n            )\n\n    if self.stacked:\n        self.axis_top.hist(\n            x=self.stacked_dict[\"x\"],\n            bins=self.stacked_dict[\"bins\"][0],\n            weights=self.stacked_dict[\"weights\"],\n            color=self.stacked_dict[\"color\"],\n            histtype=self.histtype,\n            alpha=elem.alpha,\n            linewidth=elem.linewidth,\n            linestyle=elem.linestyle,\n            stacked=self.stacked,\n            **kwargs,\n        )\n\n        # Create a total weights entry to correctly plot the ratio\n        # Total weights is here the y-value of all contributions stacked\n        self.stacked_dict[\"total_weights\"] = np.sum(self.stacked_dict[\"weights\"], axis=0)\n\n    # Check if errors should be drawn\n    # If stacked is true, plot the combined uncertainty\n    if self.draw_errors and self.stacked:\n        # Calculate the y-values of the bottom error\n        bottom_error = self.stacked_dict[\"total_weights\"] - self.stacked_dict[\"unc\"]\n        bottom_error = np.array([bottom_error[0], *bottom_error.tolist()])\n\n        # Calculate the y-values of the top error\n        top_error = self.stacked_dict[\"total_weights\"] + self.stacked_dict[\"unc\"]\n        top_error = np.array([top_error[0], *top_error.tolist()])\n\n        # Fill the space between bottom and top with the unc. band\n        self.axis_top.fill_between(\n            x=elem.bin_edges,\n            y1=bottom_error,\n            y2=top_error,\n            alpha=0.5,\n            zorder=1,\n            step=\"pre\",\n            facecolor=\"white\",\n            edgecolor=\"black\",\n            linewidth=0,\n            hatch=\"/////\",\n        )\n\n        # Add a label for the unc. in the legend\n        plt_handles.append(\n            mpl.patches.Patch(\n                facecolor=\"white\",\n                edgecolor=\"black\",\n                label=\"Stat. unc.\",\n                linewidth=0,\n                alpha=0.5,\n                hatch=\"/////\",\n            )\n        )\n\n    self.plotting_done = True\n    return plt_handles\n</code></pre>"},{"location":"api/histogram/#puma.histogram.HistogramPlot.plot_ratios","title":"<code>plot_ratios</code>","text":"<p>Plotting ratio histograms.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If no reference histogram is defined</p> Source code in <code>puma/histogram.py</code> <pre><code>def plot_ratios(self):\n    \"\"\"Plotting ratio histograms.\n\n    Raises\n    ------\n    ValueError\n        If no reference histogram is defined\n    \"\"\"\n    # Check if this is a stacked plot\n    # Plot ratio only between data and the stacked histos\n    for key in self.add_order:\n        # Get the object which is to be plotted\n        elem = self.plot_objects[key]\n\n        if elem.bin_edges is None:\n            raise ValueError(\n                \"Bin edges of plot object not set. This is done in \"\n                \"histogram_plot.plot(), so it has to be called before \"\n                \"plot_ratios() is called.\"\n            )\n\n        # Check if this is going to be Data/MC (Data/stacked plot)\n        if self.stacked:\n            # Check this is data\n            if not elem.is_data:\n                continue\n\n            # Using the total weights (full stacked histo) as reference for data\n            ratio, ratio_unc = elem.divide_data_mc(\n                ref_hist=self.stacked_dict[\"total_weights\"],\n            )\n\n        else:\n            if len(self.reference_object) == 0:\n                raise ValueError(\"Please specify a reference curve.\")\n\n            ratio, ratio_unc = elem.divide(self.get_reference_histo(elem))\n\n        # Plot the ratio values with the step function\n        if self.stacked:\n            if elem.is_data is True:\n                self.ratio_axes[0].errorbar(\n                    x=(elem.bin_edges[:-1] + elem.bin_edges[1:]) / 2,\n                    y=ratio[1:],\n                    yerr=ratio_unc[1:] if self.draw_errors else 0,\n                    color=elem.colour,\n                    label=elem.label,\n                    alpha=elem.alpha,\n                    linewidth=elem.linewidth,\n                    linestyle=elem.linestyle,\n                    marker=elem.marker,\n                    markersize=elem.markersize,\n                )\n\n        else:\n            self.ratio_axes[0].step(\n                x=elem.bin_edges,\n                y=ratio,\n                color=elem.colour,\n                linewidth=elem.linewidth,\n                linestyle=elem.linestyle,\n            )\n\n            # Plot the ratio uncertainty\n            if self.draw_errors:\n                self.ratio_axes[0].fill_between(\n                    x=elem.bin_edges,\n                    y1=np.nan_to_num(ratio - ratio_unc, nan=0, posinf=0),\n                    y2=np.nan_to_num(ratio + ratio_unc, nan=0, posinf=0),\n                    color=elem.colour,\n                    alpha=0.3,\n                    zorder=1,\n                    step=\"pre\",\n                    edgecolor=\"none\",\n                )\n\n    if self.stacked and self.draw_errors:\n        self.ratio_axes[0].fill_between(\n            x=elem.bin_edges,\n            y1=np.nan_to_num((ratio - ratio_unc) / ratio, nan=0, posinf=0),\n            y2=np.nan_to_num((ratio + ratio_unc) / ratio, nan=0, posinf=0),\n            color=elem.colour,\n            alpha=0.3,\n            zorder=1,\n            step=\"pre\",\n            edgecolor=\"none\",\n        )\n</code></pre>"},{"location":"api/histogram/#puma.histogram.HistogramPlot.set_reference","title":"<code>set_reference</code>","text":"<p>Setting the reference histogram curves used in the ratios.</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>str</code> <p>Unique identifier of histogram object</p> required Source code in <code>puma/histogram.py</code> <pre><code>def set_reference(self, key: str):\n    \"\"\"Setting the reference histogram curves used in the ratios.\n\n    Parameters\n    ----------\n    key : str\n        Unique identifier of histogram object\n    \"\"\"\n    self.reference_object.append(key)\n    logger.debug(\"Adding '%s' to reference histogram(s)\", key)\n</code></pre>"},{"location":"api/int_eff/","title":"Integrated Efficiency","text":""},{"location":"api/int_eff/#puma.integrated_eff.IntegratedEfficiency","title":"<code>puma.integrated_eff.IntegratedEfficiency</code>","text":"<p>               Bases: <code>puma.plot_base.PlotLineObject</code></p> <p>Represent a single IntegratedEfficiency curve.</p> <p>Parameters:</p> Name Type Description Default <code>disc_sig</code> <code>numpy.ndarray</code> <p>Discriminant values for signal</p> required <code>disc_bkg</code> <code>numpy.ndarray</code> <p>Discriminant values for background</p> required <code>key</code> <code>str | None</code> <p>Identifier for IntegratedEfficiency e.g. tagger, by default None</p> <code>None</code> <code>n_vals</code> <code>int</code> <p>Number of values to calculate the efficiency at, by default 500</p> <code>500</code> <code>tagger</code> <code>str | None</code> <p>Tagger name, by default None</p> <code>None</code> <code>flavour</code> <code>str | ftag.Label</code> <p>Flavour label of the jets, by default None</p> <code>None</code> <code>**kwargs</code> <code>typing.Any</code> <p>Keyword arguments passed to <code>puma.PlotLineObject</code></p> <code>{}</code> Source code in <code>puma/integrated_eff.py</code> <pre><code>def __init__(\n    self,\n    disc_sig: np.ndarray,\n    disc_bkg: np.ndarray,\n    key: str | None = None,\n    n_vals: int = 500,\n    tagger: str | None = None,\n    flavour: str | Label = None,\n    **kwargs: Any,\n) -&gt; None:\n    super().__init__(**kwargs)\n    self.disc_sig = np.asarray(disc_sig)\n    self.disc_bkg = np.asarray(disc_bkg)\n    self.n_vals = n_vals\n    self.tagger = cast(str, tagger)\n    self.key = key\n    self.flavour = Flavours[flavour] if isinstance(flavour, str) else flavour\n    if self.label is None and self.flavour is not None:\n        self.label = self.flavour.label\n    self._calc_profile()\n</code></pre>"},{"location":"api/int_eff/#puma.integrated_eff.IntegratedEfficiencyPlot","title":"<code>puma.integrated_eff.IntegratedEfficiencyPlot</code>","text":"<p>               Bases: <code>puma.plot_base.PlotBase</code></p> <p>IntegratedEfficiencyPlot class.</p> <p>Parameters:</p> Name Type Description Default <code>grid</code> <code>bool</code> <p>Set the grid for the plots.</p> <code>True</code> <code>**kwargs</code> <code>typing.Any</code> <p>Keyword arguments from <code>puma.PlotObject</code></p> <code>{}</code> Source code in <code>puma/integrated_eff.py</code> <pre><code>def __init__(self, grid: bool = True, **kwargs: Any) -&gt; None:\n    super().__init__(grid=grid, **kwargs)\n    self.int_effs: dict[str, IntegratedEfficiency] = {}\n    self.tagger_ls: dict[str, str] = {}\n    self.label_colours: dict[str, str] = {}\n    self.leg_tagger_labels: dict[str, str] = {}\n    self.initialise_figure()\n    self.disc_min, self.disc_max = (1e3, -1e3)\n    self.default_linestyles = get_good_linestyles()\n    self.legend_flavs = None\n    self.leg_tagger_loc = \"lower left\"\n\n    self.ymin = 0\n    self.ymax = 1.2\n</code></pre>"},{"location":"api/int_eff/#puma.integrated_eff.IntegratedEfficiencyPlot.add","title":"<code>add</code>","text":"<p>Adding puma.Roc object to figure.</p> <p>Parameters:</p> Name Type Description Default <code>int_eff</code> <code>puma.integrated_eff.IntegratedEfficiency</code> <p>IntegratedEfficiency curve</p> required <code>key</code> <code>str | None</code> <p>Unique identifier for IntegratedEfficiency curve, by default None</p> <code>None</code> <p>Raises:</p> Type Description <code>KeyError</code> <p>If unique identifier key is used twice</p> Source code in <code>puma/integrated_eff.py</code> <pre><code>def add(self, int_eff: IntegratedEfficiency, key: str | None = None):\n    \"\"\"Adding puma.Roc object to figure.\n\n    Parameters\n    ----------\n    int_eff : IntegratedEfficiency\n        IntegratedEfficiency curve\n    key : str | None, optional\n        Unique identifier for IntegratedEfficiency curve, by default None\n\n    Raises\n    ------\n    KeyError\n        If unique identifier key is used twice\n    \"\"\"\n    key = cast(str, key if key is not None else f\"{len(self.int_effs) + 1}\")\n    if key in self.int_effs:\n        raise KeyError(f\"Duplicated key {key} already used for roc unique identifier.\")\n\n    self.int_effs[key] = int_eff\n    # set linestyle\n    if int_eff.tagger not in self.tagger_ls:\n        self.tagger_ls[int_eff.tagger] = (\n            self.default_linestyles[len(self.tagger_ls)]\n            if int_eff.linestyle is None\n            else int_eff.linestyle\n        )\n    elif int_eff.linestyle != self.tagger_ls[int_eff.tagger] and int_eff.linestyle is not None:\n        logger.warning(\n            \"You specified a different linestyle for the same tagger\"\n            \" %s. This will lead to a mismatch in the line colours\"\n            \" and the legend.\",\n            int_eff.tagger,\n        )\n    if int_eff.linestyle is None:\n        int_eff.linestyle = self.tagger_ls[int_eff.tagger]\n\n    # set colours\n    assert isinstance(int_eff.label, str)\n    if int_eff.label not in self.label_colours:\n        if int_eff.flavour is not None:\n            self.label_colours[int_eff.label] = int_eff.flavour.colour\n        else:\n            curr_colours = set(self.label_colours.values())\n            possible_colours = set(get_good_colours()) - curr_colours\n            self.label_colours[int_eff.label] = (\n                possible_colours.pop() if int_eff.colour is None else int_eff.colour\n            )\n    elif int_eff.colour != self.label_colours[int_eff.label] and int_eff.colour is not None:\n        logger.warning(\n            \"You specified a different colour for the same label\"\n            \" %s. This will lead to a mismatch in the line colours\"\n            \" and the legend.\",\n            int_eff.label,\n        )\n    if int_eff.colour is None:\n        int_eff.colour = self.label_colours[int_eff.label]\n</code></pre>"},{"location":"api/int_eff/#puma.integrated_eff.IntegratedEfficiencyPlot.draw","title":"<code>draw</code>","text":"<p>Draw plotting.</p> <p>Parameters:</p> Name Type Description Default <code>x_label</code> <code>str</code> <p>x-axis label, by default Discriminant</p> <code>'Discriminant'</code> Source code in <code>puma/integrated_eff.py</code> <pre><code>def draw(\n    self,\n    x_label: str = \"Discriminant\",\n):\n    \"\"\"Draw plotting.\n\n    Parameters\n    ----------\n    x_label : str, optional\n        x-axis label, by default Discriminant\n    \"\"\"\n    plt_handles = self.plot()\n    xmin, xmax = self.get_xlim_auto()\n\n    self.set_xlim(\n        xmin if self.xmin is None else self.disc_min,\n        xmax if self.xmax is None else self.disc_max,\n    )\n    self.set_title()\n    self.set_y_lim()\n    # self.set_log()\n    self.set_y_lim()\n    self.set_xlabel(label=x_label)\n    self.set_ylabel(self.axis_top, label=\"Integrated efficiency\")\n\n    self.make_legend(plt_handles)\n\n    self.plotting_done = True\n    if self.apply_atlas_style is True:\n        self.atlasify()\n        # atlasify can only handle one legend. Therefore, we remove the frame of\n        # the second legend by hand\n        if self.legend_flavs is not None:\n            self.legend_flavs.set_frame_on(False)\n</code></pre>"},{"location":"api/int_eff/#puma.integrated_eff.IntegratedEfficiencyPlot.get_xlim_auto","title":"<code>get_xlim_auto</code>","text":"<p>Returns min and max efficiency values.</p> <p>Returns:</p> Type Description <code>float</code> <p>Min and max efficiency values</p> Source code in <code>puma/integrated_eff.py</code> <pre><code>def get_xlim_auto(self):\n    \"\"\"Returns min and max efficiency values.\n\n    Returns\n    -------\n    float\n        Min and max efficiency values\n    \"\"\"\n    for elem in self.int_effs.values():\n        self.disc_min = min(np.min(elem.x), self.disc_min)\n        self.disc_max = max(np.max(elem.x), self.disc_max)\n\n    return self.disc_min, self.disc_max\n</code></pre>"},{"location":"api/int_eff/#puma.integrated_eff.IntegratedEfficiencyPlot.make_legend","title":"<code>make_legend</code>","text":"<p>Make legend.</p> <p>Parameters:</p> Name Type Description Default <code>handles</code> <code>list</code> <p>List of handles</p> required Source code in <code>puma/integrated_eff.py</code> <pre><code>def make_legend(self, handles: list):\n    \"\"\"Make legend.\n\n    Parameters\n    ----------\n    handles : list\n        List of handles\n    \"\"\"\n    line_list_tagger = [\n        mpl.lines.Line2D(\n            [],\n            [],\n            color=\"k\",\n            linestyle=self.tagger_ls[tagger],\n            label=tagger,\n        )\n        for tagger in self.tagger_ls\n    ]\n    self.legend_flavs = self.axis_top.legend(\n        handles=line_list_tagger,\n        labels=[handle.get_label() for handle in line_list_tagger],\n        loc=self.leg_tagger_loc,\n        fontsize=self.leg_fontsize,\n        ncol=self.leg_ncol,\n    )\n    self.axis_top.add_artist(self.legend_flavs)\n    # Get the labels for the legends\n    labels_list = []\n    lines_list = []\n\n    for line in handles:\n        if line.get_label() not in labels_list:\n            labels_list.append(line.get_label())\n            lines_list.append(line)\n\n    # Define the legend\n    self.axis_top.legend(\n        handles=lines_list,\n        labels=labels_list,\n        loc=self.leg_loc,\n        fontsize=self.leg_fontsize,\n        ncol=self.leg_ncol,\n    )\n</code></pre>"},{"location":"api/int_eff/#puma.integrated_eff.IntegratedEfficiencyPlot.plot","title":"<code>plot</code>","text":"<p>Plotting integrated efficiency curves.</p> <p>Parameters:</p> Name Type Description Default <code>**kwargs</code> <code>typing.Any</code> <p>Keyword arguments passed to plt.axis.plot</p> <code>{}</code> <p>Returns:</p> Type Description <code>puma.line_plot_2d.Line2D</code> <p>matplotlib Line2D object</p> Source code in <code>puma/integrated_eff.py</code> <pre><code>def plot(self, **kwargs: Any) -&gt; mpl.lines.Line2D:\n    \"\"\"Plotting integrated efficiency curves.\n\n    Parameters\n    ----------\n    **kwargs: Any\n        Keyword arguments passed to plt.axis.plot\n\n    Returns\n    -------\n    Line2D\n        matplotlib Line2D object\n    \"\"\"\n    plt_handles = []\n    for key, elem in self.int_effs.items():\n        plt_handles += self.axis_top.plot(\n            elem.x,\n            elem.eff,\n            linestyle=elem.linestyle,\n            color=elem.colour,\n            label=elem.label if elem is not None else key,\n            zorder=2,\n            **kwargs,\n        )\n    return plt_handles\n</code></pre>"},{"location":"api/matshow_plot/","title":"Matshow Plot","text":""},{"location":"api/matshow_plot/#puma.matshow.MatshowPlot","title":"<code>puma.matshow.MatshowPlot</code>","text":"<p>               Bases: <code>puma.plot_base.PlotBase</code></p> <p>Plot Matrix class.</p> <p>Parameters:</p> Name Type Description Default <code>x_ticklabels</code> <code>list | None</code> <p>Names of the matrix's columns; if None, indices are shown. by default None</p> <code>None</code> <code>x_ticks_rotation</code> <code>int</code> <p>Rotation of the columns' names, by default 90</p> <code>90</code> <code>y_ticklabels</code> <code>list | None</code> <p>Names of the matrix's rows; if None, indices are shown. by default None</p> <code>None</code> <code>show_entries</code> <code>bool</code> <p>If True, show matrix entries as numbers in the matrix pixels. by default True</p> <code>True</code> <code>show_percentage</code> <code>bool</code> <p>If True, if matrix entries are percentages (i.e. numbers in [0,1]), format them as percentages. by default False</p> <code>False</code> <code>text_color_threshold</code> <code>float</code> <p>threshold on the relative luminance of the colormap bkg color after which the text color switches to black, to allow better readability on lighter cmap bkg colors. If 1, all text is white; if 0, all text is black. by default 0.408</p> <code>0.408</code> <code>colormap</code> <code>matplotlib.pyplot.cm</code> <p>Colormap for the plot, by default <code>plt.cm.Oranges</code></p> <code>matplotlib.pyplot.cm.Oranges</code> <code>show_cbar</code> <code>bool</code> <p>Whether to plot the colorbar or not, by default True</p> <code>True</code> <code>cbar_label</code> <code>str | None</code> <p>Label of the colorbar, by default None</p> <code>None</code> <code>**kwargs</code> <code>typing.Any</code> <p>Keyword arguments for <code>puma.PlotObject</code></p> <code>{}</code> Example <p>matrix_plotter = MatshowPlot() mat = np.random.rand(4, 3) matrix_plotter.draw(mat)</p> Source code in <code>puma/matshow.py</code> <pre><code>def __init__(\n    self,\n    x_ticklabels: list | None = None,\n    x_ticks_rotation: int = 90,\n    y_ticklabels: list | None = None,\n    show_entries: bool = True,\n    show_percentage: bool = False,\n    text_color_threshold: float = 0.408,\n    colormap: plt.cm = plt.cm.Oranges,\n    show_cbar: bool = True,\n    cbar_label: str | None = None,\n    **kwargs: Any,\n) -&gt; None:\n    super().__init__(**kwargs)\n\n    self.x_ticklabels = x_ticklabels\n    self.x_ticks_rotation = x_ticks_rotation\n    self.y_ticklabels = y_ticklabels\n    self.show_entries = show_entries\n    self.show_percentage = show_percentage\n    self.text_color_threshold = text_color_threshold\n    self.colormap = colormap\n    self.show_cbar = show_cbar\n    self.cbar_label = cbar_label\n\n    # Specifying figsize if not specified by user\n    if self.figsize is None:\n        self.figsize = (10, 10.5)\n    self.initialise_figure()\n</code></pre>"},{"location":"api/matshow_plot/#puma.matshow.MatshowPlot.__plot","title":"<code>__plot</code>","text":"<p>Plot the Matrix.</p> Source code in <code>puma/matshow.py</code> <pre><code>def __plot(self, matrix: np.ndarray) -&gt; None:\n    \"\"\"Plot the Matrix.\"\"\"\n    n_cols = matrix.shape[1]\n    n_rows = matrix.shape[0]\n\n    # If using percentage values, make the colormap in range [0,1]\n    if self.show_percentage:\n        im = self.axis_top.matshow(matrix * 100, vmin=0, vmax=100, cmap=self.colormap)\n    else:\n        im = self.axis_top.matshow(matrix, cmap=self.colormap)\n\n    # If mat entries have to be plotted\n    if self.show_entries:\n        # Mapping mat values in [0,1], as it's done by matplotlib\n        # to associate them to the colors of the colormap\n        normMat = matrix - np.min(matrix)\n        # Casting to float64 in case the matrix is of integer type\n        normMat = normMat.astype(np.float64)\n        normMat /= np.max(matrix) - np.min(matrix)\n\n        # Adding text values in the matrix pixels\n        for i in range(n_rows):\n            for j in range(n_cols):\n                # Choosing the text color: black if color is light, white if color is dark\n                # Getting the bkg color from the cmap\n                color = self.colormap(normMat[i, j])\n                # Calculating the bkg relative luminance\n                luminance = self._get_luminance(color)\n                # Choosing the appropriate color\n                color = \"white\" if luminance &lt;= self.text_color_threshold else \"black\"\n\n                # If matrix entry is an int, do not show decimals\n                if not self.show_percentage and m.modf(matrix[i, j])[0] == 0:\n                    text = f\"{matrix[i, j]:.0f}\"\n                # Else, round it or show it as percentage\n                else:\n                    text = (\n                        f\"{matrix[i, j]:.3f}\"\n                        if not self.show_percentage\n                        else f\"{matrix[i, j] * 100:.0f}%\"\n                    )\n                # Plotting text\n                self.axis_top.text(\n                    x=j,\n                    y=i,\n                    s=text,\n                    va=\"center\",\n                    ha=\"center\",\n                    c=color,\n                    fontsize=self.fontsize,\n                )\n\n    # inverting y axis to have the diagonal in the common orientation\n    self.axis_top.invert_yaxis()\n\n    if self.show_cbar:\n        # Plotting colorbar\n        divider = make_axes_locatable(self.axis_top)\n        cax = divider.append_axes(\"right\", size=\"5%\", pad=0.1)\n        cbar = self.fig.colorbar(im, cax=cax)\n        # If using percentages, converting cbar labels to percentages\n        if self.show_entries and self.show_percentage:\n            cbar.set_ticks(\n                ticks=np.linspace(0, 100, 5),\n                labels=[f\"{i}%\" for i in np.round(np.linspace(0, 100, 5), 2)],\n                fontsize=self.fontsize,\n            )\n        if self.cbar_label is not None:\n            cbar.ax.set_ylabel(self.cbar_label, fontsize=self.fontsize)\n\n    # Setting tick labels\n    if self.x_ticklabels is None:\n        self.x_ticklabels = [str(i) for i in range(n_cols)]\n        logger.info(\"MatshowPlot: no x_ticklabels given, using indices instead.\")\n    if self.y_ticklabels is None:\n        self.y_ticklabels = [str(i) for i in range(n_rows)]\n        logger.info(\"MatshowPlot: no y_ticklabels given, using indices instead.\")\n\n    # Writing class names on the axes\n    positions = np.array(range(n_cols))\n    self.axis_top.set_xticks(\n        positions + 0.25,\n        labels=self.x_ticklabels,\n        rotation=self.x_ticks_rotation,\n        fontsize=self.fontsize,\n        ha=\"right\",\n    )\n    positions = np.array(range(n_rows))\n    self.axis_top.set_yticks(positions, labels=self.y_ticklabels, fontsize=self.fontsize)\n    # Put xticks to the bottom\n    self.axis_top.xaxis.tick_bottom()\n\n    # Finished plotting, can apply atlas_style\n    self.plotting_done = True\n    # Applying atlas style\n    if self.apply_atlas_style:\n        # Apply ATLAS style\n        self.atlasify()\n\n    # Disable x and y ticks for better appearance\n    self.axis_top.tick_params(\"x\", which=\"both\", top=False, bottom=False)\n    self.axis_top.tick_params(\"y\", which=\"both\", right=False, left=False)\n    # Disable grid for better appearance\n    self.axis_top.grid(False)\n\n    # Setting title and label\n    self.set_xlabel()\n    self.set_ylabel(self.axis_top)\n    self.set_title()\n</code></pre>"},{"location":"api/matshow_plot/#puma.matshow.MatshowPlot.draw","title":"<code>draw</code>","text":"<p>Draw a matrix with the class customized appearance.</p> <p>Parameters:</p> Name Type Description Default <code>matrix</code> <code>numpy.ndarray</code> <p>The matrix to be plotted.</p> required Source code in <code>puma/matshow.py</code> <pre><code>def draw(self, matrix: np.ndarray) -&gt; None:\n    \"\"\"Draw a matrix with the class customized appearance.\n\n    Parameters\n    ----------\n    matrix : np.ndarray\n        The matrix to be plotted.\n    \"\"\"\n    # Checking size consistency of ticklabels\n    if self.x_ticklabels is not None:\n        assert len(self.x_ticklabels) == matrix.shape[1], (\n            \"MatshowPlot: mismatch between x_tickslabels and number of columns in the matrix.\"\n        )\n\n    if self.y_ticklabels is not None:\n        assert len(self.y_ticklabels) == matrix.shape[0], (\n            \"MatshowPlot: mismatch between y_tickslabels and number of rows in the matrix.\"\n        )\n\n    self.__plot(matrix)\n</code></pre>"},{"location":"api/pie_chart/","title":"Pie Chart","text":""},{"location":"api/pie_chart/#puma.pie.PiePlot","title":"<code>puma.pie.PiePlot</code>","text":"<p>               Bases: <code>puma.plot_base.PlotBase</code></p> <p>Pie plot class.</p> <p>Parameters:</p> Name Type Description Default <code>wedge_sizes</code> <code>numpy.ndarray</code> <p>The size of the wedges. Will be translated into the fractions automatically. So they don't have to add up to 1 or 100. The fractional area of each wedge is given by x/sum(x).</p> required <code>colours</code> <code>list | None</code> <p>List of colours for the separate wedges. You have to specify as many colours as you have wedges. Instead, you can also specify a colour scheme with the <code>colour_scheme</code> argument, by default None</p> <code>None</code> <code>colour_scheme</code> <code>str | None</code> <p>Name of the colour schemes as defined in puma.utils.get_good_pie_colours, by default None</p> <code>None</code> <code>labels</code> <code>list | None</code> <p>A sequence of strings providing the labels for each wedge, by default None</p> <code>None</code> <code>draw_legend</code> <code>bool</code> <p>If True, a legend will be drawn on the right side of the plot. If False, the labels will be drawn directly to the wedges. By default True</p> <code>False</code> <code>mpl_pie_kwargs</code> <code>dict | None</code> <p>Keyword arguments that are handed to the matplotlib.pyplot.pie function. All arguments are allowed, except [<code>x</code>, <code>labels</code>, <code>colors</code>], by default None</p> <code>None</code> <code>**kwargs</code> <code>typing.Any</code> <p>Keyword arguments from <code>puma.PlotObject</code></p> <code>{}</code> Source code in <code>puma/pie.py</code> <pre><code>def __init__(\n    self,\n    wedge_sizes: np.ndarray,\n    colours: list | None = None,\n    colour_scheme: str | None = None,\n    labels: list | None = None,\n    draw_legend: bool = False,\n    mpl_pie_kwargs: dict | None = None,\n    **kwargs: Any,\n):\n    super().__init__(vertical_split=draw_legend, **kwargs)\n    self.wedge_sizes = wedge_sizes\n    self.draw_legend = draw_legend\n\n    # set colours\n    if colours is not None:\n        logger.info(\"Using specified colours list.\")\n        self.colours = colours\n    else:\n        # Using one of the colour schemes defined in puma.utils.get_good_pie_colours\n        logger.info(\"Using specified colour scheme (%s).\", colour_scheme)\n        self.colours = get_good_pie_colours(colour_scheme)[: len(wedge_sizes)]\n\n    self.labels = labels if labels is not None else [\"\" for i in range(len(wedge_sizes))]\n\n    # Add some good defaults if not specified:\n    self.mpl_pie_kwargs = {\n        \"autopct\": \"%1.1f%%\",\n        \"startangle\": 90,\n    }\n    # If mpl.pie kwargs were specified, overwrite the defaults\n    if mpl_pie_kwargs is not None:\n        for key, value in mpl_pie_kwargs.items():\n            self.mpl_pie_kwargs[key] = value\n\n    self.initialise_figure()\n    self.plot()\n</code></pre>"},{"location":"api/pie_chart/#puma.pie.PiePlot.plot","title":"<code>plot</code>","text":"<p>Plot the pie chart.</p> Source code in <code>puma/pie.py</code> <pre><code>def plot(\n    self,\n):\n    \"\"\"Plot the pie chart.\"\"\"\n    self.axis_top.pie(\n        x=self.wedge_sizes,\n        labels=None if self.draw_legend else self.labels,\n        colors=self.colours,\n        **self.mpl_pie_kwargs,\n    )\n\n    # If the legend should be drawn, get the handles and plot it on the right axis\n    if self.draw_legend:\n        plt_handles = []\n        for pie_label, pie_colour in zip(self.labels, self.colours, strict=False):\n            plt_handles.append(\n                mpl.patches.Patch(\n                    label=pie_label,\n                    color=pie_colour,\n                )\n            )\n        self.axis_leg.axis(\"off\")\n        self.make_legend(plt_handles, ax_mpl=self.axis_leg)\n    else:\n        self.axis_top.axis(\"equal\")\n\n    self.plotting_done = True\n\n    if self.apply_atlas_style:\n        self.atlasify()\n        # Remove the legend that is automatically created by atlasify\n        if not self.draw_legend:\n            self.axis_top.legend().remove()\n\n    self.set_title()\n    self.set_y_lim()\n</code></pre>"},{"location":"api/plot_base/","title":"Plot Base","text":""},{"location":"api/plot_base/#puma.plot_base.PlotLineObject","title":"<code>puma.plot_base.PlotLineObject</code>  <code>dataclass</code>","text":"<p>Base data class defining properties of a plot object.</p> <p>Attributes:</p> Name Type Description <code>xmin</code> <code>(float | None, optional)</code> <p>Minimum value of the x-axis, by default None</p> <code>xmax</code> <code>(float | None, optional)</code> <p>Maximum value of the x-axis, by default None</p> <code>colour</code> <code>(str | None, optional)</code> <p>Colour of the object, by default None</p> <code>label</code> <code>(str | None, optional)</code> <p>Label of object, by default None</p> <code>linestyle</code> <code>(str | None, optional)</code> <p>Linestyle following numpy style, by default None</p> <code>linewidth</code> <code>(float | None, optional)</code> <p>Linewidth that will be used, by default None</p> <code>alpha</code> <code>(float | None, optional)</code> <p>Value for visibility of the plot lines, by default None</p> <code>marker</code> <code>(str | None, optional)</code> <p>Marker that is used in the plot. For example an x. By default None</p> <code>markersize</code> <code>(int | None, optional)</code> <p>Size of the marker. By default None</p> <code>markeredgewidth</code> <code>(int | None, optional)</code> <p>Edge width of the marker. By default None</p> <code>is_marker</code> <code>(bool | None, optional)</code> <p>Bool, to give info about if this is a marker or a line. By default None</p>"},{"location":"api/plot_base/#puma.plot_base.PlotLineObject.args_to_store","title":"<code>args_to_store</code>  <code>property</code>","text":"<p>Returns the arguments that need to be stored/loaded.</p> <p>Returns:</p> Type Description <code>dict[str, typing.Any]</code> <p>Dict with the arguments</p>"},{"location":"api/plot_base/#puma.plot_base.PlotLineObject.decode","title":"<code>decode</code>  <code>staticmethod</code>","text":"<p>Inverse of encode, turning tags back into real objects.</p> <p>Parameters:</p> Name Type Description Default <code>obj</code> <code>typing.Any</code> <p>Object that is to be decoded</p> required <p>Returns:</p> Type Description <code>typing.Any</code> <p>The decoded object</p> Source code in <code>puma/plot_base.py</code> <pre><code>@staticmethod\ndef decode(obj: Any) -&gt; Any:\n    \"\"\"Inverse of encode, turning tags back into real objects.\n\n    Parameters\n    ----------\n    obj : Any\n        Object that is to be decoded\n\n    Returns\n    -------\n    Any\n        The decoded object\n    \"\"\"\n    # Setup the object so that it can be returned if no decoding is needed\n    decoded: Any = obj\n\n    # If a dict was used, go through and check for types\n    if isinstance(obj, dict):\n        if \"__ndarray__\" in obj:\n            decoded = np.asarray(obj[\"__ndarray__\"], dtype=obj[\"dtype\"])\n        elif \"__label__\" in obj:\n            decoded = Label(**{\n                k: PlotLineObject.decode(v) for k, v in obj[\"__label__\"].items()\n            })\n        elif \"__tuple__\" in obj:\n            decoded = tuple(PlotLineObject.decode(v) for v in obj[\"__tuple__\"])\n        elif \"__cuts__\" in obj:\n            decoded = Cuts(**{k: PlotLineObject.decode(v) for k, v in obj[\"__cuts__\"].items()})\n        elif \"__cut__\" in obj:\n            decoded = Cut(**{k: PlotLineObject.decode(v) for k, v in obj[\"__cut__\"].items()})\n        else:\n            # If it's a regular dict, walk down the keys\n            decoded = {k: PlotLineObject.decode(v) for k, v in obj.items()}\n\n    # If a list was used, check that all sub-objects are correctly loaded\n    elif isinstance(obj, list):\n        decoded = [PlotLineObject.decode(v) for v in obj]\n\n    # If no decoding is needed, return the object\n    return decoded\n</code></pre>"},{"location":"api/plot_base/#puma.plot_base.PlotLineObject.encode","title":"<code>encode</code>  <code>staticmethod</code>","text":"<p>Return a JSON/YAML-safe version of obj, tagging special types.</p> <p>Parameters:</p> Name Type Description Default <code>obj</code> <code>typing.Any</code> <p>Object that is to be encoded</p> required <p>Returns:</p> Type Description <code>typing.Any</code> <p>The encoded object</p> Source code in <code>puma/plot_base.py</code> <pre><code>@staticmethod\ndef encode(obj: Any) -&gt; Any:\n    \"\"\"Return a JSON/YAML-safe version of obj, tagging special types.\n\n    Parameters\n    ----------\n    obj : Any\n        Object that is to be encoded\n\n    Returns\n    -------\n    Any\n        The encoded object\n    \"\"\"\n    # Setup the object so that it can be returned if no encoding is needed\n    encoded: Any = obj\n\n    # Encode special cases which can't be easily stored in json and yaml\n    if isinstance(obj, np.ndarray):\n        encoded = {\"__ndarray__\": obj.tolist(), \"dtype\": str(obj.dtype)}\n    elif isinstance(obj, Label):\n        encoded = {\"__label__\": {k: PlotLineObject.encode(v) for k, v in obj.__dict__.items()}}\n    elif isinstance(obj, tuple):\n        encoded = {\"__tuple__\": [PlotLineObject.encode(v) for v in obj]}\n    elif isinstance(obj, Cuts):\n        encoded = {\"__cuts__\": {k: PlotLineObject.encode(v) for k, v in obj.__dict__.items()}}\n    elif isinstance(obj, Cut):\n        encoded = {\"__cut__\": {k: PlotLineObject.encode(v) for k, v in obj.__dict__.items()}}\n\n    # For lists and dicts, walk through them and ensure correct encoding for sub-objects\n    elif isinstance(obj, list):\n        encoded = [PlotLineObject.encode(v) for v in obj]\n    elif isinstance(obj, dict):\n        encoded = {k: PlotLineObject.encode(v) for k, v in obj.items()}\n\n    # If no encoding is needed, return the object\n    return encoded\n</code></pre>"},{"location":"api/plot_base/#puma.plot_base.PlotLineObject.load","title":"<code>load</code>  <code>classmethod</code>","text":"<p>Load attributes from file and construct the object without init.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>str | pathlib.Path</code> <p>Path in which the attributes are stored.</p> required <code>**extra_kwargs</code> <code>typing.Any</code> <p>Extra kwargs to overwrite certain stored options.</p> <code>{}</code> <p>Returns:</p> Type Description <code>Class Instance</code> <p>Instance of class with the given attributes.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the given file is neither json nor a yaml file.</p> Source code in <code>puma/plot_base.py</code> <pre><code>@classmethod\ndef load(cls, path: str | Path, **extra_kwargs: Any) -&gt; Self:\n    \"\"\"Load attributes from file and construct the object without __init__.\n\n    Parameters\n    ----------\n    path : str | Path\n        Path in which the attributes are stored.\n    **extra_kwargs : Any\n        Extra kwargs to overwrite certain stored options.\n\n    Returns\n    -------\n    Class Instance\n        Instance of class with the given attributes.\n\n    Raises\n    ------\n    ValueError\n        If the given file is neither json nor a yaml file.\n    \"\"\"\n    # Ensure path is a path object\n    path = Path(path)\n\n    # Check if json and load it as such\n    if path.suffix == \".json\":\n        with path.open() as f:\n            data = json.load(f)\n\n    # Check if yaml and load it as such\n    elif path.suffix in {\".yaml\", \".yml\"}:\n        with path.open() as f:\n            data = yaml.safe_load(f)\n\n    # Else ValueError\n    else:\n        raise ValueError(\"Unknown file extension. Use '.json', '.yaml' or '.yml'.\")\n\n    # Convert back to numpy where appropriate\n    data = cls.decode(data)\n\n    # allow caller to override\n    data.update(extra_kwargs)\n\n    # Init the class without running __init__\n    obj: Self = cls.__new__(cls)\n\n    # Set attributes verbatim\n    for key, val in data.items():\n        setattr(obj, key, val)\n    return obj\n</code></pre>"},{"location":"api/plot_base/#puma.plot_base.PlotLineObject.save","title":"<code>save</code>","text":"<p>Store class attributes in a file (json or yaml).</p> <p>Saving can be performed to a yaml and a json file.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>str | pathlib.Path</code> <p>Path to which the class object attributes are written.</p> required <p>Raises:</p> Type Description <code>ValueError</code> <p>If an unknown file extension was given</p> Source code in <code>puma/plot_base.py</code> <pre><code>def save(self, path: str | Path) -&gt; None:\n    \"\"\"Store class attributes in a file (json or yaml).\n\n    Saving can be performed to a yaml and a json file.\n\n    Parameters\n    ----------\n    path : str | Path\n        Path to which the class object attributes are written.\n\n    Raises\n    ------\n    ValueError\n        If an unknown file extension was given\n    \"\"\"\n    # Ensure path is a path object\n    path = Path(path)\n\n    # Get the attributes as a dict\n    data = self.encode(self.args_to_store)\n\n    # Check for json and store it as such\n    if path.suffix == \".json\":\n        with path.open(\"w\") as f:\n            json.dump(data, f, indent=2)\n\n    # Check for yaml and store it as such\n    elif path.suffix in {\".yaml\", \".yml\"}:\n        with path.open(\"w\") as f:\n            yaml.safe_dump(data, f)\n\n    # Else ValueError\n    else:\n        raise ValueError(\"Unknown file extension. Use '.json', '.yaml' or '.yml'!\")\n</code></pre>"},{"location":"api/plot_base/#puma.plot_base.PlotObject","title":"<code>puma.plot_base.PlotObject</code>  <code>dataclass</code>","text":"<p>Data base class defining properties of a plot object.</p> <p>Attributes:</p> Name Type Description <code>title</code> <code>(str, optional)</code> <p>Title of the plot, by default \"\"</p> <code>draw_errors</code> <code>(bool, optional)</code> <p>Draw statistical uncertainty on the lines, by default True</p> <code>xmin</code> <code>(float | None, optional)</code> <p>Minimum value of the x-axis, by default None</p> <code>xmax</code> <code>(float | None, optional)</code> <p>Maximum value of the x-axis, by default None</p> <code>ymin</code> <code>(float | None, optional)</code> <p>Minimum value of the y-axis, by default None</p> <code>ymax</code> <code>(float | None, optional)</code> <p>Maximum value of the y-axis, by default None</p> <code>ymin_ratio</code> <code>(list[float | None] | None, optional)</code> <p>Set the lower y limit of each of the ratio subplots, by default None.</p> <code>ymax_ratio</code> <code>(list[float | None] | None, optional)</code> <p>Set the upper y limit of each of the ratio subplots, by default None.</p> <code>y_scale</code> <code>(float, optional)</code> <p>Scaling up the y axis, e.g. to fit the ATLAS Tag. Applied if ymax not defined, by default 1.3</p> <code>logx</code> <code>(bool, optional)</code> <p>Set the log of x-axis, by default False</p> <code>logy</code> <code>(bool, optional)</code> <p>Set log of y-axis of main panel, by default True</p> <code>xlabel</code> <code>(str | None, optional)</code> <p>Label of the x-axis, by default None</p> <code>ylabel</code> <code>(str | None, optional)</code> <p>Label of the y-axis, by default None</p> <code>ylabel_ratio</code> <code>(list[str] | None, optional)</code> <p>List of labels for the y-axis in the ratio plots, by default \"Ratio\"</p> <code>label_fontsize</code> <code>(int, optional)</code> <p>Used fontsize in label, by default 12</p> <code>fontsize</code> <code>(int, optional)</code> <p>Used fontsize, by default 10</p> <code>n_ratio_panels</code> <code>(int, optional)</code> <p>Amount of ratio panels between 0 and 2, by default 0</p> <code>vertical_split</code> <code>(bool, optional)</code> <p>Set to False if you would like to split the figure horizontally. If set to True the figure is split vertically (e.g. for pie chart), by default False.</p> <code>figsize</code> <code>(tuple[float, float] | None, optional)</code> <p>Tuple of figure size (width, height) in inches, by default None</p> <code>dpi</code> <code>(int, optional)</code> <p>DPI used for plotting, by default 400</p> <code>transparent</code> <code>(bool, optional)</code> <p>Specify if the background of the plot should be transparent, by default False</p> <code>grid</code> <code>(bool, optional)</code> <p>Set the grid for the plots, by default True.</p> <code>figure_layout</code> <code>(str, optional)</code> <p>Set the layout that is used for the plot, by default \"constrained\"</p> <code>leg_fontsize</code> <code>(int | None, optional)</code> <p>Fontsize of the legend, by default None (falls back to fontsize)</p> <code>leg_loc</code> <code>(str, optional)</code> <p>Position of the legend in the plot, by default \"upper right\"</p> <code>leg_linestyle_loc</code> <code>(str, optional)</code> <p>Position of the linestyle legend in the plot, by default \"upper center\"</p> <code>leg_ncol</code> <code>(int, optional)</code> <p>Number of legend columns, by default 1</p> <code>apply_atlas_style</code> <code>(bool, optional)</code> <p>Apply ATLAS style for matplotlib, by default True</p> <code>use_atlas_tag</code> <code>(bool, optional)</code> <p>Use the ATLAS Tag in the plots, by default True</p> <code>atlas_first_tag</code> <code>(str, optional)</code> <p>First row of the ATLAS tag (i.e. \"ATLAS \"), by default \"Simulation Internal\" <code>atlas_second_tag</code> <code>(str | None, optional)</code> <p>Second row of the ATLAS tag, by default None</p> <code>atlas_fontsize</code> <code>(int | None, optional)</code> <p>Fontsize of ATLAS label, by default None (falls back to fontsize)</p> <code>atlas_vertical_offset</code> <code>(float, optional)</code> <p>Vertical offset of the ATLAS tag, by default 7</p> <code>atlas_horizontal_offset</code> <code>(float, optional)</code> <p>Horizontal offset of the ATLAS tag, by default 8</p> <code>atlas_brand</code> <code>(str | None, optional)</code> <p>brand argument handed to atlasify. Use an empty string or None to remove it, by default \"ATLAS\"</p> <code>atlas_tag_outside</code> <code>(bool, optional)</code> <p>outside argument handed to atlasify. Decides if the ATLAS logo is plotted outside of the plot (on top), by default False</p> <code>atlas_second_tag_distance</code> <code>(float, optional)</code> <p>Distance between atlas_first_tag and atlas_second_tag in units of line spacing, by default 0</p> <code>plotting_done</code> <code>(bool, optional)</code> <p>Indicates if plotting is done. Only then atlasify() can be called, by default False</p>"},{"location":"api/plot_base/#puma.plot_base.PlotObject.__check_figsize","title":"<code>__check_figsize</code>","text":"<p>Check <code>figsize</code> is a tuple/list of length 2.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If shape of <code>figsize</code> is not a tuple or list with length 2</p> Source code in <code>puma/plot_base.py</code> <pre><code>def __check_figsize(self) -&gt; None:\n    \"\"\"Check `figsize` is a tuple/list of length 2.\n\n    Raises\n    ------\n    ValueError\n        If shape of `figsize` is not a tuple or list with length 2\n    \"\"\"\n    if self.figsize is None:\n        return\n    if isinstance(self.figsize, list) and len(self.figsize) == 2:\n        self.figsize = tuple(self.figsize)\n    elif not isinstance(self.figsize, tuple) or len(self.figsize) != 2:\n        raise ValueError(\n            f\"You passed `figsize` as {self.figsize} which is not allowed. \"\n            \"Either a tuple or a list of size 2 is allowed\"\n        )\n</code></pre>"},{"location":"api/plot_base/#puma.plot_base.PlotObject.__check_yratio","title":"<code>__check_yratio</code>","text":"<p>Check <code>yratio</code> is a sequence of length n_ratio_panels.</p> <p>Parameters:</p> Name Type Description Default <code>yratio</code> <code>collections.abc.Sequence[float | None] | None</code> <p>List of min or max limits of ratio plots</p> required <p>Raises:</p> Type Description <code>ValueError</code> <p>If <code>yratio</code> is not a list and it's length is not equal to number of ratio panels</p> Source code in <code>puma/plot_base.py</code> <pre><code>def __check_yratio(self, yratio: Sequence[float | None] | None) -&gt; None:\n    \"\"\"Check `yratio` is a sequence of length n_ratio_panels.\n\n    Parameters\n    ----------\n    yratio : Sequence[float | None] | None\n        List of min or max limits of ratio plots\n\n    Raises\n    ------\n    ValueError\n        If `yratio` is not a list and it's length\n        is not equal to number of ratio panels\n    \"\"\"\n    if yratio is None:\n        return\n    if not isinstance(yratio, (list, tuple)) or len(yratio) != self.n_ratio_panels:\n        raise ValueError(\n            f\"You passed `min/max_yratio` as {yratio} which is not allowed. \"\n            f\"Either a tuple or a list of size {self.n_ratio_panels} is allowed\"\n        )\n</code></pre>"},{"location":"api/plot_base/#puma.plot_base.PlotObject.__post_init__","title":"<code>__post_init__</code>","text":"<p>Check for allowed values.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If n_ratio_panels not in [0, 1, 2, 3]</p> Source code in <code>puma/plot_base.py</code> <pre><code>def __post_init__(self) -&gt; None:\n    \"\"\"Check for allowed values.\n\n    Raises\n    ------\n    ValueError\n        If n_ratio_panels not in [0, 1, 2, 3]\n    \"\"\"\n    self.__check_figsize()\n    allowed_n_ratio_panels = [0, 1, 2, 3]\n    if self.n_ratio_panels not in allowed_n_ratio_panels:\n        raise ValueError(\n            f\"{self.n_ratio_panels} not allwed value for `n_ratio_panels`. \"\n            f\"Allowed are {allowed_n_ratio_panels}\"\n        )\n    self.__check_yratio(self.ymin_ratio)\n    self.ymin_ratio = (\n        [None] * self.n_ratio_panels if self.ymin_ratio is None else self.ymin_ratio\n    )\n    self.__check_yratio(self.ymax_ratio)\n    self.ymax_ratio = (\n        [None] * self.n_ratio_panels if self.ymax_ratio is None else self.ymax_ratio\n    )\n\n    if self.ylabel_ratio is None:\n        self.ylabel_ratio = [\"Ratio\"] * self.n_ratio_panels\n    elif isinstance(self.ylabel_ratio, str):\n        self.ylabel_ratio = [self.ylabel_ratio]\n    if len(self.ylabel_ratio) != self.n_ratio_panels:\n        raise ValueError(\n            f\"You passed `ylabel_ratio` of length {len(self.ylabel_ratio)}, \"\n            f\"but `n_ratio_panels` of {self.n_ratio_panels}. \"\n            f\"These should be equal.\"\n        )\n    if self.leg_fontsize is None:\n        self.leg_fontsize = self.fontsize\n    if self.atlas_fontsize is None:\n        self.atlas_fontsize = self.fontsize\n    if not self.apply_atlas_style and (\n        self.atlas_first_tag is not None or self.atlas_second_tag is not None\n    ):\n        logger.warning(\n            \"You specified an ATLAS tag, but `apply_atlas_style` is set to false. \"\n            \"Tag will therefore not be shown on plot.\"\n        )\n</code></pre>"},{"location":"api/plot_base/#puma.plot_base.PlotBase","title":"<code>puma.plot_base.PlotBase</code>","text":"<p>               Bases: <code>puma.plot_base.PlotObject</code></p> <p>Base class for plotting.</p> <p>Parameters:</p> Name Type Description Default <code>**kwargs</code> <code>typing.Any</code> <p>Keyword arguments from <code>puma.PlotObject</code></p> <code>{}</code> Source code in <code>puma/plot_base.py</code> <pre><code>def __init__(self, **kwargs: Any) -&gt; None:\n    super().__init__(**kwargs)\n    self.axis_top: Axes | None = None\n    self.ratio_axes: list[Axes] = []\n    self.axis_leg: Axes | None = None\n    self.fig: Figure | None = None\n</code></pre>"},{"location":"api/plot_base/#puma.plot_base.PlotBase.atlasify","title":"<code>atlasify</code>","text":"<p>Apply ATLAS style to all axes using the atlasify package.</p> <p>Parameters:</p> Name Type Description Default <code>force</code> <code>bool</code> <p>Force ATLAS style also if class variable is False, by default False</p> <code>False</code> Source code in <code>puma/plot_base.py</code> <pre><code>def atlasify(self, force: bool = False) -&gt; None:\n    \"\"\"Apply ATLAS style to all axes using the atlasify package.\n\n    Parameters\n    ----------\n    force : bool, optional\n        Force ATLAS style also if class variable is False, by default False\n    \"\"\"\n    if not self.plotting_done and not force:\n        logger.warning(\n            \"`atlasify()` has to be called after plotting --&gt; \"\n            \"ATLAS style will not be adapted. If you want to do it anyway, \"\n            \"you can use `force`.\"\n        )\n        return\n\n    if self.apply_atlas_style or force:\n        assert self.axis_top is not None\n        logger.debug(\"Initialise ATLAS style using atlasify.\")\n        if self.use_atlas_tag:\n            atlasify.atlasify(\n                atlas=self.atlas_first_tag,\n                subtext=self.atlas_second_tag,\n                axes=self.axis_top,\n                font_size=self.atlas_fontsize,\n                label_font_size=self.atlas_fontsize,\n                sub_font_size=self.atlas_fontsize,\n                offset=self.atlas_vertical_offset,\n                indent=self.atlas_horizontal_offset,\n                enlarge=1,\n                brand=\"\" if self.atlas_brand is None else self.atlas_brand,\n                outside=self.atlas_tag_outside,\n                subtext_distance=self.atlas_second_tag_distance,\n            )\n        else:\n            atlasify.atlasify(atlas=False, axes=self.axis_top, enlarge=1)\n\n        for ratio_axis in self.ratio_axes:\n            atlasify.atlasify(atlas=False, axes=ratio_axis, enlarge=1)\n\n        if self.vertical_split and self.axis_leg is not None:\n            atlasify.atlasify(atlas=False, axes=self.axis_leg, enlarge=1)\n\n        if force:\n            if not self.apply_atlas_style:\n                logger.warning(\n                    \"Initialising ATLAS style even though `apply_atlas_style` is set to False.\"\n                )\n            if not self.plotting_done:\n                logger.warning(\n                    \"Initialising ATLAS style even though `plotting_done` is set to False.\"\n                )\n</code></pre>"},{"location":"api/plot_base/#puma.plot_base.PlotBase.close_window","title":"<code>close_window</code>","text":"<p>Properly close the Tkinter window and exit the main loop.</p> <p>Parameters:</p> Name Type Description Default <code>root</code> <code>tkinter.Tk | None</code> <p>The Tkinter root window instance to be closed.</p> required Source code in <code>puma/plot_base.py</code> <pre><code>def close_window(self, root: tk.Tk | None) -&gt; None:\n    \"\"\"Properly close the Tkinter window and exit the main loop.\n\n    Parameters\n    ----------\n    root : tk.Tk | None\n        The Tkinter root window instance to be closed.\n    \"\"\"\n    if root is not None:\n        logger.debug(\"Closing plot window.\")\n\n        # Stop the Tkinter main loop and destroy the window\n        root.quit()\n        root.destroy()\n\n        # Explicitly delete the root object (optional but helps with garbage collection)\n        del root\n</code></pre>"},{"location":"api/plot_base/#puma.plot_base.PlotBase.draw_vlines","title":"<code>draw_vlines</code>","text":"<p>Draw vertical lines and optional labels on the axes.</p> <p>Parameters:</p> Name Type Description Default <code>xs</code> <code>collections.abc.Sequence[float]</code> <p>List of working points x values to draw</p> required <code>labels</code> <code>collections.abc.Sequence[str | None] | None</code> <p>List with labels for the vertical lines. Must be the same order as the xs. If None, the xvalues * 100 will be used as labels. By default None</p> <code>None</code> <code>ys</code> <code>collections.abc.Sequence[float] | None</code> <p>List with the y height of the vertical lines in percent of the upper plot (0 is bottom, 1 is top). Must be the same order as the xs and the labels. By default None</p> <code>None</code> <code>same_height</code> <code>bool</code> <p>Working point lines on same height, by default False</p> <code>False</code> <code>colour</code> <code>str</code> <p>Colour of the vertical line, by default \"#000000\" (black)</p> <code>'#000000'</code> <code>linestyle</code> <code>str</code> <p>Linestyle of the vertical line, by default \"dashed\"</p> <code>'dashed'</code> <code>fontsize</code> <code>int</code> <p>Fontsize of the vertical line text. By default 10.</p> <code>10</code> Source code in <code>puma/plot_base.py</code> <pre><code>def draw_vlines(\n    self,\n    xs: Sequence[float],\n    labels: Sequence[str | None] | None = None,\n    ys: Sequence[float] | None = None,\n    same_height: bool = False,\n    colour: str = \"#000000\",\n    linestyle: str = \"dashed\",\n    fontsize: int = 10,\n) -&gt; None:\n    \"\"\"Draw vertical lines and optional labels on the axes.\n\n    Parameters\n    ----------\n    xs : Sequence[float]\n        List of working points x values to draw\n    labels : Sequence[str | None] | None, optional\n        List with labels for the vertical lines. Must be the same\n        order as the xs. If None, the xvalues * 100 will be\n        used as labels. By default None\n    ys : Sequence[float] | None, optional\n        List with the y height of the vertical lines in percent of the\n        upper plot (0 is bottom, 1 is top). Must be the same\n        order as the xs and the labels. By default None\n    same_height : bool, optional\n        Working point lines on same height, by default False\n    colour : str, optional\n        Colour of the vertical line, by default \"#000000\" (black)\n    linestyle : str, optional\n        Linestyle of the vertical line, by default \"dashed\"\n    fontsize : int, optional\n        Fontsize of the vertical line text. By default 10.\n    \"\"\"\n    assert self.axis_top is not None\n    for i, vline_x in enumerate(xs):\n        # Set y-point of the WP lines/text\n        ytext = (0.65 if same_height else 0.65 - i * 0.07) if ys is None else ys[i]\n\n        self.axis_top.axvline(\n            x=vline_x,\n            ymax=ytext,\n            color=colour,\n            linestyle=linestyle,\n            linewidth=1.0,\n        )\n\n        # Set the number above the line\n        self.axis_top.text(\n            x=vline_x - 0.005,\n            y=ytext + 0.005,\n            s=(labels[i] if labels else None),\n            transform=self.axis_top.get_xaxis_text1_transform(0)[0],\n            fontsize=fontsize,\n        )\n\n        for ratio_axis in self.ratio_axes:\n            ratio_axis.axvline(x=vline_x, color=colour, linestyle=linestyle, linewidth=1.0)\n</code></pre>"},{"location":"api/plot_base/#puma.plot_base.PlotBase.initialise_figure","title":"<code>initialise_figure</code>","text":"<p>Create matplotlib Figure and subplots based on layout options.</p> Source code in <code>puma/plot_base.py</code> <pre><code>def initialise_figure(self) -&gt; None:\n    \"\"\"Create matplotlib Figure and subplots based on layout options.\"\"\"\n    if self.vertical_split:  # split figure vertically instead of horizonally\n        if self.n_ratio_panels &gt;= 1:\n            logger.warning(\n                \"You set the number of ratio panels to %i but also set the\"\n                \" vertical splitting to True. Therefore no ratiopanels are\"\n                \" created.\",\n                self.n_ratio_panels,\n            )\n        self.fig = Figure(figsize=(6, 4.5) if self.figsize is None else self.figsize)\n        g_spec = gridspec.GridSpec(1, 11, figure=self.fig)\n        self.axis_top = self.fig.add_subplot(g_spec[0, :9])\n        self.axis_leg = self.fig.add_subplot(g_spec[0, 9:])\n\n    else:\n        # you must use increments of 0.1 for the dimensions\n        width = 4.7\n        top_height = 2.7 if self.n_ratio_panels else 3.5\n        ratio_height = 1.0\n        height = top_height + self.n_ratio_panels * ratio_height\n        figsize = (width, height) if self.figsize is None else self.figsize\n        self.fig = Figure(figsize=figsize, layout=self.figure_layout)\n\n        if self.n_ratio_panels == 0:\n            self.axis_top = self.fig.gca()\n        elif self.n_ratio_panels &gt; 0:\n            g_spec_height = (top_height + ratio_height * self.n_ratio_panels) * 10\n            g_spec = gridspec.GridSpec(int(g_spec_height), 1, figure=self.fig)\n            self.axis_top = self.fig.add_subplot(g_spec[: int(top_height * 10), 0])\n            self.set_xaxis_ticklabels_invisible(self.axis_top)\n            for i in range(1, self.n_ratio_panels + 1):\n                start = int((top_height + ratio_height * (i - 1)) * 10)\n                stop = int(start + ratio_height * 10)\n                sub_axis = self.fig.add_subplot(g_spec[start:stop, 0], sharex=self.axis_top)\n                if i &lt; self.n_ratio_panels:\n                    self.set_xaxis_ticklabels_invisible(sub_axis)\n                self.ratio_axes.append(sub_axis)\n\n    # type-narrowing: required before any use\n    assert self.axis_top is not None\n    assert self.fig is not None\n\n    # Add the locator to all axes\n    self.axis_top.yaxis.set_major_locator(\n        locator=MaxNLocator(\n            nbins=\"auto\",\n            prune=\"both\",\n            steps=[1, 2, 5, 10],\n        )\n    )\n    for ratio_axis in self.ratio_axes:\n        ratio_axis.yaxis.set_major_locator(\n            locator=MaxNLocator(\n                nbins=\"auto\",\n                prune=\"both\",\n                steps=[1, 2, 5, 10],\n            )\n        )\n\n    if self.grid:\n        self.axis_top.grid(lw=0.3)\n        for ratio_axis in self.ratio_axes:\n            ratio_axis.grid(lw=0.3)\n</code></pre>"},{"location":"api/plot_base/#puma.plot_base.PlotBase.is_running_in_jupyter","title":"<code>is_running_in_jupyter</code>","text":"<p>Detect if running inside a Jupyter notebook.</p> <p>Returns:</p> Type Description <code>bool</code> <p>If the code is run inside a jupyter notebook</p> Source code in <code>puma/plot_base.py</code> <pre><code>def is_running_in_jupyter(self) -&gt; bool:\n    \"\"\"Detect if running inside a Jupyter notebook.\n\n    Returns\n    -------\n    bool\n        If the code is run inside a jupyter notebook\n    \"\"\"\n    try:\n        shell = get_ipython()\n\n        # Running in standard Python interpreter\n        if shell is None:\n            return False\n\n        shell_name = shell.__class__.__name__\n\n        # Jupyter notebook or qtconsole\n        if shell_name == \"ZMQInteractiveShell\":\n            return True\n\n        # Terminal running IPython\n        if shell_name == \"TerminalInteractiveShell\":\n            return False\n\n    # Probably standard Python interpreter\n    except (NameError, ImportError):\n        return False\n\n    else:\n        # Other type (?)\n        return False\n</code></pre>"},{"location":"api/plot_base/#puma.plot_base.PlotBase.make_legend","title":"<code>make_legend</code>","text":"<p>Draw legend on a given axis.</p> <p>Parameters:</p> Name Type Description Default <code>handles</code> <code>list[matplotlib.lines.Line2D]</code> <p>List of matplotlib.lines.Line2D object returned when plotting</p> required <code>ax_mpl</code> <code>matplotlib.axes.Axes</code> <p><code>matplotlib.axis.Axes</code> object where the legend should be plotted</p> required <code>labels</code> <code>list[str] | None</code> <p>Plot labels. If None, the labels are extracted from the <code>handles</code>. By default None</p> <code>None</code> <code>**kwargs</code> <code>typing.Any</code> <p>Keyword arguments which can be passed to matplotlib axis</p> <code>{}</code> Source code in <code>puma/plot_base.py</code> <pre><code>def make_legend(\n    self,\n    handles: list[lines.Line2D],\n    ax_mpl: Axes,\n    labels: list[str] | None = None,\n    **kwargs: Any,\n) -&gt; None:\n    \"\"\"Draw legend on a given axis.\n\n    Parameters\n    ----------\n    handles : list[lines.Line2D]\n        List of matplotlib.lines.Line2D object returned when plotting\n    ax_mpl : Axes\n        `matplotlib.axis.Axes` object where the legend should be plotted\n    labels : list[str] | None, optional\n        Plot labels. If None, the labels are extracted from the `handles`.\n        By default None\n    **kwargs : Any\n        Keyword arguments which can be passed to matplotlib axis\n    \"\"\"\n    if labels is None:\n        # remove the handles which have label=None\n        handles = [handle for handle in handles if handle.get_label() is not None]\n    ax_mpl.add_artist(\n        ax_mpl.legend(\n            handles=handles,\n            labels=([handle.get_label() for handle in handles] if labels is None else labels),\n            loc=self.leg_loc,\n            fontsize=self.leg_fontsize,\n            ncol=self.leg_ncol,\n            **kwargs,\n        )\n    )\n</code></pre>"},{"location":"api/plot_base/#puma.plot_base.PlotBase.make_linestyle_legend","title":"<code>make_linestyle_legend</code>","text":"<p>Create a legend to indicate what different linestyles correspond to.</p> <p>Parameters:</p> Name Type Description Default <code>linestyles</code> <code>collections.abc.Sequence[str]</code> <p>List of the linestyles to draw in the legend</p> required <code>labels</code> <code>collections.abc.Sequence[str]</code> <p>List of the corresponding labels. Has to be in the same order as the linestyles</p> required <code>loc</code> <code>str | None</code> <p>Location of the legend (matplotlib supported locations), by default None</p> <code>None</code> <code>bbox_to_anchor</code> <code>tuple[float, float] | tuple[float, float, float, float] | None</code> <p>Allows to specify the precise position of this legend. Either a 2-tuple (x, y) or a 4-tuple (x, y, width, height), by default None</p> <code>None</code> <code>axis_for_legend</code> <code>matplotlib.axes.Axes | None</code> <p>Axis on which to draw the legend, by default None</p> <code>None</code> Source code in <code>puma/plot_base.py</code> <pre><code>def make_linestyle_legend(\n    self,\n    linestyles: Sequence[str],\n    labels: Sequence[str],\n    loc: str | None = None,\n    bbox_to_anchor: tuple[float, float] | tuple[float, float, float, float] | None = None,\n    axis_for_legend: Axes | None = None,\n) -&gt; None:\n    \"\"\"Create a legend to indicate what different linestyles correspond to.\n\n    Parameters\n    ----------\n    linestyles : Sequence[str]\n        List of the linestyles to draw in the legend\n    labels : Sequence[str]\n        List of the corresponding labels. Has to be in the same order as the\n        linestyles\n    loc : str | None, optional\n        Location of the legend (matplotlib supported locations), by default None\n    bbox_to_anchor : tuple[float, float] | tuple[float, float, float, float] | None, optional\n        Allows to specify the precise position of this legend. Either a 2-tuple\n        (x, y) or a 4-tuple (x, y, width, height), by default None\n    axis_for_legend : Axes | None, optional\n        Axis on which to draw the legend, by default None\n    \"\"\"\n    axis_for_legend = self.axis_top if axis_for_legend is None else axis_for_legend\n    assert axis_for_legend is not None\n\n    lines_list: list[lines.Line2D] = []\n    for linestyle, label in zip(linestyles, labels, strict=False):\n        lines_list.append(\n            lines.Line2D(\n                [],\n                [],\n                color=\"k\",\n                label=label,\n                linestyle=linestyle,\n            )\n        )\n\n    linestyle_legend = axis_for_legend.legend(\n        handles=lines_list,\n        labels=[handle.get_label() for handle in lines_list],\n        loc=(loc if loc is not None else self.leg_linestyle_loc),\n        fontsize=self.leg_fontsize,\n        bbox_to_anchor=bbox_to_anchor,\n        frameon=False,\n    )\n    axis_for_legend.add_artist(linestyle_legend)\n</code></pre>"},{"location":"api/plot_base/#puma.plot_base.PlotBase.savefig","title":"<code>savefig</code>","text":"<p>Save plot to disk.</p> <p>Parameters:</p> Name Type Description Default <code>plot_name</code> <code>str</code> <p>File name of the plot</p> required <code>transparent</code> <code>bool | None</code> <p>Specify if plot background is transparent, by default False</p> <code>None</code> <code>dpi</code> <code>int | None</code> <p>DPI for plotting, by default 400</p> <code>None</code> <code>**kwargs</code> <code>typing.Any</code> <p>Keyword arguments passed to <code>matplotlib.figure.Figure.savefig()</code></p> <code>{}</code> Source code in <code>puma/plot_base.py</code> <pre><code>def savefig(\n    self,\n    plot_name: str,\n    transparent: bool | None = None,\n    dpi: int | None = None,\n    **kwargs: Any,\n) -&gt; None:\n    \"\"\"Save plot to disk.\n\n    Parameters\n    ----------\n    plot_name : str\n        File name of the plot\n    transparent : bool | None, optional\n        Specify if plot background is transparent, by default False\n    dpi : int | None, optional\n        DPI for plotting, by default 400\n    **kwargs : Any\n        Keyword arguments passed to `matplotlib.figure.Figure.savefig()`\n    \"\"\"\n    assert self.fig is not None\n    logger.debug(\"Saving plot to %s\", plot_name)\n    self.fig.savefig(\n        plot_name,\n        transparent=self.transparent if transparent is None else transparent,\n        dpi=self.dpi if dpi is None else dpi,\n        bbox_inches=\"tight\",\n        pad_inches=0.04,\n        **kwargs,\n    )\n</code></pre>"},{"location":"api/plot_base/#puma.plot_base.PlotBase.set_log","title":"<code>set_log</code>","text":"<p>Set log scale of axes as configured.</p> Source code in <code>puma/plot_base.py</code> <pre><code>def set_log(self) -&gt; None:\n    \"\"\"Set log scale of axes as configured.\"\"\"\n    assert self.axis_top is not None\n    if self.logx:\n        self.axis_top.set_xscale(\"log\")\n        for ratio_axis in self.ratio_axes:\n            ratio_axis.set_xscale(\"log\")\n\n    if self.logy:\n        self.axis_top.set_yscale(\"log\")\n        ymin, ymax = self.axis_top.get_ylim()\n        self.y_scale = ymin * ((ymax / ymin) ** self.y_scale) / ymax\n</code></pre>"},{"location":"api/plot_base/#puma.plot_base.PlotBase.set_ratio_label","title":"<code>set_ratio_label</code>","text":"<p>Associate the rejection class to a ratio panel.</p> <p>Parameters:</p> Name Type Description Default <code>ratio_panel</code> <code>int</code> <p>Index of the ratio panel to label.</p> required <code>label</code> <code>str</code> <p>y-axis label of the ratio panel.</p> required <p>Raises:</p> Type Description <code>ValueError</code> <p>If the requested ratio panel does not exist.</p> Source code in <code>puma/plot_base.py</code> <pre><code>def set_ratio_label(self, ratio_panel: int, label: str) -&gt; None:\n    \"\"\"Associate the rejection class to a ratio panel.\n\n    Parameters\n    ----------\n    ratio_panel : int\n        Index of the ratio panel to label.\n    label : str\n        y-axis label of the ratio panel.\n\n    Raises\n    ------\n    ValueError\n        If the requested ratio panel does not exist.\n    \"\"\"\n    if ratio_panel &gt; self.n_ratio_panels:\n        raise ValueError(f\"Plot has {self.n_ratio_panels} ratio panels, not {ratio_panel}\")\n    assert self.ylabel_ratio is not None\n    self.ylabel_ratio[ratio_panel - 1] = label\n</code></pre>"},{"location":"api/plot_base/#puma.plot_base.PlotBase.set_tick_params","title":"<code>set_tick_params</code>","text":"<p>Set tick params on all relevant axes.</p> <p>Parameters:</p> Name Type Description Default <code>labelsize</code> <code>int | None</code> <p>Label size of x- and y- axis ticks, by default None. If None then using global fontsize</p> <code>None</code> <code>**kwargs</code> <code>typing.Any</code> <p>Keyword arguments passed to <code>matplotlib.axes.Axes.set_xlabel()</code></p> <code>{}</code> Source code in <code>puma/plot_base.py</code> <pre><code>def set_tick_params(self, labelsize: int | None = None, **kwargs: Any) -&gt; None:\n    \"\"\"Set tick params on all relevant axes.\n\n    Parameters\n    ----------\n    labelsize : int | None, optional\n        Label size of x- and y- axis ticks, by default None.\n        If None then using global fontsize\n    **kwargs : Any\n        Keyword arguments passed to `matplotlib.axes.Axes.set_xlabel()`\n    \"\"\"\n    assert self.axis_top is not None\n    labelsize_eff = self.fontsize if labelsize is None else labelsize\n    self.axis_top.tick_params(axis=\"y\", labelsize=labelsize_eff, **kwargs)\n    if self.n_ratio_panels == 0:\n        self.axis_top.tick_params(axis=\"x\", labelsize=labelsize_eff, **kwargs)\n    for i, ratio_axis in enumerate(self.ratio_axes):\n        ratio_axis.tick_params(axis=\"y\", labelsize=labelsize_eff, **kwargs)\n        if i == self.n_ratio_panels - 1:\n            ratio_axis.tick_params(axis=\"x\", labelsize=labelsize_eff, **kwargs)\n</code></pre>"},{"location":"api/plot_base/#puma.plot_base.PlotBase.set_title","title":"<code>set_title</code>","text":"<p>Set title of top panel.</p> <p>Parameters:</p> Name Type Description Default <code>title</code> <code>str | None</code> <p>Title of top panel, if None using the value form the class variables, by default None</p> <code>None</code> <code>**kwargs</code> <code>typing.Any</code> <p>Keyword arguments passed to <code>matplotlib.axes.Axes.set_title()</code></p> <code>{}</code> Source code in <code>puma/plot_base.py</code> <pre><code>def set_title(self, title: str | None = None, **kwargs: Any) -&gt; None:\n    \"\"\"Set title of top panel.\n\n    Parameters\n    ----------\n    title : str | None, optional\n        Title of top panel, if None using the value form the class variables,\n        by default None\n    **kwargs : Any\n        Keyword arguments passed to `matplotlib.axes.Axes.set_title()`\n    \"\"\"\n    assert self.axis_top is not None\n    self.axis_top.set_title(self.title if title is None else title, **kwargs)\n</code></pre>"},{"location":"api/plot_base/#puma.plot_base.PlotBase.set_xaxis_ticklabels_invisible","title":"<code>set_xaxis_ticklabels_invisible</code>","text":"<p>Helper function to set the ticklabels of the xaxis invisible.</p> <p>Parameters:</p> Name Type Description Default <code>ax</code> <code>matplotlib.axes.Axes</code> <p>Axis you want to modify</p> required Source code in <code>puma/plot_base.py</code> <pre><code>def set_xaxis_ticklabels_invisible(self, ax: Axes):\n    \"\"\"Helper function to set the ticklabels of the xaxis invisible.\n\n    Parameters\n    ----------\n    ax : Axes\n        Axis you want to modify\n    \"\"\"\n    for label in ax.get_xticklabels():\n        label.set_visible(False)\n</code></pre>"},{"location":"api/plot_base/#puma.plot_base.PlotBase.set_xlabel","title":"<code>set_xlabel</code>","text":"<p>Set x-axis label on the bottom-most axis.</p> <p>Parameters:</p> Name Type Description Default <code>label</code> <code>str | None</code> <p>x-axis label, by default None</p> <code>None</code> <code>**kwargs</code> <code>typing.Any</code> <p>Keyword arguments passed to <code>matplotlib.axes.Axes.set_xlabel()</code></p> <code>{}</code> Source code in <code>puma/plot_base.py</code> <pre><code>def set_xlabel(self, label: str | None = None, **kwargs: Any) -&gt; None:\n    \"\"\"Set x-axis label on the bottom-most axis.\n\n    Parameters\n    ----------\n    label : str | None, optional\n        x-axis label, by default None\n    **kwargs : Any\n        Keyword arguments passed to `matplotlib.axes.Axes.set_xlabel()`\n    \"\"\"\n    assert self.axis_top is not None\n    xlabel_args = {\n        \"xlabel\": self.xlabel if label is None else label,\n        \"horizontalalignment\": \"right\",\n        \"x\": 1.0,\n        \"fontsize\": self.label_fontsize,\n    }\n    if self.n_ratio_panels == 0:\n        self.axis_top.set_xlabel(**xlabel_args, **kwargs)\n    else:\n        self.ratio_axes[-1].set_xlabel(**xlabel_args, **kwargs)\n</code></pre>"},{"location":"api/plot_base/#puma.plot_base.PlotBase.set_xlim","title":"<code>set_xlim</code>","text":"<p>Set limits of x-axis.</p> <p>Parameters:</p> Name Type Description Default <code>xmin</code> <code>float | None</code> <p>Min of x-axis, by default None</p> <code>None</code> <code>xmax</code> <code>float | None</code> <p>Max of x-axis, by default None</p> <code>None</code> <code>**kwargs</code> <code>typing.Any</code> <p>Keyword arguments passed to <code>matplotlib.axes.Axes.set_xlim()</code></p> <code>{}</code> Source code in <code>puma/plot_base.py</code> <pre><code>def set_xlim(self, xmin: float | None = None, xmax: float | None = None, **kwargs: Any) -&gt; None:\n    \"\"\"Set limits of x-axis.\n\n    Parameters\n    ----------\n    xmin : float | None, optional\n        Min of x-axis, by default None\n    xmax : float | None, optional\n        Max of x-axis, by default None\n    **kwargs : Any\n        Keyword arguments passed to `matplotlib.axes.Axes.set_xlim()`\n    \"\"\"\n    assert self.axis_top is not None\n    self.axis_top.set_xlim(\n        self.xmin if xmin is None else xmin,\n        self.xmax if xmax is None else xmax,\n        **kwargs,\n    )\n</code></pre>"},{"location":"api/plot_base/#puma.plot_base.PlotBase.set_y_lim","title":"<code>set_y_lim</code>","text":"<p>Set limits of y-axis (main and ratios).</p> Source code in <code>puma/plot_base.py</code> <pre><code>def set_y_lim(self) -&gt; None:\n    \"\"\"Set limits of y-axis (main and ratios).\"\"\"\n    assert self.axis_top is not None\n    ymin, ymax = self.axis_top.get_ylim()\n    self.axis_top.set_ylim(\n        self.ymin if self.ymin is not None else ymin,\n        (ymin + (ymax - ymin) * self.y_scale) if self.ymax is None else self.ymax,\n    )\n\n    if self.ymin_ratio is None or self.ymax_ratio is None:\n        return\n\n    for i, ratio_axis in enumerate(self.ratio_axes):\n        if self.ymin_ratio[i] is not None or self.ymax_ratio[i] is not None:\n            ymin_i, ymax_i = ratio_axis.get_ylim()\n            ymin_i = self.ymin_ratio[i] if self.ymin_ratio[i] is not None else ymin_i\n            ymax_i = self.ymax_ratio[i] if self.ymax_ratio[i] is not None else ymax_i\n            ratio_axis.set_ylim(bottom=ymin_i, top=ymax_i)\n</code></pre>"},{"location":"api/plot_base/#puma.plot_base.PlotBase.set_ylabel","title":"<code>set_ylabel</code>","text":"<p>Set y-axis label.</p> <p>Parameters:</p> Name Type Description Default <code>ax_mpl</code> <code>matplotlib.axes.Axes</code> <p>matplotlib axis object</p> required <code>label</code> <code>str | None</code> <p>x-axis label, by default None</p> <code>None</code> <code>align</code> <code>str | None</code> <p>Alignment of y-axis label, by default \"right\"</p> <code>'right'</code> <code>**kwargs</code> <code>typing.Any</code> <p>Keyword arguments passed to <code>matplotlib.axes.Axes.set_ylabel()</code></p> <code>{}</code> Source code in <code>puma/plot_base.py</code> <pre><code>def set_ylabel(\n    self,\n    ax_mpl: Axes,\n    label: str | None = None,\n    align: str | None = \"right\",\n    **kwargs: Any,\n) -&gt; None:\n    \"\"\"Set y-axis label.\n\n    Parameters\n    ----------\n    ax_mpl : Axes\n        matplotlib axis object\n    label : str | None, optional\n        x-axis label, by default None\n    align : str | None, optional\n        Alignment of y-axis label, by default \"right\"\n    **kwargs : Any\n        Keyword arguments passed to `matplotlib.axes.Axes.set_ylabel()`\n    \"\"\"\n    assert self.fig is not None\n    label_options: dict[str, Any] = {\"fontsize\": self.label_fontsize}\n    if align:\n        label_options[\"horizontalalignment\"] = align\n        if align == \"right\":\n            label_options[\"y\"] = 1\n        elif align == \"left\":\n            label_options[\"y\"] = 0\n\n    ax_mpl.set_ylabel(\n        self.ylabel if label is None else label,\n        **label_options,\n        **kwargs,\n    )\n    self.fig.align_labels()\n</code></pre>"},{"location":"api/plot_base/#puma.plot_base.PlotBase.show","title":"<code>show</code>","text":"<p>Show the plot using tkinter in CLI and detect Jupyter to avoid issues.</p> <p>Parameters:</p> Name Type Description Default <code>auto_close_after</code> <code>int | None</code> <p>After how many milliseconds, the window is automatically closed, by default None</p> <code>None</code> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the figure is not initalized yet</p> Source code in <code>puma/plot_base.py</code> <pre><code>def show(self, auto_close_after: int | None = None) -&gt; None:\n    \"\"\"Show the plot using tkinter in CLI and detect Jupyter to avoid issues.\n\n    Parameters\n    ----------\n    auto_close_after : int | None, optional\n        After how many milliseconds, the window is automatically closed, by default None\n\n    Raises\n    ------\n    ValueError\n        If the figure is not initalized yet\n    \"\"\"\n    if self.is_running_in_jupyter():\n        logger.debug(\"Detected Jupyter Notebook, displaying inline.\")\n        assert self.fig is not None\n        display(self.fig)\n        return\n\n    logger.debug(\"Showing plot using tkinter\")\n\n    # Ensure figure is initialized\n    if self.fig is None:\n        raise ValueError(\"You need to initalize the figure before using show().\")\n\n    # Create the Tkinter root window\n    root = tk.Tk()\n    root.title(\"Plot Display\")\n\n    # Embed the figure into a Tkinter canvas\n    canvas = FigureCanvasTkAgg(self.fig, master=root)\n    canvas_widget = canvas.get_tk_widget()\n    canvas_widget.pack(fill=\"both\", expand=True)\n\n    # Render the figure\n    canvas.draw()\n\n    # If auto_close_after is set, close the window automatically\n    if auto_close_after:\n        logger.debug(f\"Auto-closing window after {auto_close_after} ms\")\n        root.after(auto_close_after, lambda: self.close_window(root))\n\n    # Handle window close event manually\n    root.protocol(\"WM_DELETE_WINDOW\", lambda: self.close_window(root))\n\n    # Start Tkinter event loop\n    root.mainloop()\n</code></pre>"},{"location":"api/roc/","title":"ROC","text":""},{"location":"api/roc/#puma.roc.Roc","title":"<code>puma.roc.Roc</code>","text":"<p>               Bases: <code>puma.plot_base.PlotLineObject</code></p> <p>Represent a single ROC curve and allows to calculate ratio w.r.t other ROCs.</p> <p>Parameters:</p> Name Type Description Default <code>sig_eff</code> <code>numpy.ndarray</code> <p>Array of signal efficiencies</p> required <code>bkg_rej</code> <code>numpy.ndarray</code> <p>Array of background rejection</p> required <code>n_test</code> <code>int | None</code> <p>Number of events used to calculate the background efficiencies, by default None</p> <code>None</code> <code>rej_class</code> <code>str | ftag.Label</code> <p>Rejection class, e.g. for b-tagging anc charm rejection \"cjets\", by default None</p> <code>None</code> <code>signal_class</code> <code>str | None</code> <p>Signal class, e.g. for b-tagging \"bjets\", by default None</p> <code>None</code> <code>key</code> <code>str | None</code> <p>Identifier for roc curve e.g. tagger, by default None</p> <code>None</code> <code>ratio_group</code> <code>str | None</code> <p>Identifies the reference ROC group for ratio calculation, by default None</p> <code>None</code> <code>use_bkg_eff</code> <code>bool</code> <p>Correct error calculation for background efficiency ROCs instead of background rejection, by default False</p> <code>False</code> <code>**kwargs</code> <code>typing.Any</code> <p>Keyword arguments passed to <code>puma.PlotLineObject</code></p> <code>{}</code> <p>Raises:</p> Type Description <code>ValueError</code> <p>If <code>sig_eff</code> and <code>bkg_rej</code> have a different shape</p> Source code in <code>puma/roc.py</code> <pre><code>def __init__(\n    self,\n    sig_eff: np.ndarray,\n    bkg_rej: np.ndarray,\n    n_test: int | None = None,\n    rej_class: str | Label = None,\n    signal_class: str | None = None,\n    key: str | None = None,\n    ratio_group: str | None = None,\n    use_bkg_eff: bool = False,\n    **kwargs: Any,\n) -&gt; None:\n    super().__init__(**kwargs)\n    if len(sig_eff) != len(bkg_rej):\n        raise ValueError(\n            f\"The shape of `sig_eff` ({np.shape(sig_eff)}) and `bkg_rej` \"\n            f\"({np.shape(bkg_rej)}) have to be identical.\"\n        )\n    self.sig_eff = sig_eff\n    self.bkg_rej = bkg_rej\n    self.n_test = None if n_test is None else int(n_test)\n    self.signal_class = signal_class\n    self.rej_class = rej_class.name if isinstance(rej_class, Label) else rej_class\n    self.key = key\n    self.ratio_group = ratio_group or str(rej_class)\n    self.use_bkg_eff = use_bkg_eff\n    self.kwargs = kwargs\n\n    # Check that the rejection class is a string\n    if self.rej_class and not isinstance(self.rej_class, str):\n        raise ValueError(\n            f\"'rej_class' must either be a string or a Label! You gave {type(self.rej_class)}\"\n        )\n</code></pre>"},{"location":"api/roc/#puma.roc.Roc.args_to_store","title":"<code>args_to_store</code>  <code>property</code>","text":"<p>Returns the arguments that need to be stored/loaded.</p> <p>Returns:</p> Type Description <code>dict[str, typing.Any]</code> <p>Dict with the arguments</p>"},{"location":"api/roc/#puma.roc.Roc.non_zero","title":"<code>non_zero</code>  <code>property</code>","text":"<p>Abstraction of <code>non_zero_mask</code>.</p> <p>Returns:</p> Type Description <code>numpy.array</code> <p>Masked signal efficiency</p> <code>numpy.array</code> <p>Masked background rejection</p>"},{"location":"api/roc/#puma.roc.Roc.non_zero_mask","title":"<code>non_zero_mask</code>  <code>property</code>","text":"<p>Masking points where rejection is 0 and no signal efficiency change present.</p> <p>Returns:</p> Type Description <code>numpy.array</code> <p>Masked indices</p>"},{"location":"api/roc/#puma.roc.Roc.binomial_error","title":"<code>binomial_error</code>","text":"<p>Calculate binomial error of roc curve.</p> <p>Parameters:</p> Name Type Description Default <code>norm</code> <code>bool</code> <p>If True calulate relative error, by default False</p> <code>False</code> <code>n_test</code> <code>int | None</code> <p>Number of events used to calculate the background efficiencies, by default None</p> <code>None</code> <p>Returns:</p> Type Description <code>numpy.ndarray</code> <p>Binomial error</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If no <code>n_test</code> was provided</p> Source code in <code>puma/roc.py</code> <pre><code>def binomial_error(self, norm: bool = False, n_test: int | None = None) -&gt; np.ndarray:\n    \"\"\"Calculate binomial error of roc curve.\n\n    Parameters\n    ----------\n    norm : bool, optional\n        If True calulate relative error, by default False\n    n_test : int | None\n        Number of events used to calculate the background efficiencies,\n        by default None\n\n    Returns\n    -------\n    np.ndarray\n        Binomial error\n\n    Raises\n    ------\n    ValueError\n        If no `n_test` was provided\n    \"\"\"\n    if n_test is None:\n        n_test = self.n_test\n    if n_test is None:\n        raise ValueError(\"No `n_test` provided, cannot calculate binomial error!\")\n    if self.use_bkg_eff:\n        return calculate_efficiency_error(self.bkg_rej[self.non_zero_mask], n_test, norm=norm)\n    return calculate_rejection_error(self.bkg_rej[self.non_zero_mask], n_test, norm=norm)\n</code></pre>"},{"location":"api/roc/#puma.roc.Roc.divide","title":"<code>divide</code>","text":"<p>Calculate ratio between the roc curve and another roc.</p> <p>Parameters:</p> Name Type Description Default <code>roc_comp</code> <code>puma.roc.Roc</code> <p>Second roc curve to calculate ratio with</p> required <code>inverse</code> <code>bool</code> <p>If False the ratio is calculated <code>this_roc / roc_comp</code>, if True the inverse is calculated</p> <code>False</code> <p>Returns:</p> Type Description <code>tuple[numpy.ndarray, numpy.ndarray, numpy.ndarray]</code> <p>The signal efficiency used for the ratio calculation which is the overlapping interval of the two roc curves The ratio between the two ROCs The ratio error between the two ROCs</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the signal efficiency between the two ROCs do not match</p> Source code in <code>puma/roc.py</code> <pre><code>def divide(\n    self,\n    roc_comp: Roc,\n    inverse: bool = False,\n) -&gt; tuple[np.ndarray, np.ndarray, np.ndarray]:\n    \"\"\"Calculate ratio between the roc curve and another roc.\n\n    Parameters\n    ----------\n    roc_comp : Roc\n        Second roc curve to calculate ratio with\n    inverse : bool\n        If False the ratio is calculated `this_roc / roc_comp`,\n        if True the inverse is calculated\n\n    Returns\n    -------\n    tuple[np.ndarray, np.ndarray, np.ndarray]\n        The signal efficiency used for the ratio calculation which is the overlapping\n        interval of the two roc curves\n        The ratio between the two ROCs\n        The ratio error between the two ROCs\n\n    Raises\n    ------\n    ValueError\n        If the signal efficiency between the two ROCs do not match\n    \"\"\"\n    if not np.array_equal(self.sig_eff, roc_comp.sig_eff):\n        raise ValueError(\"Signal efficiencies of the two ROCs do not match.\")\n\n    ratio = self.bkg_rej / roc_comp.bkg_rej\n    if inverse:\n        ratio = 1 / ratio\n\n    ratio_err = self.binomial_error(norm=True) * ratio if self.n_test else None\n    return self.sig_eff, ratio, ratio_err\n</code></pre>"},{"location":"api/roc/#puma.roc.RocPlot","title":"<code>puma.roc.RocPlot</code>","text":"<p>               Bases: <code>puma.plot_base.PlotBase</code></p> <p>ROC plot class.</p> <p>Parameters:</p> Name Type Description Default <code>grid</code> <code>bool</code> <p>Set the grid for the plots.</p> <code>True</code> <code>**kwargs</code> <code>typing.Any</code> <p>Keyword arguments from <code>puma.PlotObject</code></p> <code>{}</code> Source code in <code>puma/roc.py</code> <pre><code>def __init__(self, grid: bool = True, **kwargs: Any) -&gt; None:\n    super().__init__(grid=grid, **kwargs)\n    self.test = \"\"\n    self.rocs: dict[str, Roc] = {}\n    self.roc_ratios: dict[str, tuple] = {}\n    self.rej_axes: dict[str, Axes] = {}\n    self.rej_class_ls: dict[str, str] = {}\n    self.label_colours: dict[Any, str] = {}\n    self.leg_rej_labels: dict[str, str] = {}\n    self.reference_roc: dict[Label, dict[str, str]] = {}\n    self.initialise_figure()\n    self.fig.get_layout_engine().set(h_pad=0, hspace=0)\n    self.eff_min, self.eff_max = (1, 0)\n    self.default_linestyles = get_good_linestyles()\n    self.legend_flavs = None\n    self.rej_leg_loc = \"ratio\" if kwargs[\"n_ratio_panels\"] &gt; 0 else \"lower left\"\n</code></pre>"},{"location":"api/roc/#puma.roc.RocPlot.add_ratios","title":"<code>add_ratios</code>","text":"<p>Calculating ratios.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If number of reference rocs and ratio panels don't match If no ratio classes are set</p> Source code in <code>puma/roc.py</code> <pre><code>def add_ratios(self) -&gt; None:\n    \"\"\"Calculating ratios.\n\n    Raises\n    ------\n    ValueError\n        If number of reference rocs and ratio panels don't match\n        If no ratio classes are set\n    \"\"\"\n    if self.reference_roc and len(self.reference_roc) != self.n_ratio_panels:\n        raise ValueError(\n            f\"{len(self.reference_roc)} reference rocs defined but requested \"\n            f\"{self.n_ratio_panels} ratio panels.\"\n        )\n    if len(self.rej_axes) != self.n_ratio_panels:\n        raise ValueError(\"Ratio classes not set, set them first with `set_ratio_class`.\")\n\n    for rej_class, axis in self.rej_axes.items():\n        self.plot_ratios(axis=axis, rej_class=rej_class)\n</code></pre>"},{"location":"api/roc/#puma.roc.RocPlot.add_roc","title":"<code>add_roc</code>","text":"<p>Adding puma.Roc object to figure.</p> <p>Parameters:</p> Name Type Description Default <code>roc_curve</code> <code>puma.roc.Roc</code> <p>ROC curve</p> required <code>key</code> <code>str | None</code> <p>Unique identifier for roc_curve, by default None</p> <code>None</code> <code>reference</code> <code>bool</code> <p>If roc is used as reference for ratio calculation, by default False</p> <code>False</code> <p>Raises:</p> Type Description <code>KeyError</code> <p>If unique identifier key is used twice</p> Source code in <code>puma/roc.py</code> <pre><code>def add_roc(\n    self,\n    roc_curve: Roc,\n    key: str | None = None,\n    reference: bool = False,\n) -&gt; None:\n    \"\"\"Adding puma.Roc object to figure.\n\n    Parameters\n    ----------\n    roc_curve : Roc\n        ROC curve\n    key : str | None, optional\n        Unique identifier for roc_curve, by default None\n    reference : bool, optional\n        If roc is used as reference for ratio calculation, by default False\n\n    Raises\n    ------\n    KeyError\n        If unique identifier key is used twice\n    \"\"\"\n    key = cast(str, key if key is not None else f\"{len(self.rocs) + 1}\")\n\n    if key in self.rocs:\n        raise KeyError(f\"Duplicated key {key} already used for roc unique identifier.\")\n\n    self.rocs[key] = roc_curve\n    # set linestyle\n    if roc_curve.rej_class not in self.rej_class_ls:\n        self.rej_class_ls[roc_curve.rej_class] = (\n            self.default_linestyles[len(self.rej_class_ls)]\n            if roc_curve.linestyle is None\n            else roc_curve.linestyle\n        )\n    elif (\n        roc_curve.linestyle != self.rej_class_ls[roc_curve.rej_class]\n        and roc_curve.linestyle is not None\n    ):\n        logger.warning(\n            \"You specified a different linestyle for the same rejection class \"\n            \"%s. Will keep the linestyle defined first.\",\n            roc_curve.rej_class,\n        )\n    if roc_curve.linestyle is None:\n        roc_curve.linestyle = self.rej_class_ls[roc_curve.rej_class]\n\n    # set colours\n    if roc_curve.label not in self.label_colours:\n        self.label_colours[roc_curve.label] = (\n            get_good_colours()[len(self.label_colours)]\n            if roc_curve.colour is None\n            else roc_curve.colour\n        )\n    elif (\n        roc_curve.colour != self.label_colours[roc_curve.label] and roc_curve.colour is not None\n    ):\n        logger.warning(\n            \"You specified a different colour for the same label\"\n            \" %s. This will lead to a mismatch in the line colours\"\n            \" and the legend.\",\n            roc_curve.label,\n        )\n    if roc_curve.colour is None:\n        roc_curve.colour = self.label_colours[roc_curve.label]\n\n    if reference:\n        logger.debug(\"Setting roc %s as reference for %s.\", key, roc_curve.rej_class)\n        self.set_roc_reference(\n            key=key,\n            rej_class=roc_curve.rej_class,\n            ratio_group=roc_curve.ratio_group,\n        )\n        self.reference_label = roc_curve.label\n</code></pre>"},{"location":"api/roc/#puma.roc.RocPlot.draw","title":"<code>draw</code>","text":"<p>Draw plotting.</p> <p>Parameters:</p> Name Type Description Default <code>labelpad</code> <code>int | None</code> <p>Spacing in points from the axes bounding box including ticks and tick labels, by default None</p> <code>None</code> Source code in <code>puma/roc.py</code> <pre><code>def draw(\n    self,\n    labelpad: int | None = None,\n):\n    \"\"\"Draw plotting.\n\n    Parameters\n    ----------\n    labelpad : int | None, optional\n        Spacing in points from the axes bounding box including\n        ticks and tick labels, by default None\n    \"\"\"\n    plt_handles = self.plot_roc()\n    xmin, xmax = self.get_xlim_auto()\n\n    self.set_xlim(\n        xmin if self.xmin is None else self.xmin,\n        xmax if self.xmax is None else self.xmax,\n    )\n    if self.n_ratio_panels &gt; 0:\n        self.add_ratios()\n    self.set_title()\n    self.set_log()\n    self.set_y_lim()\n    self.set_xlabel()\n    self.set_ylabel(self.axis_top)\n\n    common_ratio_ylabel_text = None\n    if self.n_ratio_panels &gt; 0 and hasattr(self, \"reference_label\") and self.reference_label:\n        common_ratio_ylabel_text = f\"Ratio to {self.reference_label}\"\n\n    if self.n_ratio_panels &lt; 2:\n        self.make_legend(plt_handles, ax_mpl=self.axis_top)\n    else:\n        if not self.leg_rej_labels:\n            for rej_class in self.rej_axes:\n                self.leg_rej_labels[rej_class] = rej_class\n        self.make_split_legend(handles=plt_handles)\n\n    self.plotting_done = True\n    if self.apply_atlas_style is True:\n        self.atlasify()\n        # atlasify can only handle one legend. Therefore, we remove the frame of\n        # the second legend by hand\n        if self.legend_flavs is not None:\n            self.legend_flavs.set_frame_on(False)\n\n    # Ensure the figure layout is calculated before getting extents\n    self.fig.canvas.draw_idle()\n\n    # Add the common ratio label as figure text if it exists\n    if common_ratio_ylabel_text and self.axis_top.yaxis.get_label().get_text():\n        main_ylabel_obj = self.axis_top.yaxis.get_label()\n        renderer = self.fig.canvas.get_renderer()\n        main_ylabel_disp_bbox = main_ylabel_obj.get_window_extent(renderer=renderer)\n        main_ylabel_fig_bbox = main_ylabel_disp_bbox.transformed(\n            self.fig.transFigure.inverted()\n        )\n\n        ratio_ylabel_offset = 0\n        if labelpad:\n            fig_width_inches = self.fig.get_figwidth()\n            # The default labelpad for the axis_top is 4 points\n            ratio_ylabel_offset_inchs = (labelpad - 4) / 72\n            ratio_ylabel_offset = ratio_ylabel_offset_inchs / fig_width_inches\n\n        fig_text_x = main_ylabel_fig_bbox.x0 - ratio_ylabel_offset\n        last_ratio_ax_bbox_fig = self.ratio_axes[-1].get_position()\n        fig_text_y = last_ratio_ax_bbox_fig.y0\n\n        self.fig.text(\n            fig_text_x,\n            fig_text_y,\n            common_ratio_ylabel_text,\n            rotation=\"vertical\",\n            va=\"baseline\",\n            ha=\"left\",\n            fontsize=self.label_fontsize,\n            transform=self.fig.transFigure,\n        )\n\n    adjust_ylabels(self.fig, self.rej_axes.values())\n</code></pre>"},{"location":"api/roc/#puma.roc.RocPlot.get_xlim_auto","title":"<code>get_xlim_auto</code>","text":"<p>Returns min and max efficiency values.</p> <p>Returns:</p> Type Description <code>float</code> <p>Min and max efficiency values</p> Source code in <code>puma/roc.py</code> <pre><code>def get_xlim_auto(self) -&gt; tuple[float, float]:\n    \"\"\"Returns min and max efficiency values.\n\n    Returns\n    -------\n    float\n        Min and max efficiency values\n    \"\"\"\n    for elem in self.rocs.values():\n        self.eff_min = min(np.min(elem.sig_eff), self.eff_min)\n        self.eff_max = max(np.max(elem.sig_eff), self.eff_min)\n\n    return self.eff_min, self.eff_max\n</code></pre>"},{"location":"api/roc/#puma.roc.RocPlot.make_split_legend","title":"<code>make_split_legend</code>","text":"<p>Draw legend for the case of 2 ratios, splitting up legend into models and rejection class.</p> <p>Parameters:</p> Name Type Description Default <code>handles</code> <code>list</code> <p>List of Line2D objects to extract info for legend</p> required <p>Raises:</p> Type Description <code>ValueError</code> <p>If not 2 ratios requested</p> Source code in <code>puma/roc.py</code> <pre><code>def make_split_legend(self, handles: list) -&gt; None:\n    \"\"\"Draw legend for the case of 2 ratios, splitting up legend into models and\n    rejection class.\n\n    Parameters\n    ----------\n    handles : list\n        List of Line2D objects to extract info for legend\n\n    Raises\n    ------\n    ValueError\n        If not 2 ratios requested\n    \"\"\"\n    if self.n_ratio_panels &lt; 2:\n        raise ValueError(\"For a split legend you need 2 ratio panels.\")\n\n    if self.rej_leg_loc == \"ratio\":\n        for rej_class, axis in self.rej_axes.items():\n            legend_line = mpl.lines.Line2D(\n                [],\n                [],\n                color=\"k\",\n                label=self.leg_rej_labels[rej_class],\n                linestyle=self.rej_class_ls[rej_class],\n            )\n            axis.legend(\n                handles=[legend_line],\n                labels=[legend_line.get_label()],\n                loc=\"upper right\",\n                fontsize=self.leg_fontsize,\n            )\n\n    else:\n        line_list_rej = [\n            mpl.lines.Line2D(\n                [],\n                [],\n                color=\"k\",\n                label=self.leg_rej_labels[rej_class],\n                linestyle=self.rej_class_ls[rej_class],\n            )\n            for rej_class in self.rej_axes\n        ]\n\n        self.legend_flavs = self.axis_top.legend(\n            handles=line_list_rej,\n            labels=[handle.get_label() for handle in line_list_rej],\n            loc=self.rej_leg_loc,\n            fontsize=self.leg_fontsize,\n            ncol=self.leg_ncol,\n        )\n\n        # Add the second legend to plot\n        self.axis_top.add_artist(self.legend_flavs)\n\n    # Get the labels for the legends\n    labels_list = []\n    lines_list = []\n\n    for line in handles:\n        if line.get_label() not in labels_list:\n            labels_list.append(line.get_label())\n            lines_list.append(line)\n\n    # Define the legend\n    self.axis_top.legend(\n        handles=lines_list,\n        labels=labels_list,\n        loc=self.leg_loc,\n        fontsize=self.leg_fontsize,\n        ncol=self.leg_ncol,\n    )\n</code></pre>"},{"location":"api/roc/#puma.roc.RocPlot.plot_ratios","title":"<code>plot_ratios</code>","text":"<p>Plotting ratio curves.</p> <p>Parameters:</p> Name Type Description Default <code>axis</code> <code>matplotlib.pyplot.axis</code> <p>matplotlib axis object</p> required <code>rej_class</code> <code>str</code> <p>Rejection class</p> required Source code in <code>puma/roc.py</code> <pre><code>def plot_ratios(self, axis: plt.axis, rej_class: str) -&gt; None:\n    \"\"\"Plotting ratio curves.\n\n    Parameters\n    ----------\n    axis : plt.axis\n        matplotlib axis object\n    rej_class : str\n        Rejection class\n    \"\"\"\n    for key, elem in self.rocs.items():\n        if elem.rej_class != rej_class:\n            continue\n        sig_eff, ratio, ratio_err = elem.divide(\n            self.rocs[self.reference_roc[rej_class][elem.ratio_group]]\n        )\n\n        self.roc_ratios[key] = (sig_eff, ratio, ratio_err)\n        axis.plot(\n            sig_eff,\n            ratio,\n            color=elem.colour,\n            linestyle=elem.linestyle,\n            linewidth=2.0,\n        )\n        if ratio_err is not None:\n            axis.fill_between(\n                sig_eff,\n                ratio - ratio_err,\n                ratio + ratio_err,\n                color=elem.colour,\n                alpha=0.25,\n                edgecolor=\"none\",\n                zorder=1,\n            )\n</code></pre>"},{"location":"api/roc/#puma.roc.RocPlot.plot_roc","title":"<code>plot_roc</code>","text":"<p>Plotting roc curves.</p> <p>Parameters:</p> Name Type Description Default <code>**kwargs</code> <code>typing.Any</code> <p>Keyword arguments passed to plt.axis.plot</p> <code>{}</code> <p>Returns:</p> Type Description <code>puma.line_plot_2d.Line2D</code> <p>matplotlib Line2D object</p> Source code in <code>puma/roc.py</code> <pre><code>def plot_roc(self, **kwargs: Any) -&gt; mpl.lines.Line2D:\n    \"\"\"Plotting roc curves.\n\n    Parameters\n    ----------\n    **kwargs: Any\n        Keyword arguments passed to plt.axis.plot\n\n    Returns\n    -------\n    Line2D\n        matplotlib Line2D object\n    \"\"\"\n    plt_handles = []\n    for key, elem in self.rocs.items():\n        plt_handles += self.axis_top.plot(\n            elem.sig_eff[elem.non_zero_mask],\n            elem.bkg_rej[elem.non_zero_mask],\n            linestyle=elem.linestyle,\n            linewidth=2,\n            color=elem.colour,\n            label=elem.label if elem is not None else key,\n            zorder=2,\n            **kwargs,\n        )\n        if elem.n_test is not None:\n            # if uncertainties are available for roc plotting their uncertainty as\n            # a band around the roc itself\n            rej_band_down = (\n                elem.bkg_rej[elem.non_zero_mask] - elem.binomial_error()[elem.non_zero_mask]\n            )\n            rej_band_up = (\n                elem.bkg_rej[elem.non_zero_mask] + elem.binomial_error()[elem.non_zero_mask]\n            )\n            self.axis_top.fill_between(\n                elem.sig_eff[elem.non_zero_mask],\n                rej_band_down,\n                rej_band_up,\n                color=elem.colour,\n                alpha=0.25,\n                edgecolor=\"none\",\n                zorder=2,\n            )\n    return plt_handles\n</code></pre>"},{"location":"api/roc/#puma.roc.RocPlot.set_ratio_class","title":"<code>set_ratio_class</code>","text":"<p>Associate the rejection class to a ratio panel adn set the legend label.</p> <p>Parameters:</p> Name Type Description Default <code>ratio_panel</code> <code>int</code> <p>Ratio panel either 1 or 2</p> required <code>rej_class</code> <code>str | ftag.Label</code> <p>Rejection class associated to that panel. Either a Label instance or a string</p> required <code>rej_class_label</code> <code>str | None</code> <p>If rej_class is not a Label, this label must be given</p> <code>None</code> <p>Raises:</p> Type Description <code>TypeError</code> <p>If the rej_class is a string and rej_class_label is not defined</p> Source code in <code>puma/roc.py</code> <pre><code>def set_ratio_class(\n    self,\n    ratio_panel: int,\n    rej_class: str | Label,\n    rej_class_label: str | None = None,\n) -&gt; None:\n    \"\"\"Associate the rejection class to a ratio panel adn set the legend label.\n\n    Parameters\n    ----------\n    ratio_panel : int\n        Ratio panel either 1 or 2\n    rej_class : str | Label\n        Rejection class associated to that panel. Either a Label instance or a string\n    rej_class_label : str | None, optional\n        If rej_class is not a Label, this label must be given\n\n    Raises\n    ------\n    TypeError\n        If the rej_class is a string and rej_class_label is not defined\n    \"\"\"\n    if isinstance(rej_class, Label):\n        rej_class_label_str = rej_class.label\n        rej_class_name = rej_class.name\n\n    else:\n        if not isinstance(rej_class_label, str):\n            raise TypeError(\n                \"'rej_class_label' must be a string when 'rej_class' is not a Label!\"\n            )\n        rej_class_label_str = rej_class_label\n        rej_class_name = rej_class\n\n    self.rej_axes[rej_class_name] = self.ratio_axes[ratio_panel - 1]\n    label = rej_class_label_str.replace(\"jets\", \"jet\")\n    self.set_ratio_label(ratio_panel, f\"{label} ratio\")\n    self.leg_rej_labels[rej_class_name] = rej_class_label_str\n</code></pre>"},{"location":"api/roc/#puma.roc.RocPlot.set_roc_reference","title":"<code>set_roc_reference</code>","text":"<p>Setting the reference roc curves used in the ratios.</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>str</code> <p>Unique identifier of roc object</p> required <code>rej_class</code> <code>str | ftag.Label</code> <p>Rejection class encoded in roc curve</p> required <code>ratio_group</code> <code>str</code> <p>Ratio group this roc is reference for</p> required <p>Raises:</p> Type Description <code>ValueError</code> <p>If more rejection classes are set than actual ratio panels available.</p> Source code in <code>puma/roc.py</code> <pre><code>def set_roc_reference(\n    self,\n    key: str,\n    rej_class: str | Label,\n    ratio_group: str,\n):\n    \"\"\"Setting the reference roc curves used in the ratios.\n\n    Parameters\n    ----------\n    key : str\n        Unique identifier of roc object\n    rej_class : str | Label\n        Rejection class encoded in roc curve\n    ratio_group : str\n        Ratio group this roc is reference for\n\n    Raises\n    ------\n    ValueError\n        If more rejection classes are set than actual ratio panels available.\n    \"\"\"\n    # Ensure that rej_class is not an instance of label\n    rej_class_str = rej_class.name if isinstance(rej_class, Label) else rej_class\n\n    if rej_class_str not in self.reference_roc:\n        if len(self.reference_roc) &gt; self.n_ratio_panels:\n            raise ValueError(\n                \"You cannot set more rejection classes than available ratio panels.\"\n            )\n        self.reference_roc[rej_class_str] = {ratio_group: key}\n    else:\n        if self.reference_roc[rej_class_str].get(ratio_group):\n            logger.warning(\n                \"You specified a second roc curve %s as reference for ratio. \"\n                \"Using it as new reference instead of %s.\",\n                key,\n                self.reference_roc[rej_class_str][ratio_group],\n            )\n        self.reference_roc[rej_class_str][ratio_group] = key\n</code></pre>"},{"location":"api/var_vs_var/","title":"Variable vs Variable","text":""},{"location":"api/var_vs_var/#puma.var_vs_var.VarVsVar","title":"<code>puma.var_vs_var.VarVsVar</code>","text":"<p>               Bases: <code>puma.plot_base.PlotLineObject</code></p> <p>VarVsVar class storing info about curve and allows to calculate ratio w.r.t other efficiency plots.</p> <p>Parameters:</p> Name Type Description Default <code>x_var</code> <code>numpy.ndarray</code> <p>Values for x-axis variable, e.g. bin midpoints for binned data</p> required <code>y_var_mean</code> <code>numpy.ndarray</code> <p>Mean value for y-axis variable</p> required <code>y_var_std</code> <code>numpy.ndarray</code> <p>Std value for y-axis variable</p> required <code>x_var_widths</code> <code>numpy.ndarray</code> <p>Widths for x-axis variable, e.g. bin widths for binned data</p> <code>None</code> <code>key</code> <code>str | None</code> <p>Identifier for the curve e.g. tagger, by default None</p> <code>None</code> <code>fill</code> <code>bool</code> <p>Defines do we need to fill box around point, by default True</p> <code>True</code> <code>plot_y_std</code> <code>bool</code> <p>Defines do we need to plot y_var_std, by default True</p> <code>True</code> <code>ratio_group</code> <code>str | None</code> <p>Name of the ratio group this VarVsVar is compared with. The ratio group allows you to compare different groups of VarVsVar within one plot. By default None</p> <code>None</code> <code>**kwargs</code> <code>typing.Any</code> <p>Keyword arguments passed to <code>PlotLineObject</code></p> <code>{}</code> <p>Raises:</p> Type Description <code>ValueError</code> <p>If provided options are not compatible with each other</p> Source code in <code>puma/var_vs_var.py</code> <pre><code>def __init__(\n    self,\n    x_var: np.ndarray,\n    y_var_mean: np.ndarray,\n    y_var_std: np.ndarray,\n    x_var_widths: np.ndarray = None,\n    key: str | None = None,\n    fill: bool = True,\n    plot_y_std: bool = True,\n    ratio_group: str | None = None,\n    **kwargs: Any,\n) -&gt; None:\n    super().__init__(**kwargs)\n    if len(x_var) != len(y_var_mean):\n        raise ValueError(\n            f\"Length of `x_var` ({len(x_var)}) and `y_var_mean` \"\n            f\"({len(y_var_mean)}) have to be identical.\"\n        )\n    if len(x_var) != len(y_var_std):\n        raise ValueError(\n            f\"Length of `x_var` ({len(x_var)}) and `y_var_std` \"\n            f\"({len(y_var_std)}) have to be identical.\"\n        )\n    if x_var_widths is not None and len(x_var) != len(x_var_widths):\n        raise ValueError(\n            f\"Length of `x_var` ({len(x_var)}) and `x_var_widths` \"\n            f\"({len(x_var_widths)}) have to be identical.\"\n        )\n    self.x_var = np.array(x_var)\n    self.x_var_widths = None if x_var_widths is None else np.array(x_var_widths)\n    self.y_var_mean = np.array(y_var_mean)\n    self.y_var_std = np.array(y_var_std)\n\n    self.key = key\n    self.fill = fill\n    self.plot_y_std = plot_y_std\n    self.ratio_group = ratio_group\n\n    # Get the kwargs\n    self.kwargs = kwargs\n</code></pre>"},{"location":"api/var_vs_var/#puma.var_vs_var.VarVsVar.args_to_store","title":"<code>args_to_store</code>  <code>property</code>","text":"<p>Returns the arguments that need to be stored/loaded.</p> <p>Returns:</p> Type Description <code>dict[str, typing.Any]</code> <p>Dict with the arguments</p>"},{"location":"api/var_vs_var/#puma.var_vs_var.VarVsVar.__eq__","title":"<code>__eq__</code>","text":"<p>Handles a == check with the class.</p> <p>Parameters:</p> Name Type Description Default <code>other</code> <code>puma.var_vs_var.VarVsVar</code> <p>Other VarVsVar that this class is tested against</p> required <p>Returns:</p> Type Description <code>bool</code> <p>If this VarVsVar and the other are equal</p> Source code in <code>puma/var_vs_var.py</code> <pre><code>def __eq__(self, other: VarVsVar) -&gt; bool:\n    \"\"\"Handles a == check with the class.\n\n    Parameters\n    ----------\n    other : VarVsVar\n        Other VarVsVar that this class is tested against\n\n    Returns\n    -------\n    bool\n        If this VarVsVar and the other are equal\n    \"\"\"\n    if isinstance(other, self.__class__):\n        return (\n            np.all(self.x_var == other.x_var)\n            and np.all(self.y_var_mean == other.y_var_mean)\n            and np.all(self.y_var_std == other.y_var_std)\n            and self.key == other.key\n        )\n    return False\n</code></pre>"},{"location":"api/var_vs_var/#puma.var_vs_var.VarVsVar.divide","title":"<code>divide</code>","text":"<p>Calculate ratio between two class objects.</p> <p>Parameters:</p> Name Type Description Default <code>other</code> <code>puma.var_vs_var.VarVsVar</code> <p>Second VarVsVar object to calculate ratio with</p> required <code>inverse</code> <code>bool</code> <p>If False the ratio is calculated <code>this / other</code>, if True the inverse is calculated. By default False.</p> <code>False</code> <code>method</code> <code>str</code> <p>Define which method is used for ratio calculation. By default \"divide\". Other possibility is \"root_square_diff\" and \"subtract\".</p> <code>'divide'</code> <p>Returns:</p> Type Description <code>tuple[numpy.ndarray, numpy.ndarray]</code> <p>Ratio and ratio error Ratio error</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If binning is not identical between 2 objects</p> Source code in <code>puma/var_vs_var.py</code> <pre><code>def divide(\n    self,\n    other: VarVsVar,\n    inverse: bool = False,\n    method: str = \"divide\",\n) -&gt; tuple[np.ndarray, np.ndarray]:\n    \"\"\"Calculate ratio between two class objects.\n\n    Parameters\n    ----------\n    other : VarVsVar\n        Second VarVsVar object to calculate ratio with\n    inverse : bool, optional\n        If False the ratio is calculated `this / other`,\n        if True the inverse is calculated. By default False.\n    method : str, optional\n        Define which method is used for ratio calculation. By default \"divide\".\n        Other possibility is \"root_square_diff\" and \"subtract\".\n\n    Returns\n    -------\n    tuple[np.ndarray, np.ndarray]\n        Ratio and ratio error\n        Ratio error\n\n    Raises\n    ------\n    ValueError\n        If binning is not identical between 2 objects\n    \"\"\"\n    # Check that both x variables match\n    if not np.array_equal(self.x_var, other.x_var):\n        raise ValueError(\"The x variables of the two given objects do not match.\")\n\n    # Get the nominator/denominator + uncertainty\n    nom, nom_err = self.y_var_mean, self.y_var_std\n    denom, denom_err = other.y_var_mean, other.y_var_std\n\n    # Calculate the ratio/difference between the the actual and other VarVsVar object\n    ratio, ratio_err = hist_ratio(\n        numerator=denom if inverse else nom,\n        denominator=nom if inverse else denom,\n        numerator_unc=denom_err if inverse else nom_err,\n        step=False,\n        method=method,\n    )\n    return (ratio, ratio_err)\n</code></pre>"},{"location":"api/var_vs_var/#puma.var_vs_var.VarVsVarPlot","title":"<code>puma.var_vs_var.VarVsVarPlot</code>","text":"<p>               Bases: <code>puma.plot_base.PlotBase</code></p> <p>VarVsVar plot class.</p> <p>Parameters:</p> Name Type Description Default <code>grid</code> <code>bool</code> <p>Set the grid for the plots.</p> <code>False</code> <code>ratio_method</code> <code>str</code> <p>Method for ratio calculations. Accepted values: \"divide\", \"root_square_diff\", \"subtract\". By default \"divide\"</p> <code>'divide'</code> <code>**kwargs</code> <code>typing.Any</code> <p>Keyword arguments from <code>puma.PlotObject</code></p> <code>{}</code> <p>Raises:</p> Type Description <code>ValueError</code> <p>If incompatible mode given or more than 1 ratio panel requested</p> Source code in <code>puma/var_vs_var.py</code> <pre><code>def __init__(self, grid: bool = False, ratio_method: str = \"divide\", **kwargs: Any) -&gt; None:\n    super().__init__(grid=grid, **kwargs)\n\n    self.plot_objects: dict[str, VarVsVar] = {}\n    self.add_order: list[str] = []\n    self.reference_object: list[str] | None = None\n    self.x_var_min = np.inf\n    self.x_var_max = -np.inf\n    self.inverse_cut: bool = False\n    if self.n_ratio_panels &gt; 1:\n        raise ValueError(\"Not more than one ratio panel supported.\")\n    self.ratio_method = ratio_method\n    self.initialise_figure()\n</code></pre>"},{"location":"api/var_vs_var/#puma.var_vs_var.VarVsVarPlot.add","title":"<code>add</code>","text":"<p>Adding VarVsVar object to figure.</p> <p>Parameters:</p> Name Type Description Default <code>curve</code> <code>puma.var_vs_var.VarVsVar</code> <p>VarVsVar curve</p> required <code>key</code> <code>str | None</code> <p>Unique identifier for VarVsVar curve, by default None</p> <code>None</code> <code>reference</code> <code>bool</code> <p>If VarVsVar is used as reference for ratio calculation, by default False</p> <code>False</code> <p>Raises:</p> Type Description <code>KeyError</code> <p>If unique identifier key is used twice</p> Source code in <code>puma/var_vs_var.py</code> <pre><code>def add(self, curve: VarVsVar, key: str | None = None, reference: bool = False) -&gt; None:\n    \"\"\"Adding VarVsVar object to figure.\n\n    Parameters\n    ----------\n    curve : VarVsVar\n        VarVsVar curve\n    key : str | None, optional\n        Unique identifier for VarVsVar curve, by default None\n    reference : bool, optional\n        If VarVsVar is used as reference for ratio calculation, by default False\n\n    Raises\n    ------\n    KeyError\n        If unique identifier key is used twice\n    \"\"\"\n    key = cast(str, key if key is not None else f\"{len(self.plot_objects) + 1}\")\n\n    if key in self.plot_objects:\n        raise KeyError(f\"Duplicated key {key} already used for unique identifier.\")\n\n    self.plot_objects[key] = curve\n    self.add_order.append(key)\n    # set linestyle\n    if curve.linestyle is None:\n        curve.linestyle = \"-\"\n    # set colours\n    if curve.colour is None:\n        curve.colour = get_good_colours()[len(self.plot_objects) - 1]\n    # set alpha\n    if curve.alpha is None:\n        curve.alpha = 0.8\n    # set linewidth\n    if curve.linewidth is None:\n        curve.linewidth = 1.6\n\n    if curve.is_marker is True:\n        if curve.marker is None:\n            curve.marker = get_good_markers()[len(self.plot_objects)]\n        # Set markersize\n        if curve.markersize is None:\n            curve.markersize = 8\n        if curve.markeredgewidth is None:\n            curve.markeredgewidth = 2\n\n    # set min and max edges\n    if curve.x_var_widths is not None:\n        left_edge = curve.x_var - curve.x_var_widths / 2\n        right_edge = curve.x_var + curve.x_var_widths / 2\n    else:\n        left_edge = curve.x_var\n        right_edge = curve.x_var\n    self.x_var_min = min(self.x_var_min, np.sort(left_edge)[0])\n    self.x_var_max = max(self.x_var_max, np.sort(right_edge)[-1])\n\n    if reference:\n        logger.debug(\"Setting roc %s as reference.\", key)\n        self.set_reference(key)\n</code></pre>"},{"location":"api/var_vs_var/#puma.var_vs_var.VarVsVarPlot.draw","title":"<code>draw</code>","text":"<p>Draw figure.</p> <p>Parameters:</p> Name Type Description Default <code>labelpad</code> <code>int | None</code> <p>Spacing in points from the axes bounding box including ticks and tick labels, by default \"ratio\"</p> <code>None</code> Source code in <code>puma/var_vs_var.py</code> <pre><code>def draw(\n    self,\n    labelpad: int | None = None,\n):\n    \"\"\"Draw figure.\n\n    Parameters\n    ----------\n    labelpad : int | None, optional\n        Spacing in points from the axes bounding box including\n        ticks and tick labels, by default \"ratio\"\n    \"\"\"\n    self.set_xlim(\n        self.x_var_min if self.xmin is None else self.xmin,\n        self.x_var_max if self.xmax is None else self.xmax,\n    )\n    plt_handles = self.plot()\n    if self.n_ratio_panels == 1:\n        self.plot_ratios()\n    self.set_title()\n    self.set_log()\n    self.set_y_lim()\n    self.set_xlabel()\n    self.set_tick_params()\n    self.set_ylabel(self.axis_top)\n\n    if self.n_ratio_panels &gt; 0:\n        assert isinstance(self.ylabel_ratio, list)\n        self.set_ylabel(\n            self.ratio_axes[0],\n            self.ylabel_ratio[0],\n            align=\"center\",\n            labelpad=labelpad,\n        )\n    self.make_legend(plt_handles, ax_mpl=self.axis_top)\n    self.plotting_done = True\n    if self.apply_atlas_style is True:\n        self.atlasify()\n</code></pre>"},{"location":"api/var_vs_var/#puma.var_vs_var.VarVsVarPlot.draw_hline","title":"<code>draw_hline</code>","text":"<p>Draw hline in top plot panel.</p> <p>Parameters:</p> Name Type Description Default <code>y_val</code> <code>float</code> <p>y value of the horizontal line</p> required Source code in <code>puma/var_vs_var.py</code> <pre><code>def draw_hline(self, y_val: float):\n    \"\"\"Draw hline in top plot panel.\n\n    Parameters\n    ----------\n    y_val : float\n        y value of the horizontal line\n    \"\"\"\n    self.axis_top.hlines(\n        y=y_val,\n        xmin=self.x_var_min,\n        xmax=self.x_var_max,\n        colors=\"black\",\n        linestyle=\"dotted\",\n        alpha=0.5,\n    )\n</code></pre>"},{"location":"api/var_vs_var/#puma.var_vs_var.VarVsVarPlot.get_reference_name","title":"<code>get_reference_name</code>","text":"<p>Get reference VarVsVar object from list of references.</p> <p>Parameters:</p> Name Type Description Default <code>var_object</code> <code>puma.var_vs_var.VarVsVar</code> <p>VarVsVar we want to calculate the ratio for</p> required <p>Returns:</p> Name Type Description <code>reference_name</code> <code>puma.var_vs_var.VarVsVar | None</code> <p>Corresponding reference VarVsVar</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If no reference VarVsVar was found or multiple matches.</p> Source code in <code>puma/var_vs_var.py</code> <pre><code>def get_reference_name(self, var_object: VarVsVar) -&gt; VarVsVar | None:\n    \"\"\"Get reference VarVsVar object from list of references.\n\n    Parameters\n    ----------\n    var_object : VarVsVar\n        VarVsVar we want to calculate the ratio for\n\n    Returns\n    -------\n    reference_name : VarVsVar | None\n        Corresponding reference VarVsVar\n\n    Raises\n    ------\n    ValueError\n        If no reference VarVsVar was found or multiple matches.\n    \"\"\"\n    matches = 0\n    reference_name = None\n\n    for key in self.reference_object:\n        reference_candidate = self.plot_objects[key]\n        if var_object.ratio_group is not None:\n            if var_object.ratio_group == reference_candidate.ratio_group:\n                matches += 1\n                reference_name = reference_candidate\n        else:\n            matches += 1\n            reference_name = reference_candidate\n\n    if matches != 1:\n        raise ValueError(\n            f\"Found {matches} matching reference candidates, but only one match is allowed.\"\n        )\n\n    logger.debug(\"Reference var_object for '%s' is '%s'\", var_object.key, reference_name.key)\n\n    return reference_name\n</code></pre>"},{"location":"api/var_vs_var/#puma.var_vs_var.VarVsVarPlot.plot","title":"<code>plot</code>","text":"<p>Plotting curves.</p> <p>Parameters:</p> Name Type Description Default <code>**kwargs</code> <code>typing.Any</code> <p>Keyword arguments passed to plt.axis.errorbar</p> <code>{}</code> <p>Returns:</p> Type Description <code>matplotlib.lines.Line2D</code> <p>matplotlib Line2D object</p> Source code in <code>puma/var_vs_var.py</code> <pre><code>def plot(self, **kwargs: Any) -&gt; mpl.lines.Line2D:\n    \"\"\"Plotting curves.\n\n    Parameters\n    ----------\n    **kwargs: Any\n        Keyword arguments passed to plt.axis.errorbar\n\n    Returns\n    -------\n    mpl.lines.Line2D\n        matplotlib Line2D object\n    \"\"\"\n    logger.debug(\"Plotting curves\")\n    plt_handles = []\n    for key in self.add_order:\n        elem = self.plot_objects[key]\n        error_bar = self.axis_top.errorbar(\n            elem.x_var,\n            elem.y_var_mean,\n            xerr=elem.x_var_widths / 2 if elem.x_var_widths is not None else None,\n            yerr=(elem.y_var_std if elem.plot_y_std else np.zeros_like(elem.x_var)),\n            color=elem.colour,\n            fmt=\"none\",\n            label=elem.label,\n            alpha=elem.alpha,\n            linewidth=elem.linewidth,\n            ms=elem.markersize,\n            **kwargs,\n        )\n        # # set linestyle for errorbar\n        error_bar[-1][0].set_linestyle(elem.linestyle)\n        # Draw markers\n        if elem.is_marker is True:\n            self.axis_top.scatter(\n                x=elem.x_var,\n                y=elem.y_var_mean,\n                marker=elem.marker,\n                s=elem.markersize**2,\n                color=elem.colour,\n            )\n        if elem.x_var_widths is not None and elem.fill:\n            for x_pos, y_pos, width, height in zip(\n                elem.x_var,\n                elem.y_var_mean,\n                elem.x_var_widths,\n                2 * elem.y_var_std,\n                strict=False,\n            ):\n                self.axis_top.add_patch(\n                    Rectangle(\n                        xy=(\n                            x_pos - width / 2,\n                            y_pos - height / 2,\n                        ),\n                        width=width,\n                        height=height,\n                        linewidth=0,\n                        color=elem.colour,\n                        alpha=0.3,\n                        zorder=1,\n                    )\n                )\n        plt_handles.append(\n            mpl.lines.Line2D(\n                [],\n                [],\n                color=elem.colour,\n                label=elem.label,\n                linestyle=elem.linestyle,\n                marker=elem.marker,\n                markersize=elem.markersize,\n            )\n        )\n    return plt_handles\n</code></pre>"},{"location":"api/var_vs_var/#puma.var_vs_var.VarVsVarPlot.plot_ratios","title":"<code>plot_ratios</code>","text":"<p>Plotting ratio curves.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If no reference curve is defined</p> Source code in <code>puma/var_vs_var.py</code> <pre><code>def plot_ratios(self):\n    \"\"\"Plotting ratio curves.\n\n    Raises\n    ------\n    ValueError\n        If no reference curve is defined\n    \"\"\"\n    if self.reference_object is None:\n        raise ValueError(\"Please specify a reference curve.\")\n    for key in self.add_order:\n        elem = self.plot_objects[key]\n        ratio, ratio_err = elem.divide(\n            other=self.get_reference_name(elem),\n            method=self.ratio_method,\n        )\n        error_bar = self.ratio_axes[0].errorbar(\n            elem.x_var,\n            ratio,\n            xerr=elem.x_var_widths / 2 if elem.x_var_widths is not None else None,\n            yerr=ratio_err if elem.plot_y_std else np.zeros_like(elem.x_var),\n            color=elem.colour,\n            fmt=\"none\",\n            alpha=elem.alpha,\n            linewidth=elem.linewidth,\n            ms=elem.markersize,\n        )\n        # set linestyle for errorbar\n        error_bar[-1][0].set_linestyle(elem.linestyle)\n        # draw markers\n        if elem.is_marker is True:\n            self.ratio_axes[0].scatter(\n                x=elem.x_var,\n                y=ratio,\n                marker=elem.marker,\n                color=elem.colour,\n                s=elem.markersize**2,\n            )\n        if elem.x_var_widths is not None and elem.fill:\n            for x_pos, y_pos, width, height in zip(\n                elem.x_var, ratio, elem.x_var_widths, 2 * ratio_err, strict=False\n            ):\n                self.ratio_axes[0].add_patch(\n                    Rectangle(\n                        xy=(\n                            x_pos - width / 2,\n                            y_pos - height / 2,\n                        ),\n                        width=width,\n                        height=height,\n                        linewidth=0,\n                        color=elem.colour,\n                        alpha=0.3,\n                        zorder=1,\n                    )\n                )\n</code></pre>"},{"location":"api/var_vs_var/#puma.var_vs_var.VarVsVarPlot.set_reference","title":"<code>set_reference</code>","text":"<p>Setting the reference VarVsVar curves used in the ratios.</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>str</code> <p>Unique identifier of roc object</p> required Source code in <code>puma/var_vs_var.py</code> <pre><code>def set_reference(self, key: str):\n    \"\"\"Setting the reference VarVsVar curves used in the ratios.\n\n    Parameters\n    ----------\n    key : str\n        Unique identifier of roc object\n    \"\"\"\n    if self.reference_object is None:\n        self.reference_object = [key]\n    else:\n        self.reference_object.append(key)\n    logger.debug(\"Adding '%s' to reference VarVsVar(s)\", key)\n</code></pre>"},{"location":"api/var_vs_var/#puma.var_vs_eff.VarVsEff","title":"<code>puma.var_vs_eff.VarVsEff</code>","text":"<p>               Bases: <code>puma.var_vs_var.VarVsVar</code></p> <p>Class for efficiency vs. variable plot.</p> <p>Parameters:</p> Name Type Description Default <code>x_var_sig</code> <code>numpy.ndarray</code> <p>Values for x-axis variable for signal</p> required <code>disc_sig</code> <code>numpy.ndarray</code> <p>Discriminant values for signal</p> required <code>weights_sig</code> <code>numpy.ndarray | None</code> <p>Weights for the signal. If not provided, equal weights will be used. By default None</p> <code>None</code> <code>x_var_bkg</code> <code>numpy.ndarray</code> <p>Values for x-axis variable for background, by default None</p> <code>None</code> <code>disc_bkg</code> <code>numpy.ndarray</code> <p>Discriminant values for background, by default None</p> <code>None</code> <code>weights_bkg</code> <code>numpy.ndarray | None</code> <p>Weights for the background. If not provided, equal weights will be used. By default None</p> <code>None</code> <code>bins</code> <code>int | list | numpy.ndarray</code> <p>If bins is an int, it defines the number of equal-width bins in the given range (10, by default). If bins is a sequence, it defines a monotonically increasing array of bin edges, including the rightmost edge, allowing for non-uniform bin widths, by default 10</p> <code>10</code> <code>working_point</code> <code>float | list | None</code> <p>Working point, by default None</p> <code>None</code> <code>fixed_bkg_rej</code> <code>float | None</code> <p>Instead of fixing the signal efficiency (by using working_point), fix the background rejection to a certain value. By default None</p> <code>None</code> <code>disc_cut</code> <code>int | list | numpy.ndarray | None</code> <p>Cut value for discriminant, if it is a sequence it has to have the same length as number of bins, by default None</p> <code>None</code> <code>flat_per_bin</code> <code>bool</code> <p>If True and no <code>disc_cut</code> is given the signal efficiency is held constant in each bin, by default False</p> <code>False</code> <code>key</code> <code>str | None</code> <p>Identifier for the curve e.g. tagger, by default None</p> <code>None</code> <code>**kwargs</code> <code>typing.Any</code> <p>Keyword arguments passed to <code>PlotLineObject</code></p> <code>{}</code> <p>Raises:</p> Type Description <code>ValueError</code> <p>x_var_sig and disc_sig have different lengths x_var_bkg and disc_bkg have different lengths Neither working_point nor flat_per_bin was set Both disc_cut and flat_per_bin are set working_point is not set but flat_per_bin is Using PCFT bins and flat_per_bin together Using disc_cut and working_point together disc_cut (if an array) has a different length than the number of bins given</p> <code>TypeError</code> <p>If \"working_point\" is neither a list nor a float</p> Source code in <code>puma/var_vs_eff.py</code> <pre><code>def __init__(\n    self,\n    x_var_sig: np.ndarray,\n    disc_sig: np.ndarray,\n    weights_sig: np.ndarray | None = None,\n    x_var_bkg: np.ndarray = None,\n    disc_bkg: np.ndarray = None,\n    weights_bkg: np.ndarray | None = None,\n    bins: int | list | np.ndarray = 10,\n    working_point: float | list | None = None,\n    fixed_bkg_rej: float | None = None,\n    disc_cut: int | list | np.ndarray | None = None,\n    flat_per_bin: bool = False,\n    key: str | None = None,\n    **kwargs: Any,\n) -&gt; None:\n    if len(x_var_sig) != len(disc_sig):\n        raise ValueError(\n            f\"Length of `x_var_sig` ({len(x_var_sig)}) and `disc_sig` \"\n            f\"({len(disc_sig)}) have to be identical.\"\n        )\n    if x_var_bkg is not None and len(x_var_bkg) != len(disc_bkg):\n        raise ValueError(\n            f\"Length of `x_var_bkg` ({len(x_var_bkg)}) and `disc_bkg` \"\n            f\"({len(disc_bkg)}) have to be identical.\"\n        )\n\n    # Ensure that signal/background variables are arrays\n    self.x_var_sig = np.array(x_var_sig)\n    self.disc_sig = np.array(disc_sig)\n    self.x_var_bkg = None if x_var_bkg is None else np.array(x_var_bkg)\n    self.disc_bkg = None if disc_bkg is None else np.array(disc_bkg)\n\n    # Check the signal weights and use ones if not given\n    if weights_sig is None:\n        self.weights_sig = np.ones_like(self.disc_sig, dtype=float)\n\n    # Else ensure that they have the same size as the discriminants\n    else:\n        self.weights_sig = np.asarray(weights_sig, dtype=float)\n        if self.weights_sig.shape != self.disc_sig.shape:\n            raise ValueError(\n                \"Length of 'weights_sig' \"\n                f\"({self.weights_sig.shape}) must match 'disc_sig' ({self.disc_sig.shape}).\"\n            )\n\n    # If no bkg discs are given, don't use bkg weights\n    if self.disc_bkg is None:\n        self.weights_bkg = None\n\n    # If no weights but discs are given, use ones\n    elif weights_bkg is None:\n        self.weights_bkg = np.ones_like(self.disc_bkg, dtype=float)\n\n    # Else ensure that they have the same size as the discs\n    else:\n        self.weights_bkg = np.asarray(weights_bkg, dtype=float)\n        if self.weights_bkg.shape != self.disc_bkg.shape:\n            raise ValueError(\n                \"Length of 'weights_bkg' \"\n                f\"({self.weights_bkg.shape}) must match 'disc_bkg' ({self.disc_bkg.shape}).\"\n            )\n\n    # Define attributes for the working points\n    self.working_point = working_point\n    self.fixed_bkg_rej = fixed_bkg_rej\n    self.disc_cut = disc_cut\n    self.flat_per_bin = flat_per_bin\n\n    # Binning related variables\n    self.n_bins = None\n    self.bin_edges = None\n    self.x_bin_centres = None\n    self.bin_widths = None\n    self.n_bins = None\n\n    # Binned distributions\n    self.bin_indices_sig = None\n    self.disc_binned_sig = None\n    self.weights_binned_sig = None\n    self.bin_indices_bkg = None\n    self.disc_binned_bkg = None\n    self.weights_binned_bkg = None\n\n    # Kwargs\n    self.kwargs = kwargs\n\n    # Set the bin edges\n    self._set_bin_edges(bins)\n\n    # Check that either disc_cut, working_point, or fixed_bkg_rej are defined\n    not_none = [\n        name\n        for name, val in (\n            (\"disc_cut\", self.disc_cut),\n            (\"working_point\", self.working_point),\n            (\"fixed_bkg_rej\", self.fixed_bkg_rej),\n        )\n        if val is not None\n    ]\n\n    if len(not_none) != 1:\n        raise ValueError(\n            f\"Exactly one of disc_cut, working_point, fixed_bkg_rej must be provided! \"\n            f\"Got {', '.join(not_none) if not_none else 'none'}.\"\n        )\n\n    if self.disc_cut is not None:\n        # Ensure that flat_per_bin cannot be set\n        if self.flat_per_bin:\n            raise ValueError(\n                \"You cannot specify `disc_cut` when `flat_per_bin` is set to True.\"\n            )\n\n        # Ensure that disc_cut has the same length as the number of bins if it's used\n        if isinstance(disc_cut, (list, np.ndarray)) and self.n_bins != len(disc_cut):\n            raise ValueError(\n                \"`disc_cut` has to be a float or has to have the same length as number of bins.\"\n            )\n\n    elif self.working_point is not None:\n        # Ensure that only a one float is given to working_point with flat_per_bin\n        if self.flat_per_bin and not isinstance(working_point, float):\n            raise ValueError(\"working_point must be a float when running with flat_per_bin!\")\n\n        # Ensure that the given working points are an array\n        if isinstance(self.working_point, list):\n            self.working_point = np.asarray(self.working_point)\n\n        # Throw error if the working points are neither a float nor a list\n        elif not isinstance(working_point, float):\n            raise TypeError(\n                \"`working_point` must either be a list or a float! \"\n                f\"You gave {type(self.working_point)}\"\n            )\n\n    elif self.fixed_bkg_rej is not None:\n        # Ensure that fixed_bkg_rej is a float:\n        if not isinstance(fixed_bkg_rej, (int, float)):\n            raise TypeError(\n                \"`fixed_bkg_rej` must be an int or a float!\"\n                f\" You gave {type(self.fixed_bkg_rej)}\"\n            )\n\n    # Apply the binning and get the discriminant value cuts as attributes\n    self._apply_binning()\n    self._get_disc_cuts()\n\n    # Setup some needed attributes and also check them\n    VarVsVar.__init__(\n        self,\n        x_var=self.x_bin_centres,\n        y_var_mean=np.zeros_like(self.x_bin_centres),\n        y_var_std=np.zeros_like(self.x_bin_centres),\n        x_var_widths=2 * self.bin_widths,\n        key=key,\n        fill=True,\n        plot_y_std=False,\n        **kwargs,\n    )\n\n    # Calculate all efficiencies/rejections possible to make them easily available and storable\n    self.results: dict[str, dict] = {\"normal\": {}, \"inverse\": {}}\n\n    # Iterate over inverse and normal setup\n    for iter_key in self.results:\n        self.inverse_cut = iter_key == \"inverse\"\n\n        # Iterate over the different output modes and store them\n        for iter_mode in VarVsEffPlot.mode_options:\n            self.results[iter_key][iter_mode] = {}\n\n            # We can't calculate always everything, so the ones that\n            # make problems will be filtered\n            try:\n                (\n                    self.results[iter_key][iter_mode][\"y_value\"],\n                    self.results[iter_key][iter_mode][\"y_error\"],\n                ) = getattr(self, iter_mode)\n\n            except (TypeError, ValueError):\n                (\n                    self.results[iter_key][iter_mode][\"y_value\"],\n                    self.results[iter_key][iter_mode][\"y_error\"],\n                ) = (None, None)\n\n    # Set inverse_cut back to false\n    self.inverse_cut = False\n</code></pre>"},{"location":"api/var_vs_var/#puma.var_vs_eff.VarVsEff.args_to_store","title":"<code>args_to_store</code>  <code>property</code>","text":"<p>Returns the arguments that need to be stored/loaded.</p> <p>Returns:</p> Type Description <code>dict[str, typing.Any]</code> <p>Dict with the arguments</p>"},{"location":"api/var_vs_var/#puma.var_vs_eff.VarVsEff.bkg_eff","title":"<code>bkg_eff</code>  <code>property</code>","text":"<p>Calculate background efficiency per bin.</p> <p>Returns:</p> Type Description <code>numpy.ndarray</code> <p>Efficiency</p> <code>numpy.ndarray</code> <p>Efficiency_error</p>"},{"location":"api/var_vs_var/#puma.var_vs_eff.VarVsEff.bkg_eff_sig_err","title":"<code>bkg_eff_sig_err</code>  <code>property</code>","text":"<p>Calculate signal efficiency per bin, assuming a flat background per bin. This results in returning the signal efficiency per bin, but the background error per bin.</p>"},{"location":"api/var_vs_var/#puma.var_vs_eff.VarVsEff.bkg_rej","title":"<code>bkg_rej</code>  <code>property</code>","text":"<p>Calculate background rejection per bin.</p> <p>Returns:</p> Type Description <code>numpy.ndarray</code> <p>Rejection</p> <code>numpy.ndarray</code> <p>Rejection_error</p>"},{"location":"api/var_vs_var/#puma.var_vs_eff.VarVsEff.sig_eff","title":"<code>sig_eff</code>  <code>property</code>","text":"<p>Calculate signal efficiency per bin.</p> <p>Returns:</p> Type Description <code>numpy.ndarray</code> <p>Efficiency</p> <code>numpy.ndarray</code> <p>Efficiency_error</p>"},{"location":"api/var_vs_var/#puma.var_vs_eff.VarVsEff.sig_rej","title":"<code>sig_rej</code>  <code>property</code>","text":"<p>Calculate signal rejection per bin.</p> <p>Returns:</p> Type Description <code>numpy.ndarray</code> <p>Rejection</p> <code>numpy.ndarray</code> <p>Rejection_error</p>"},{"location":"api/var_vs_var/#puma.var_vs_eff.VarVsEff.efficiency","title":"<code>efficiency</code>","text":"<p>Calculate efficiency and the associated error.</p> <p>Parameters:</p> Name Type Description Default <code>arr</code> <code>numpy.ndarray</code> <p>Array with discriminants</p> required <code>cut</code> <code>float | numpy.ndarray</code> <p>Cut value. If you want to use PCFT, two values are provided. The lower and the upper cut.</p> required <code>weights</code> <code>numpy.ndarray | None</code> <p>Weights to use for the array. Must be same length as arr! When None is given, equal weights are used. By default None</p> <code>None</code> <p>Returns:</p> Type Description <code>float | numpy.ndarray</code> <p>Efficiency</p> <code>float | numpy.ndarray</code> <p>Efficiency error</p> <p>Raises:</p> Type Description <code>TypeError</code> <p>If the cut parameter type is not supported</p> Source code in <code>puma/var_vs_eff.py</code> <pre><code>def efficiency(\n    self,\n    arr: np.ndarray,\n    cut: float | np.ndarray,\n    weights: np.ndarray | None = None,\n) -&gt; tuple[float, float] | tuple[np.ndarray, np.ndarray]:\n    \"\"\"Calculate efficiency and the associated error.\n\n    Parameters\n    ----------\n    arr : np.ndarray\n        Array with discriminants\n    cut : float | np.ndarray\n        Cut value. If you want to use PCFT, two values are provided.\n        The lower and the upper cut.\n    weights : np.ndarray | None, optional\n        Weights to use for the array. Must be same length as arr!\n        When None is given, equal weights are used. By default None\n\n    Returns\n    -------\n    float | np.ndarray\n        Efficiency\n    float | np.ndarray\n        Efficiency error\n\n    Raises\n    ------\n    TypeError\n        If the cut parameter type is not supported\n    \"\"\"\n    # If no values are given, return 0 for eff and eff_err\n    if len(arr) == 0:\n        return 0.0, 0.0\n\n    # Fall back if no weights are used\n    if weights is None:\n        weights = np.ones_like(arr, dtype=float)\n\n    # If the cut is a single value, this is a non-PCFT WP\n    if isinstance(cut, (int, float, np.integer, np.floating)):\n        # Check for the inverse cut\n        mask = arr &lt; cut if self.inverse_cut else arr &gt; cut\n\n    # If the cut is an array, this is a PCFT-style two-sided cut\n    # Keep values between cut[1] and cut[0]\n    elif isinstance(cut, np.ndarray):\n        mask = (arr &lt; cut[0]) &amp; (arr &gt; cut[1])\n\n    # Else return an error that this type of cut is not supported\n    else:\n        raise TypeError(\n            f\"cut parameter type {type(cut)} is not supported! Must be float or np.ndarray\"\n        )\n\n    # With the given mask, calculate the sum of the weights\n    numerator = float(weights[mask].sum())\n    denominator = float(weights.sum())\n\n    # Check if the denominator is &gt; 0\n    # If not, return 0 as eff and eff_err\n    if denominator &lt;= 0:\n        return 0.0, 0.0\n\n    # Calculate the efficiency and the error\n    eff = save_divide(numerator=numerator, denominator=denominator)\n    eff_error = calculate_efficiency_error(eff, denominator)\n\n    return eff, eff_error\n</code></pre>"},{"location":"api/var_vs_var/#puma.var_vs_eff.VarVsEff.get","title":"<code>get</code>","text":"<p>Wrapper around rejection and efficiency functions.</p> <p>Parameters:</p> Name Type Description Default <code>mode</code> <code>str</code> <p>Can be \"sig_eff\", \"bkg_eff\", \"sig_rej\", \"bkg_rej\", or \"bkg_eff_sig_err\"</p> required <code>inverse_cut</code> <code>bool</code> <p>Inverts the discriminant cut, which will yield the efficiency or rejection of the jets not passing the working point, by default False</p> <code>False</code> <p>Returns:</p> Type Description <code>numpy.ndarray</code> <p>Rejection or efficiency depending on <code>mode</code> value</p> <code>numpy.ndarray</code> <p>Rejection or efficiency error depending on <code>mode</code> value</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If mode not supported</p> Source code in <code>puma/var_vs_eff.py</code> <pre><code>def get(self, mode: str, inverse_cut: bool = False):\n    \"\"\"Wrapper around rejection and efficiency functions.\n\n    Parameters\n    ----------\n    mode : str\n        Can be \"sig_eff\", \"bkg_eff\", \"sig_rej\", \"bkg_rej\", or\n        \"bkg_eff_sig_err\"\n    inverse_cut : bool, optional\n        Inverts the discriminant cut, which will yield the efficiency or rejection\n        of the jets not passing the working point, by default False\n\n    Returns\n    -------\n    np.ndarray\n        Rejection or efficiency depending on `mode` value\n    np.ndarray\n        Rejection or efficiency error depending on `mode` value\n\n    Raises\n    ------\n    ValueError\n        If mode not supported\n    \"\"\"\n    if mode in VarVsEffPlot.mode_options:\n        name = \"normal\" if inverse_cut is False else \"inverse\"\n        return (\n            self.results[name][mode][\"y_value\"],\n            self.results[name][mode][\"y_error\"],\n        )\n    raise ValueError(\n        f\"The selected mode {mode} is not supported. Use one of the following:\"\n        f\" {VarVsEffPlot.mode_options}.\"\n    )\n</code></pre>"},{"location":"api/var_vs_var/#puma.var_vs_eff.VarVsEff.rejection","title":"<code>rejection</code>","text":"<p>Calculate rejection and the associated error.</p> <p>Parameters:</p> Name Type Description Default <code>arr</code> <code>numpy.ndarray</code> <p>Array with discriminants</p> required <code>cut</code> <code>float | numpy.ndarray</code> <p>Cut value used for the given working point. Ndarray when PCFT-style cuts are used</p> required <code>weights</code> <code>numpy.ndarray | None</code> <p>Weights to use for the array. Must be same length as arr! When None is given, equal weights are used. By default None</p> <code>None</code> <p>Returns:</p> Type Description <code>float | numpy.ndarray</code> <p>Rejection</p> <code>float | numpy.ndarray</code> <p>Rejection error</p> <p>Raises:</p> Type Description <code>TypeError</code> <p>If the cut parameter type is not supported</p> Source code in <code>puma/var_vs_eff.py</code> <pre><code>def rejection(\n    self,\n    arr: np.ndarray,\n    cut: float | np.ndarray,\n    weights: np.ndarray | None = None,\n) -&gt; tuple[float, float] | tuple[np.ndarray, np.ndarray]:\n    \"\"\"Calculate rejection and the associated error.\n\n    Parameters\n    ----------\n    arr : np.ndarray\n        Array with discriminants\n    cut : float | np.ndarray\n        Cut value used for the given working point. Ndarray\n        when PCFT-style cuts are used\n    weights : np.ndarray | None, optional\n        Weights to use for the array. Must be same length as arr!\n        When None is given, equal weights are used. By default None\n\n    Returns\n    -------\n    float | np.ndarray\n        Rejection\n    float | np.ndarray\n        Rejection error\n\n    Raises\n    ------\n    TypeError\n        If the cut parameter type is not supported\n    \"\"\"\n    # If no values are given, return 0 for eff and eff_err\n    if len(arr) == 0:\n        return 0.0, 0.0\n\n    # Fall back if no weights are used\n    if weights is None:\n        weights = np.ones_like(arr, dtype=float)\n\n    # Get the denominator from the total sum of weights\n    denominator = float(weights.sum())\n\n    # Return NaN if total weights is &lt;= 0\n    if denominator &lt;= 0:\n        logger.warning(\"Total weight in bin is &lt;= 0. Setting rejection to NaN.\")\n        return np.nan, np.nan\n\n    # If the cut is a single value, this is a non-PCFT WP\n    if isinstance(cut, (int, float, np.integer, np.floating)):\n        # Check for the inverse cut\n        mask = arr &lt; cut if self.inverse_cut else arr &gt; cut\n\n    # If the cut is an array, this is a PCFT-style two-sided cut\n    # Keep values between cut[1] and cut[0]\n    elif isinstance(cut, np.ndarray):\n        mask = (arr &lt; cut[0]) &amp; (arr &gt; cut[1])\n\n    # Else return an error that this type of cut is not supported\n    else:\n        raise TypeError(\n            f\"cut parameter type {type(cut)} is not supported! Must be float or np.ndarray\"\n        )\n\n    # Get the total weight for passing jets\n    numerator = float(weights[mask].sum())\n\n    # Calculate the rejection by using the inverse of the efficiency (1 / eff)\n    # To do so with less calculation, flip numerator and denominator\n    rej = save_divide(numerator=denominator, denominator=numerator, default=np.inf)\n\n    # If the rejection is infinite, print a warning and return NaN\n    if rej == np.inf:\n        logger.warning(\"Your rejection is infinity -&gt; setting it to np.nan.\")\n        return np.nan, np.nan\n\n    # Calculate the error\n    rej_error = calculate_rejection_error(rej, denominator)\n    return rej, rej_error\n</code></pre>"},{"location":"api/var_vs_var/#puma.var_vs_eff.VarVsEffPlot","title":"<code>puma.var_vs_eff.VarVsEffPlot</code>","text":"<p>               Bases: <code>puma.var_vs_var.VarVsVarPlot</code></p> <p>VarVsEff plot class.</p> <p>Parameters:</p> Name Type Description Default <code>mode</code> <code>str</code> <p>Defines which quantity is plotted, the following options ar available:     sig_eff - Plots signal efficiency vs. variable, with statistical error         on N signal per bin     bkg_eff - Plots background efficiency vs. variable, with statistical         error on N background per bin     sig_rej - Plots signal rejection vs. variable, with statistical error         on N signal per bin     bkg_rej - Plots background rejection vs. variable, with statistical         error on N background per bin     bkg_eff_sig_err - Plots background efficiency vs. variable, with         statistical error on N signal per bin.</p> required <code>grid</code> <code>bool</code> <p>Set the grid for the plots.</p> <code>False</code> <code>**kwargs</code> <code>typing.Any</code> <p>Keyword arguments from <code>puma.PlotObject</code></p> <code>{}</code> <p>Attributes:</p> Name Type Description <code>mode_options</code> <code>typing.ClassVar[list[str]]</code> <p>List of possible modes.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If incompatible mode given or more than 1 ratio panel requested</p> Source code in <code>puma/var_vs_eff.py</code> <pre><code>def __init__(self, mode: str, grid: bool = False, **kwargs: Any) -&gt; None:\n    super().__init__(grid=grid, **kwargs)\n    if mode not in self.mode_options:\n        raise ValueError(\n            f\"The selected mode {mode} is not supported. Use one of the following: \"\n            f\"{self.mode_options}.\"\n        )\n    self.mode = mode\n</code></pre>"},{"location":"api/var_vs_var/#puma.var_vs_eff.VarVsEffPlot.apply_modified_atlas_second_tag","title":"<code>apply_modified_atlas_second_tag</code>","text":"<p>Modifies the atlas_second_tag to include info on the type of p-eff plot.</p> <p>Parameters:</p> Name Type Description Default <code>signal</code> <code>ftag.labels.Label | None</code> <p>Signal flavour that is used. By default None</p> <code>None</code> <code>background</code> <code>ftag.labels.Label | None</code> <p>Background flavour that is used. By default None</p> <code>None</code> <code>working_point</code> <code>float | list | None</code> <p>Working point that was used. When PCFT was used, this is a list of length 2. If disc_cut/fixed_bkg_rej is used, this needs to be None, by default None</p> <code>None</code> <code>fixed_bkg_rej</code> <code>float | None</code> <p>The background rejection to which it was fixed. Must be None when working_point or disc_cut is used. By default None</p> <code>None</code> <code>disc_cut</code> <code>float | None</code> <p>Discriminant cut that was used. If working_point/fixed_bkg_rej is used, this must be None. By default None</p> <code>None</code> <code>flat_per_bin</code> <code>bool</code> <p>If flat_per_bin was used, by default False</p> <code>False</code> Source code in <code>puma/var_vs_eff.py</code> <pre><code>def apply_modified_atlas_second_tag(\n    self,\n    signal: Label | None = None,\n    background: Label | None = None,\n    working_point: float | list | None = None,\n    fixed_bkg_rej: float | None = None,\n    disc_cut: float | None = None,\n    flat_per_bin: bool = False,\n):\n    \"\"\"Modifies the atlas_second_tag to include info on the type of p-eff plot.\n\n    Parameters\n    ----------\n    signal : Label | None, optional\n        Signal flavour that is used. By default None\n    background : Label | None, optional\n        Background flavour that is used. By default None\n    working_point : float | list | None, optional\n        Working point that was used. When PCFT was used, this is a list of length 2.\n        If disc_cut/fixed_bkg_rej is used, this needs to be None, by default None\n    fixed_bkg_rej : float | None, optional\n        The background rejection to which it was fixed. Must be None when working_point\n        or disc_cut is used. By default None\n    disc_cut : float | None, optional\n        Discriminant cut that was used. If working_point/fixed_bkg_rej is used,\n        this must be None. By default None\n    flat_per_bin : bool, optional\n        If flat_per_bin was used, by default False\n    \"\"\"\n    if working_point:\n        if isinstance(working_point, list):\n            mid_str = (\n                f\"{int(round(working_point[0] * 100, 0))}% - \"\n                f\"{int(round(working_point[1] * 100, 0))}% \" + signal.eff_str\n            )\n\n        else:\n            mid_str = f\"{int(round(working_point * 100, 0))}% \" + signal.eff_str\n    elif disc_cut:\n        mid_str = rf\"$D_{{{signal.name.rstrip('jets')}}}$ &gt; {disc_cut}\"\n    elif fixed_bkg_rej:\n        mid_str = f\"{int(round(fixed_bkg_rej, 0))} \" + background.rej_str\n    tag = f\"Flat {mid_str} per bin\" if flat_per_bin else f\"{mid_str}\"\n    if self.atlas_second_tag:\n        self.atlas_second_tag = f\"{self.atlas_second_tag}\\n{tag}\"\n    else:\n        self.atlas_second_tag = tag\n</code></pre>"},{"location":"api/var_vs_var/#puma.var_vs_eff.VarVsEffPlot.plot","title":"<code>plot</code>","text":"<p>Plotting curves.</p> <p>Parameters:</p> Name Type Description Default <code>**kwargs</code> <code>typing.Any</code> <p>Keyword arguments passed to plt.axis.errorbar</p> <code>{}</code> <p>Returns:</p> Type Description <code>matplotlib.lines.Line2D</code> <p>matplotlib Line2D object</p> Source code in <code>puma/var_vs_eff.py</code> <pre><code>def plot(self, **kwargs: Any) -&gt; mpl.lines.Line2D:\n    \"\"\"Plotting curves.\n\n    Parameters\n    ----------\n    **kwargs: Any\n        Keyword arguments passed to plt.axis.errorbar\n\n    Returns\n    -------\n    mpl.lines.Line2D\n        matplotlib Line2D object\n    \"\"\"\n    logger.debug(f\"Plotting curves with mode {self.mode}\")\n    self._setup_curves()\n    return super().plot(**kwargs)\n</code></pre>"},{"location":"api/var_vs_var/#puma.var_vs_vtx.VarVsVtx","title":"<code>puma.var_vs_vtx.VarVsVtx</code>","text":"<p>               Bases: <code>puma.var_vs_var.VarVsVar</code></p> <p>VarVsVtx class storing info about vertexing performance.</p> <p>Parameters:</p> Name Type Description Default <code>x_var</code> <code>numpy.ndarray</code> <p>Values for x-axis variable for signal</p> required <code>n_match</code> <code>numpy.ndarray</code> <p>Values for number of correctly identified objects (where truth and reco match)</p> required <code>n_true</code> <code>numpy.ndarray</code> <p>Values for true number of objects</p> required <code>n_reco</code> <code>numpy.ndarray</code> <p>Values for reconstructed number of objects</p> required <code>bins</code> <code>int | collections.abc.Sequence</code> <p>If bins is an int, it defines the number of equal-width bins in the given range (10, by default). If bins is a sequence, it defines a monotonically increasing array of bin edges, including the rightmost edge, allowing for non-uniform bin widths, by default 10</p> <code>10</code> <code>key</code> <code>str | None</code> <p>Identifier for the curve e.g. tagger, by default None</p> <code>None</code> <code>**kwargs</code> <code>typing.Any</code> <p>Keyword arguments passed to <code>PlotLineObject</code></p> <code>{}</code> <p>Raises:</p> Type Description <code>ValueError</code> <p>If provided options are not compatible with each other</p> Source code in <code>puma/var_vs_vtx.py</code> <pre><code>def __init__(\n    self,\n    x_var: np.ndarray,\n    n_match: np.ndarray,\n    n_true: np.ndarray,\n    n_reco: np.ndarray,\n    bins: int | Sequence = 10,\n    key: str | None = None,\n    **kwargs: Any,\n) -&gt; None:\n    if len(x_var) != len(n_match):\n        raise ValueError(\n            f\"Length of `x_var` ({len(x_var)}) and `n_match` \"\n            f\"({len(n_match)}) have to be identical.\"\n        )\n    if len(x_var) != len(n_true):\n        raise ValueError(\n            f\"Length of `x_var` ({len(x_var)}) and `n_true` \"\n            f\"({len(n_true)}) have to be identical.\"\n        )\n    if len(x_var) != len(n_reco):\n        raise ValueError(\n            f\"Length of `x_var` ({len(x_var)}) and `n_reco` \"\n            f\"({len(n_reco)}) have to be identical.\"\n        )\n\n    self.x_var = np.array(x_var)\n    self.n_match = np.array(n_match)\n    self.n_true = np.array(n_true)\n    self.n_reco = np.array(n_reco)\n    # Binning related variables\n    self.n_bins = None\n    self.bin_edges = None\n    self.x_bin_centres = None\n    self.bin_widths = None\n    # Binned distributions\n    self.bin_indices = None\n    self.metric_binned = None\n\n    self._set_bin_edges(bins)\n    self._apply_binning()\n\n    VarVsVar.__init__(\n        self,\n        x_var=self.x_bin_centres,\n        y_var_mean=np.zeros_like(self.x_bin_centres),\n        y_var_std=np.zeros_like(self.x_bin_centres),\n        x_var_widths=2 * self.bin_widths,\n        key=key,\n        fill=True,\n        plot_y_std=False,\n        **kwargs,\n    )\n</code></pre>"},{"location":"api/var_vs_var/#puma.var_vs_vtx.VarVsVtx.efficiency","title":"<code>efficiency</code>  <code>property</code>","text":"<p>Calculate vertexing efficiency per bin. Defined as number of reconstructed vertices matched to truth divided by number of total true vertices.</p> <p>Returns:</p> Type Description <code>numpy.ndarray</code> <p>Efficiency</p> <code>numpy.ndarray</code> <p>Efficiency error</p>"},{"location":"api/var_vs_var/#puma.var_vs_vtx.VarVsVtx.fakes","title":"<code>fakes</code>  <code>property</code>","text":"<p>Calculate vertexing fake rate per bin. Defined as total number of events with reconstructed vertices where vertices are not expected.</p> <p>Returns:</p> Type Description <code>numpy.ndarray</code> <p>Fake rate</p> <code>numpy.ndarray</code> <p>Fake rate error</p>"},{"location":"api/var_vs_var/#puma.var_vs_vtx.VarVsVtx.purity","title":"<code>purity</code>  <code>property</code>","text":"<p>Calculate vertexing purity per bin. Defined as number of reconstructed vertices matched to truth divided by number of total reconstructed vertices.</p> <p>Returns:</p> Type Description <code>numpy.ndarray</code> <p>Purity</p> <code>numpy.ndarray</code> <p>Purity error</p>"},{"location":"api/var_vs_var/#puma.var_vs_vtx.VarVsVtx.__eq__","title":"<code>__eq__</code>","text":"<p>Handles a == check with the class.</p> <p>Parameters:</p> Name Type Description Default <code>other</code> <code>puma.var_vs_vtx.VarVsVtx</code> <p>Other VarVsVtx that this class is tested against</p> required <p>Returns:</p> Type Description <code>bool</code> <p>If this VarVsVtx and the other are equal</p> Source code in <code>puma/var_vs_vtx.py</code> <pre><code>def __eq__(self, other: VarVsVtx) -&gt; bool:\n    \"\"\"Handles a == check with the class.\n\n    Parameters\n    ----------\n    other : VarVsVtx\n        Other VarVsVtx that this class is tested against\n\n    Returns\n    -------\n    bool\n        If this VarVsVtx and the other are equal\n    \"\"\"\n    if isinstance(other, self.__class__):\n        return (\n            np.all(self.x_var == other.x_var)\n            and np.all(self.n_match == other.n_match)\n            and np.all(self.n_true == other.n_true)\n            and np.all(self.n_reco == other.n_reco)\n            and np.all(self.bin_edges == other.bin_edges)\n            and self.key == other.key\n        )\n    return False\n</code></pre>"},{"location":"api/var_vs_var/#puma.var_vs_vtx.VarVsVtx.get","title":"<code>get</code>","text":"<p>Wrapper around rejection and efficiency functions.</p> <p>Parameters:</p> Name Type Description Default <code>mode</code> <code>str</code> <p>Can be \"efficiency\", \"purity\" or \"fakes\"</p> required <p>Returns:</p> Type Description <code>numpy.ndarray</code> <p>Efficiency, purity or fake rate depending on <code>mode</code> value</p> <code>numpy.ndarray</code> <p>Efficiency, purity or fake rate error depending on <code>mode</code> value</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If mode not supported</p> Source code in <code>puma/var_vs_vtx.py</code> <pre><code>def get(self, mode: str):\n    \"\"\"Wrapper around rejection and efficiency functions.\n\n    Parameters\n    ----------\n    mode : str\n        Can be \"efficiency\", \"purity\" or \"fakes\"\n\n    Returns\n    -------\n    np.ndarray\n        Efficiency, purity or fake rate depending on `mode` value\n    np.ndarray\n        Efficiency, purity or fake rate error depending on `mode` value\n\n    Raises\n    ------\n    ValueError\n        If mode not supported\n    \"\"\"\n    if mode == \"efficiency\":\n        return self.efficiency\n    if mode == \"purity\":\n        return self.purity\n    if mode == \"fakes\":\n        return self.fakes\n    raise ValueError(\n        f\"The selected mode {mode} is not supported. Use one of the following:\"\n        f\" {VarVsVtxPlot.mode_options}.\"\n    )\n</code></pre>"},{"location":"api/var_vs_var/#puma.var_vs_vtx.VarVsVtx.get_performance_ratio","title":"<code>get_performance_ratio</code>","text":"<p>Calculate performance ratio for vertexing task. Either n_matched/n_true (efficiency) or n_matched/n_reco (purity).</p> <p>Parameters:</p> Name Type Description Default <code>num</code> <code>numpy.ndarray</code> <p>Array with discriminants</p> required <code>denom</code> <code>numpy.ndarray</code> <p>Cut value</p> required <p>Returns:</p> Type Description <code>numpy.ndarray</code> <p>Performance ratio</p> <code>numpy.ndarray</code> <p>Performance ratio error</p> Source code in <code>puma/var_vs_vtx.py</code> <pre><code>def get_performance_ratio(\n    self,\n    num: np.ndarray,\n    denom: np.ndarray,\n) -&gt; tuple[np.ndarray, np.ndarray]:\n    \"\"\"Calculate performance ratio for vertexing task. Either n_matched/n_true\n    (efficiency) or n_matched/n_reco (purity).\n\n    Parameters\n    ----------\n    num : np.ndarray\n        Array with discriminants\n    denom : np.ndarray\n        Cut value\n\n    Returns\n    -------\n    np.ndarray\n        Performance ratio\n    np.ndarray\n        Performance ratio error\n    \"\"\"\n    pm = save_divide(np.sum(num), np.sum(denom), default=np.inf)\n    if pm == np.inf:\n        logger.warning(\"Your vertexing performance ratio is infinity -&gt; setting it to np.nan.\")\n        return np.nan, np.nan\n    if pm == 0:\n        logger.warning(\"Your vertexing performance ratio is zero -&gt; setting error to zero.\")\n        return 0.0, 0.0\n    pm_error = calculate_efficiency_error(pm, len(num))\n    return pm, pm_error\n</code></pre>"},{"location":"api/var_vs_var/#puma.var_vs_vtx.VarVsVtxPlot","title":"<code>puma.var_vs_vtx.VarVsVtxPlot</code>","text":"<p>               Bases: <code>puma.var_vs_var.VarVsVarPlot</code></p> <p>var_vs_vtx plot class.</p> <p>Parameters:</p> Name Type Description Default <code>mode</code> <code>str</code> <p>Defines which quantity is plotted, the following options ar available:     efficiency - Plots efficiency vs. variable for jets where vertices are     expected     purity - Plots purity vs. variable for jets where vertices are expected     fakes - Plots fake rate vs. variable for jets where vertices are not     expected</p> required <code>grid</code> <code>bool</code> <p>Set the grid for the plots.</p> <code>False</code> <code>**kwargs</code> <code>typing.Any</code> <p>Keyword arguments from <code>puma.PlotObject</code></p> <code>{}</code> <p>Attributes:</p> Name Type Description <code>mode_options</code> <code>typing.ClassVar[list[str]]</code> <p>List of possible modes.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If incompatible mode given or more than 1 ratio panel requested</p> Source code in <code>puma/var_vs_vtx.py</code> <pre><code>def __init__(self, mode: str, grid: bool = False, **kwargs: Any) -&gt; None:\n    super().__init__(grid=grid, **kwargs)\n    if mode not in self.mode_options:\n        raise ValueError(\n            f\"The selected mode {mode} is not supported. Use one of the following: \"\n            f\"{self.mode_options}.\"\n        )\n    self.mode = mode\n</code></pre>"},{"location":"api/var_vs_var/#puma.var_vs_vtx.VarVsVtxPlot.plot","title":"<code>plot</code>","text":"<p>Plotting curves.</p> <p>Parameters:</p> Name Type Description Default <code>**kwargs</code> <code>typing.Any</code> <p>Keyword arguments passed to plt.axis.errorbar</p> <code>{}</code> <p>Returns:</p> Type Description <code>matplotlib.lines.Line2D</code> <p>matplotlib Line2D object</p> Source code in <code>puma/var_vs_vtx.py</code> <pre><code>def plot(self, **kwargs: Any) -&gt; mpl.lines.Line2D:\n    \"\"\"Plotting curves.\n\n    Parameters\n    ----------\n    **kwargs: Any\n        Keyword arguments passed to plt.axis.errorbar\n\n    Returns\n    -------\n    mpl.lines.Line2D\n        matplotlib Line2D object\n    \"\"\"\n    logger.debug(\"Plotting curves with mode %s\", self.mode)\n    self._setup_curves()\n    return super().plot(**kwargs)\n</code></pre>"},{"location":"dev/development_guidelines/","title":"Good coding practices","text":""},{"location":"dev/development_guidelines/#development-setup","title":"Development Setup","text":""},{"location":"dev/development_guidelines/#installing-for-development","title":"Installing for development","text":"<p>For development, we recommend using <code>uv</code>, a fast Python package installer and resolver written in Rust. It provides significantly faster dependency resolution and installation compared to traditional tools.</p>"},{"location":"dev/development_guidelines/#install-uv","title":"Install uv","text":"<pre><code># On macOS and Linux\ncurl -LsSf https://astral.sh/uv/install.sh | sh\n\n# On Windows\npowershell -c \"irm https://astral.sh/uv/install.ps1 | iex\"\n\n# Or with pip (If installing from PyPI, we recommend installing uv into an isolated environment)\npip install uv\n</code></pre>"},{"location":"dev/development_guidelines/#install-puma-in-development-mode","title":"Install puma in development mode","text":"<pre><code>git clone https://github.com/umami-hep/puma.git\ncd puma\nuv sync --extra dev\n</code></pre> <p>This installs <code>puma</code> in editable mode with all development dependencies including testing frameworks, linters, formatters, etc.</p>"},{"location":"dev/development_guidelines/#alternative-using-pip","title":"Alternative: Using pip","text":"<p>If you prefer to use <code>pip</code>, you can still install with:</p> <pre><code>python -m pip install -e \".[dev]\"\n</code></pre>"},{"location":"dev/development_guidelines/#test-driven-development","title":"Test-Driven Development","text":"<p>The <code>puma</code> framework uses unit tests to reduce the risk for bugs being undetected. If you contribute to <code>puma</code>, please make sure that you add unit tests for the new code.</p>"},{"location":"dev/development_guidelines/#code-style","title":"Code Style","text":"<p>We are using the <code>black</code> python formatter, which also runs in the pipeline to check if your code is properly formatted. Most editors have a quite nice integration of <code>black</code> where you can e.g. set up automatic formatting when you save a file.</p>"},{"location":"dev/development_guidelines/#linters","title":"Linters","text":"<p>In addition to the pure style-component of checking the code with <code>black</code>, we use <code>ruff</code> to check the code for bad coding practices and docstrings. Make sure to run  <code>ruff</code> before you commit your code.</p>"},{"location":"dev/development_guidelines/#pre-commit-hook","title":"Pre-commit hook","text":"<p>To check staged files for style conformity, you can use the <code>pre-commit</code> hook, which then won't allow you to commit your staged changes if <code>ruff</code>  or `black fails. You can set it up by executing the following in the root of the repo:</p> <pre><code>pre-commit install\n</code></pre>"},{"location":"dev/docker/","title":"Docker images","text":"<p>The Docker images are built on GitHub and contain the latest version from the <code>main</code> branch.</p> <p>The container registry with all available tags can be found here.</p> <p>On a machine with Docker installed:</p> <pre><code>docker run -it --rm -v $PWD:/puma_container -w /puma_container gitlab-registry.cern.ch/aft/training-images/puma-images/puma:latest bash\n</code></pre> <p>On a machine/cluster with singularity installed:</p> <pre><code>singularity shell -B $PWD docker://gitlab-registry.cern.ch/aft/training-images/puma-images/puma:latest\n</code></pre>"},{"location":"dev/docs_development/","title":"Docs development","text":""},{"location":"dev/docs_development/#adding-a-new-versiontag-to-the-docs","title":"Adding a new version/tag to the docs","text":"<p>To add the docs of a specific release/tag to the deployment on GitHub pages, just add the corresponding version to the file <code>docs/source/_static/switcher.json</code>. The corresponding job in the CI will then automatically build the docs for this release and add it to the deployment.</p> <p></p>"},{"location":"dev/docs_development/#downloading-the-artifact-of-a-dev-version-of-the-docs","title":"Downloading the artifact of a dev version of the docs","text":"<p>When changing something in the <code>puma</code> documentation, you might find yourself in a situation where you want to see if your changes have the intended effect.</p> <p>The docs are only deployed for commits on the <code>main</code> branch. However, the docs are built for every commit, no matter on which branch, and are uploaded as an artifact.</p> <p>This means that you can download the docs as a <code>.zip</code> file and then browser the html files on your machine.</p> <p>If you have an open pull request for your changes, you find the artifact like shown below (click on the button that is marked with the red circle). After downloading, unzip the file and open the <code>artifact/index.html</code> file in your browser. You should then see the docs that you just downloaded.</p> <p> </p>"},{"location":"examples/","title":"Examples","text":"<p>Please find links to the examples in the sidebar on the left.</p> <p>Note that the high-level plotting interface is generally recommended as the fastest and easiest way to make plots.</p>"},{"location":"examples/confusion_matrix/","title":"Confusion Matrix","text":"<p>This function evaluates the (multiclass[^1]) Confusion Matrix (CM) associated to a classifier output predictions. The CM is a metric that measures the misclassification rates between all the classes in the classification task.</p>"},{"location":"examples/confusion_matrix/#mathematical-definition","title":"Mathematical definition","text":"<p>Mathematically, if the classification task has N_c target classes, the CM is an N_c \\times N_c matrix whose entry C_{i,j} is the number of predictions known to be in group i and predicted to be in group j.  The matrix can then be normalized in different ways, obtaining rates of misclassifications instead of raw counts (more on that in normalization).</p>"},{"location":"examples/confusion_matrix/#implementation","title":"Implementation","text":"<p>The function <code>confusion_matrix</code> in <code>puma.utils.confusion_matrix</code> computes the CM from two arrays of target and predicted labels. The basic usage is: <pre><code>targets = np.array([2, 0, 2, 2, 0, 1])\npredictions = np.array([0, 0, 2, 2, 0, 2])\nconfusion_matrix(targets, predictions)\n</code></pre></p> <p>Eventually, samples can be weighted by their relative importance by providing an array of weights w_i \\in [0,1]: <pre><code>targets = np.array([2, 0, 2, 2, 0, 1])\npredictions = np.array([0, 0, 2, 2, 0, 2])\nweights = np.array([1, 0.5, 0.5, 1, 0.2, 1])\nconfusion_matrix(targets, predictions, sample_weights=weights)\n</code></pre></p>"},{"location":"examples/confusion_matrix/#normalization","title":"Normalization","text":"<p>There are four possible normalization choices, which can be selected through the <code>normalize</code> argument of the function: <code>None</code> to use raw counts; <code>\"rownorm\"</code> to normalize across the prediction class, i.e. such that the rows add to one (default); <code>\"colnorm\"</code> to normalize across the target class, i.e. such that the columns add to one; <code>\"all\"</code> to normalize across all examples, i.e. such that all matrix entries add to one. Defaults to <code>\"rownorm\"</code>.</p>"},{"location":"examples/confusion_matrix/#example","title":"Example","text":"<pre><code>\"\"\"Produce the confusion matrix for a tagger output.\"\"\"\n\nfrom __future__ import annotations\n\nimport numpy as np\n\nfrom puma.utils.confusion_matrix import confusion_matrix\n\n# Sample size\nN = 100\n\n# Number of target classes\nNclass = 3\n\n# Dummy target labels\ntargets = np.random.randint(0, Nclass, size=N)\n# Making sure that there is at least one sample for each class\ntargets = np.append(targets, np.array(list(range(Nclass))))\n\n# Dummy predicted labels\npredictions = np.random.randint(0, Nclass, size=(N + Nclass))\n\n\n# Confusion matrix examples:\n\n# Unweighted confusion matrix, normalized on all entries\nunweighted_cm = confusion_matrix(targets, predictions, normalize=\"all\")\nprint(\"Unweighted, normalized on all entries, CM:\")\nprint(unweighted_cm)\nprint(\" \")\n\n# Unweighted confusion matrix, normalized on true labels\nunweighted_cm = confusion_matrix(targets, predictions, normalize=\"rownorm\")\nprint(\"Unweighted, normalized true labels (rownorm), CM:\")\nprint(unweighted_cm)\nprint(\" \")\n\n# Unweighted confusion matrix, with raw counts (non-normalized)\nunweighted_cm = confusion_matrix(targets, predictions, normalize=None)\nprint(\"Unweighted, non-normalized, CM:\")\nprint(unweighted_cm)\nprint(\" \")\n\n# Weighted Confusion Matrix\n# Dummy sample weights\nsample_weights = np.random.rand(N + Nclass)\n\nweighted_cm = confusion_matrix(targets, predictions, sample_weights=sample_weights)\nprint(\"Weighted CM:\")\nprint(weighted_cm)\n</code></pre> <p>[^1] In a multiclass task, each sample belongs to one and only class (the true label, or target label).</p>"},{"location":"examples/dummy_data/","title":"Dummy Data","text":"<p>To test/demonstrate the <code>puma</code> API, we just want to use dummy data.</p> <p>There are three methods in puma to generate dummy data:</p> <p>The first function returns directly a <code>pandas.DataFrame</code> including the following columns:</p> <ul> <li><code>HadronConeExclTruthLabelID</code></li> <li><code>rnnip_pu</code></li> <li><code>rnnip_pc</code></li> <li><code>rnnip_pb</code></li> <li><code>dips_pu</code></li> <li><code>dips_pc</code></li> <li><code>dips_pb</code></li> </ul> <p>which can be used in the following manner:</p> <pre><code>from puma.utils import get_dummy_2_taggers\n\ndf = get_dummy_2_taggers()\n</code></pre> <p>The second function is <code>get_dummy_multiclass_scores</code> which returns an output array with shape <code>(size, 3)</code>, which is the usual output of our multi-class classifiers like DIPS, and the labels conform with the <code>HadronConeExclTruthLabelID</code> variable.</p> <pre><code>from puma.utils import get_dummy_multiclass_scores\n\noutput, labels = get_dummy_multiclass_scores()\n</code></pre> <p>Finally, the <code>get_dummy_tagger_aux</code> function returns a h5 file with both jet and track collections (needed for aux task plots). These include the following columns (aux task information is generated for both vertexing and track origin classification):</p> <p>jets:</p> <ul> <li><code>HadronConeExclTruthLabelID</code></li> <li><code>GN2_pu</code></li> <li><code>GN2_pc</code></li> <li><code>GN2_pb</code></li> <li><code>pt</code></li> <li><code>eta</code></li> <li><code>n_truth_promptLepton</code></li> </ul> <p>tracks:</p> <ul> <li><code>ftagTruthVertexIndex</code></li> <li><code>GN2_VertexIndex</code></li> <li><code>ftagTruthOriginLabel</code></li> <li><code>GN2_TrackOrigin</code></li> </ul> <p>which can be used in the following manner:</p> <pre><code>from puma.utils import get_dummy_tagger_aux\n\ndf = get_dummy_tagger_aux()\n</code></pre>"},{"location":"examples/fraction_scan/","title":"Fraction Scan Plots","text":"<p>In the following a small example how to plot the rejections for the different fraction value combinations. In this example,  value from numpy arange are used.</p> <p></p> <pre><code>\"\"\"Example of fraction scan plot.\"\"\"\n\nfrom __future__ import annotations\n\nimport numpy as np\nfrom ftag import Flavours\nfrom ftag.utils import calculate_efficiency, get_discriminant\n\nfrom puma import Line2D, Line2DPlot\nfrom puma.utils import get_dummy_2_taggers, logger\n\n# The line below generates dummy data which is similar to a NN output\ndf = get_dummy_2_taggers(size=100_000)\n\nlogger.info(\"caclulate tagger discriminants\")\n\n# defining boolean arrays to select the different flavour classes\nis_light = df[\"HadronConeExclTruthLabelID\"] == 0\nis_c = df[\"HadronConeExclTruthLabelID\"] == 4\nis_b = df[\"HadronConeExclTruthLabelID\"] == 5\n\n\nfc_values = np.linspace(0.0, 1.0, 101)\nSIG_EFF = 0.77\n\ndips_scores = df[[\"dips_pu\", \"dips_pc\", \"dips_pb\"]]\n\n\ndef calc_effs(fc_value: float):\n    \"\"\"Tagger efficiency for fixed working point.\n\n    Parameters\n    ----------\n    fc_value : float\n        Value for the charm fraction used in discriminant calculation.\n\n    Returns\n    -------\n    tuple\n        Tuple of shape (, 3) containing (fc_value, ujets_eff, cjets_eff)\n    \"\"\"\n    disc = get_discriminant(\n        jets=dips_scores,\n        tagger=\"dips\",\n        signal=Flavours[\"bjets\"],\n        flavours=Flavours.by_category(\"single-btag\"),\n        fraction_values={\"fc\": fc_value, \"fu\": 1 - fc_value, \"ftau\": 0},\n    )\n    ujets_eff = calculate_efficiency(disc[is_b], disc[is_light], SIG_EFF)\n    cjets_eff = calculate_efficiency(disc[is_b], disc[is_c], SIG_EFF)\n\n    return [fc_value, ujets_eff, cjets_eff]\n\n\neff_results = np.array(list(map(calc_effs, fc_values)))\n\n\n# Init example x- and y values of the fraction scan. Theses\n# are the x- and y values for the rejections for different fractions.\n# You can plot 2 rejections against each other. These values can either\n# be arrays, lists, ints or floats but the dtype must be the same and also\n# the number of values inside!\nx_values = eff_results[:, 2]\ny_values = eff_results[:, 1]\n\n# If you want to mark a specific point with a marker, you just need to\n# define the x- and y values again for the marker (This must be floats)\nMARKER_X = eff_results[30, 2]\nMARKER_Y = eff_results[30, 1]\n\n# You can give several plotting options to the plot itself\n\n# Now init a fraction scan plot\nfrac_plot = Line2DPlot()\n\n# Add our x- and y values as a new line\n# The colour and linestyle are optional here\nfrac_plot.add(\n    Line2D(\n        x_values=x_values,\n        y_values=y_values,\n        label=\"Tagger 1\",\n        colour=\"r\",\n        linestyle=\"-\",\n    )\n)\n\n# Add a marker for the just added fraction scan. If you don't\n# set the colour here, the colour of the last added element will be used.\n# marker, markersize and markeredgewidth are optional. The here\n# given values are the default values.\n# The is_marker bool tells the plot that this is a marker and not a line\nfrac_plot.add(\n    Line2D(\n        x_values=MARKER_X,\n        y_values=MARKER_Y,\n        colour=\"r\",\n        marker=\"x\",\n        label=rf\"$f_c={eff_results[30, 0]}$\",\n        markersize=15,\n        markeredgewidth=2,\n    ),\n    is_marker=True,\n)\n\n# Adding labels\nfrac_plot.ylabel = \"Light-flavour jets efficiency\"\nfrac_plot.xlabel = \"$c$-jets efficiency\"\n\n# Draw and save the plot\nfrac_plot.draw()\nfrac_plot.savefig(\"FractionScanPlot_test.png\")\n</code></pre>"},{"location":"examples/histograms/","title":"Histograms","text":"<p>The following examples use the dummy data which is described here</p>"},{"location":"examples/histograms/#b-tagging-discriminant-plot","title":"b-tagging Discriminant Plot","text":"<pre><code>\"\"\"Produce histogram of discriminant from tagger output and labels.\"\"\"\n\nfrom __future__ import annotations\n\nimport numpy as np\nfrom ftag import Flavours\nfrom ftag.utils import get_discriminant\n\nfrom puma import Histogram, HistogramPlot\nfrom puma.utils import get_dummy_2_taggers, get_good_linestyles\n\n# The line below generates dummy data which is similar to a NN output\ndf = get_dummy_2_taggers()\n\n# Calculate discriminant scores for DIPS and RNNIP, and add them to the dataframe\ndisc_dips = get_discriminant(\n    jets=df,\n    tagger=\"dips\",\n    signal=Flavours[\"bjets\"],\n    flavours=Flavours.by_category(\"single-btag\"),\n    fraction_values={\n        \"fc\": 0.018,\n        \"fu\": 0.982,\n        \"ftau\": 0,\n    },\n)\ndisc_rnnip = get_discriminant(\n    jets=df,\n    tagger=\"rnnip\",\n    signal=Flavours[\"bjets\"],\n    flavours=Flavours.by_category(\"single-btag\"),\n    fraction_values={\n        \"fc\": 0.018,\n        \"fu\": 0.982,\n        \"ftau\": 0,\n    },\n)\n\n# defining boolean arrays to select the different flavour classes\nis_light = df[\"HadronConeExclTruthLabelID\"] == 0\nis_c = df[\"HadronConeExclTruthLabelID\"] == 4\nis_b = df[\"HadronConeExclTruthLabelID\"] == 5\n\ntaggers = [\"dips\", \"rnnip\"]\ndiscs = {\"dips\": disc_dips, \"rnnip\": disc_rnnip}\nlinestyles = get_good_linestyles()[:2]\n\n# Initialise histogram plot\nplot_histo = HistogramPlot(\n    n_ratio_panels=1,\n    ylabel=\"Normalised number of jets\",\n    ylabel_ratio=[\"Ratio to DIPS\"],\n    xlabel=\"$b$-jet discriminant\",\n    logy=False,\n    leg_ncol=1,\n    figsize=(5.5, 4.5),\n    y_scale=1.5,\n    ymax_ratio=[1.5],\n    ymin_ratio=[0.5],\n    atlas_second_tag=\"$\\\\sqrt{s}=13$ TeV, dummy jets \\ndummy sample, $f_{c}=0.018$\",\n)\n\n# Add the histograms\nfor tagger, linestyle in zip(taggers, linestyles, strict=False):\n    plot_histo.add(\n        Histogram(\n            values=discs[tagger][is_light],\n            # Only specify the label for the case of the \"DIPS\" light-jets, since we\n            # want to hide the legend entry for \"RNNIP\" light-jets as it has the same\n            # linecolour. Instead, we specify a \"linestyle legend\" further down in the\n            # script\n            bins=np.linspace(-10, 10, 50),\n            label=\"Light-flavour jets\" if tagger == \"dips\" else None,\n            colour=Flavours[\"ujets\"].colour,\n            ratio_group=\"ujets\",\n            linestyle=linestyle,\n        ),\n        reference=tagger == \"dips\",\n    )\n    plot_histo.add(\n        Histogram(\n            values=discs[tagger][is_c],\n            bins=np.linspace(-10, 10, 50),\n            label=\"$c$-jets\" if tagger == \"dips\" else None,\n            colour=Flavours[\"cjets\"].colour,\n            ratio_group=\"cjets\",\n            linestyle=linestyle,\n        ),\n        reference=tagger == \"dips\",\n    )\n    plot_histo.add(\n        Histogram(\n            values=discs[tagger][is_b],\n            bins=np.linspace(-10, 10, 50),\n            label=\"$b$-jets\" if tagger == \"dips\" else None,\n            colour=Flavours[\"bjets\"].colour,\n            ratio_group=\"bjets\",\n            linestyle=linestyle,\n        ),\n        reference=tagger == \"dips\",\n    )\n\nplot_histo.draw()\n# The lines below create a legend for the linestyles (i.e. solid lines -&gt; DIPS, dashed\n# lines -&gt; RNNIP here). The \"bbox_to_anchor\" argument specifies where to place the\n# linestyle legend\nplot_histo.make_linestyle_legend(\n    linestyles=linestyles, labels=[\"DIPS\", \"RNNIP\"], bbox_to_anchor=(0.55, 1)\n)\nplot_histo.savefig(\"histogram_discriminant.png\", transparent=False)\n</code></pre>"},{"location":"examples/histograms/#flavour-probabilities-plot","title":"Flavour Probabilities Plot","text":"<pre><code>\"\"\"Example plot script for flavour probability comparison.\"\"\"\n\nfrom __future__ import annotations\n\nimport numpy as np\nfrom ftag import Flavours\n\nfrom puma import Histogram, HistogramPlot\nfrom puma.utils import get_dummy_2_taggers\n\n# The line below generates dummy data which is similar to a NN output\ndf = get_dummy_2_taggers()\n\n# Initialise histogram plot\nplot_histo = HistogramPlot(\n    n_ratio_panels=0,\n    ylabel=\"Normalised number of jets\",\n    xlabel=\"$b$-jets probability\",\n    logy=True,\n    leg_ncol=1,\n    atlas_first_tag=\"Simulation, $\\\\sqrt{s}=13$ TeV\",\n    atlas_second_tag=\"dummy sample, dummy jets\",\n    atlas_brand=None,  # You can deactivate the ATLAS branding (e.g. for a thesis)\n    draw_errors=False,\n)\n\n# Add the ttbar histograms\nu_jets = df[df[\"HadronConeExclTruthLabelID\"] == 0]\nc_jets = df[df[\"HadronConeExclTruthLabelID\"] == 4]\nb_jets = df[df[\"HadronConeExclTruthLabelID\"] == 5]\n\n# The 'flavour' option here takes an instance of Label (coming from the atlas-ftag-tools package)\n# as input. You can use default flavours by importing Flavours from the ftag package\nplot_histo.add(\n    Histogram(\n        u_jets[\"dips_pb\"],\n        bins=np.linspace(0, 1, 30),\n        flavour=Flavours[\"ujets\"],\n        linestyle=\"dashed\",\n    )\n)\nplot_histo.add(\n    Histogram(\n        c_jets[\"dips_pb\"],\n        bins=np.linspace(0, 1, 30),\n        flavour=Flavours[\"cjets\"],\n        linestyle=\"dashdot\",\n    )\n)\nplot_histo.add(\n    Histogram(\n        b_jets[\"dips_pb\"],\n        bins=np.linspace(0, 1, 30),\n        flavour=Flavours[\"bjets\"],\n    )\n)\n\nplot_histo.draw()\nplot_histo.savefig(\"histogram_bjets_probability.png\", transparent=False)\n</code></pre>"},{"location":"examples/histograms/#more-general-example","title":"More General Example","text":"<p>In most cases you probably want to plot histograms with the different flavours like in the examples above. However, the <code>puma</code> API allows to plot any kind of data. As an example, you could also produce a <code>MC</code> vs <code>data</code> plot with the following example code:</p> <p></p> <pre><code>\"\"\"Example of histogram plot that deviates from puma default plots.\"\"\"\n\nfrom __future__ import annotations\n\nimport numpy as np\n\nfrom puma import Histogram, HistogramPlot\n\n# Generate two distributions to plot\nN_BKG = int(1e6)\nN_SIG = int(2e4)\nrng = np.random.default_rng(seed=42)\nexpectation = rng.exponential(size=N_BKG)\nmeasurement = np.concatenate((\n    rng.exponential(size=N_BKG),\n    rng.normal(loc=2, scale=0.2, size=N_SIG),\n))\nexpectation_hist = Histogram(\n    values=expectation,\n    bins=50,\n    bins_range=(1.1, 4),\n    norm=False,\n    label=\"MC\",\n    histtype=\"stepfilled\",\n    alpha=1,\n)\nmeasurement_hist = Histogram(\n    values=measurement,\n    bins=50,\n    bins_range=(1.1, 4),\n    norm=False,\n    label=\"dummy data\",\n)\n\n# Initialise histogram plot\nplot_histo = HistogramPlot(\n    ylabel=\"Number of events\",\n    xlabel=\"Invariant mass $m$ [a.u.]\",\n    logy=False,\n    atlas_first_tag=\"Simulation Internal\",\n    atlas_second_tag=\"Example for more general plot\",\n    figsize=(6, 5),\n    n_ratio_panels=1,\n)\n\n# Add histograms and plot\nplot_histo.add(expectation_hist, reference=True)\nplot_histo.add(measurement_hist)\nplot_histo.draw()\n\nplot_histo.savefig(\"histogram_basic_example.png\", transparent=False)\n</code></pre>"},{"location":"examples/histograms/#weighted-histograms","title":"Weighted Histograms","text":"<p><code>puma</code> also supports weighted histograms by specifying the optional argument <code>weights</code>. An example is given below:</p> <p></p> <pre><code>\"\"\"Example script for plotting weighted histograms.\"\"\"\n\nfrom __future__ import annotations\n\nimport numpy as np\n\nfrom puma import Histogram, HistogramPlot\n\nrng = np.random.default_rng(seed=42)\n# we define two gaussian distributions - one located at 0, one at 3\nvalues = np.hstack((rng.normal(size=10_000), rng.normal(loc=3, size=10_000)))\n# for the weighted histogram we weight entries of the right peak by a factor of 2\nweights = np.hstack((np.ones(10_000), 2 * np.ones(10_000)))\n\nhist_plot = HistogramPlot(n_ratio_panels=1)\n# add the unweighted histogram\nhist_plot.add(\n    Histogram(\n        values=values,\n        bins=40,\n        bins_range=(-3, 6),\n        norm=False,\n        label=\"Without weights\",\n    ),\n    reference=True,\n)\n# add the weighted histogram\nhist_plot.add(\n    Histogram(\n        values=values,\n        bins=40,\n        bins_range=(-3, 6),\n        weights=weights,\n        norm=False,\n        label=\"Weight 2 for right peak\",\n    )\n)\nhist_plot.draw()\nhist_plot.savefig(\"histogram_weighted.png\")\n</code></pre>"},{"location":"examples/histograms/#underflowoverflow-bins","title":"Underflow/Overflow Bins","text":"<p>Underflow and overflow bins are enabled by default, but can be deactivated using the <code>underoverflow</code> attribute of <code>puma.HistogramPlot</code>. Below an example of the same Gaussian distribution plotted with and without underflow/overflow bins.</p> <p> </p> <pre><code>\"\"\"Example script that demonstrates under/overflow bins.\"\"\"\n\nfrom __future__ import annotations\n\nimport numpy as np\n\nfrom puma import Histogram, HistogramPlot\n\nrng = np.random.default_rng(42)\n\nvals = rng.normal(size=10_000)\n\nplot_without = HistogramPlot()\nplot_without.title = \"Without underflow/overflow bins\"\nplot_without.add(\n    Histogram(\n        values=vals,\n        bins=40,\n        bins_range=(-2, 2),\n        underoverflow=False,\n        label=\"Gaussian($\\\\mu=0$, $\\\\sigma=1$)\",\n    )\n)\nplot_without.draw()\nplot_without.savefig(\"hist_without_underoverflow.png\")\n\nplot_with = HistogramPlot()\nplot_with.title = \"With underflow/overflow bins\"\nplot_with.add(\n    Histogram(\n        values=vals,\n        bins=40,\n        bins_range=(-2, 2),\n        label=\"Gaussian($\\\\mu=0$, $\\\\sigma=1$)\",\n    )\n)\nplot_with.draw()\nplot_with.savefig(\"hist_with_underoverflow.png\")\n</code></pre>"},{"location":"examples/histograms/#iteratively-filling-a-histogram","title":"Iteratively Filling a Histogram","text":"<p>Sometimes, the amount of data/jets you want to histogram, is too large to fit in your RAM. To avoid issues here, you can use the <code>update()</code> function of the <code>Histogram</code> class.</p> <p></p> <pre><code>\"\"\"Example script that demonstrates iterative Histogram filling.\"\"\"\n\nfrom __future__ import annotations\n\nimport numpy as np\n\nfrom puma import Histogram, HistogramPlot\n\nrng = np.random.default_rng(42)\n\n# We create now two value sets to mimic a batch-wise loading\nvals = rng.normal(size=10_000)\nextra_vals = rng.normal(size=10_000)\n\n# We can also define weights for each entry. For simplicity, we set them to one for this example\nweights_vals = np.ones_like(vals)\nweights_extra_vals = np.ones_like(extra_vals)\n\n# Now loop over our batches\nfor counter, (batch_values, batch_weights) in enumerate(\n    zip([vals, extra_vals], [weights_vals, weights_extra_vals], strict=False)\n):\n    # Create the histogram if it's the first batch\n    if counter == 0:\n        histo = Histogram(\n            values=batch_values,\n            weights=batch_weights,\n            bins=40,\n            bins_range=(-2, 2),\n            underoverflow=False,\n            label=\"Gaussian($\\\\mu=0$, $\\\\sigma=1$)\",\n        )\n\n    # Update the existing histogram else\n    else:\n        histo.update(values=batch_values, weights=batch_weights)\n\n# Create the HistogramPlot and add the iterativly filled histogram\nplot = HistogramPlot()\nplot.add(histo)\nplot.draw()\nplot.savefig(\"Iterative_histogram.png\")\n</code></pre>"},{"location":"examples/histograms/#datamc-histograms","title":"Data/MC Histograms","text":"<p>To visualize the agreement of the Monte-Carlo with data, <code>puma</code> is also able to produce so-called Data/MC histograms. They show the data as a dot histogram while the MC is still a stacked histogram. An example of this plot can be seen here:</p> <p></p> <p>The code to create this example can be found in the <code>examples</code> folder in the <code>plot_data_mc.py</code>. Similar to the rest of the <code>Puma.HistogramPlot</code> examples shown here, a lot of more optional argument can be passed.</p> <pre><code>\"\"\"Example script that demonstrates Data/MC plots.\"\"\"\n\nfrom __future__ import annotations\n\nimport numpy as np\n\nfrom puma import Histogram, HistogramPlot\n\n# Generate two MC contributions and data\nrng = np.random.default_rng(42)\nmc1 = rng.normal(size=10_000)\nmc2 = rng.normal(size=20_000)\ndata = rng.normal(size=30_000)\n\n# Set up the real plot\ndata_mc_plot = HistogramPlot(\n    n_ratio_panels=1,\n    stacked=True,\n)\n\n# Set the plot title\ndata_mc_plot.title = \"Test Data/MC Plot\"\n\n# Add the different MC contributions to the plot\ndata_mc_plot.add(\n    Histogram(\n        mc1,\n        bins=40,\n        bins_range=(-2, 2),\n        label=\"MC Process 1\",\n        norm=False,\n    )\n)\ndata_mc_plot.add(\n    Histogram(\n        mc2,\n        bins=40,\n        bins_range=(-2, 2),\n        label=\"MC Process 2\",\n        norm=False,\n    )\n)\n\n# Add the data\ndata_mc_plot.add(\n    Histogram(\n        data,\n        bins=40,\n        bins_range=(-2, 2),\n        label=\"Data\",\n        is_data=True,\n        colour=\"k\",\n        norm=False,\n    )\n)\n\n# Draw the plot\ndata_mc_plot.draw()\n\n# Add the bin width to the y-axis label\ndata_mc_plot.add_bin_width_to_ylabel()\ndata_mc_plot.savefig(\"data_mc_example.png\")\n</code></pre>"},{"location":"examples/int_eff/","title":"Integrated efficiency plot","text":"<p>In the following a small example how to plot a integrated efficiency plot with the <code>puma</code> API.</p> <p>Then we can start the actual plotting part:</p> <p></p> <pre><code>\"\"\"Produce Integrated Efficiency curves from tagger output and labels.\"\"\"\n\nfrom __future__ import annotations\n\nfrom ftag import Flavours\nfrom ftag.utils import get_discriminant\n\nfrom puma import IntegratedEfficiency, IntegratedEfficiencyPlot\nfrom puma.utils import get_dummy_2_taggers, logger\n\n# The line below generates dummy data which is similar to a NN output\ndf = get_dummy_2_taggers()\n\nlogger.info(\"caclulate tagger discriminants\")\ndiscs_dips = get_discriminant(\n    jets=df,\n    tagger=\"dips\",\n    signal=Flavours[\"bjets\"],\n    flavours=Flavours.by_category(\"single-btag\"),\n    fraction_values={\n        \"fc\": 0.018,\n        \"fu\": 0.982,\n        \"ftau\": 0,\n    },\n)\ndiscs_rnnip = get_discriminant(\n    jets=df,\n    tagger=\"rnnip\",\n    signal=Flavours[\"bjets\"],\n    flavours=Flavours.by_category(\"single-btag\"),\n    fraction_values={\n        \"fc\": 0.018,\n        \"fu\": 0.982,\n        \"ftau\": 0,\n    },\n)\n\n# defining boolean arrays to select the different flavour classes\nis_light = df[\"HadronConeExclTruthLabelID\"] == 0\nis_c = df[\"HadronConeExclTruthLabelID\"] == 4\nis_b = df[\"HadronConeExclTruthLabelID\"] == 5\n\nn_jets_light = sum(is_light)\nn_jets_c = sum(is_c)\n\nlogger.info(\"Calculate signal and background discriminant values.\")\nrnnip = {\n    \"sig_disc\": discs_rnnip[is_b],\n    \"bkg_disc_b\": discs_rnnip[is_b],\n    \"bkg_disc_c\": discs_rnnip[is_c],\n    \"bkg_disc_l\": discs_rnnip[is_light],\n}\ndips = {\n    \"sig_disc\": discs_dips[is_b],\n    \"bkg_disc_b\": discs_dips[is_b],\n    \"bkg_disc_c\": discs_dips[is_c],\n    \"bkg_disc_l\": discs_dips[is_light],\n}\n\n# here the plotting of the Integrated Efficiency curves starts\nlogger.info(\"Plotting IntegratedEfficiency curves.\")\nplot = IntegratedEfficiencyPlot(\n    ylabel=\"Integrated efficiency\",\n    xlabel=\"Discriminant\",\n    atlas_second_tag=\"$\\\\sqrt{s}=13$ TeV, dummy jets \\ndummy sample, $f_{c}=0.018$\",\n    figsize=(6.5, 6),\n    y_scale=1.4,\n)\nplot.add(\n    IntegratedEfficiency(rnnip[\"sig_disc\"], rnnip[\"bkg_disc_b\"], flavour=\"bjets\", tagger=\"RRNIP\")\n)\nplot.add(\n    IntegratedEfficiency(rnnip[\"sig_disc\"], rnnip[\"bkg_disc_c\"], flavour=\"cjets\", tagger=\"RRNIP\")\n)\nplot.add(\n    IntegratedEfficiency(rnnip[\"sig_disc\"], rnnip[\"bkg_disc_l\"], flavour=\"ujets\", tagger=\"RRNIP\")\n)\nplot.add(IntegratedEfficiency(dips[\"sig_disc\"], dips[\"bkg_disc_b\"], flavour=\"bjets\", tagger=\"DIPS\"))\nplot.add(IntegratedEfficiency(dips[\"sig_disc\"], dips[\"bkg_disc_c\"], flavour=\"cjets\", tagger=\"DIPS\"))\nplot.add(IntegratedEfficiency(dips[\"sig_disc\"], dips[\"bkg_disc_l\"], flavour=\"ujets\", tagger=\"DIPS\"))\n\nplot.draw()\nplot.savefig(\"integrated_efficiency.png\", transparent=False)\n</code></pre>"},{"location":"examples/line_plots/","title":"Line plots","text":"<p>This is an example on how you can create basic line plots with <code>puma</code>. Of course, this can be easily done with matplotlib directly, but by using <code>puma</code> you get the ATLAS tag and all the functionality <code>puma.PlotObject</code> supports.</p> <p></p> <pre><code>\"\"\"Example for a basic line plot with puma.\"\"\"\n\nfrom __future__ import annotations\n\nimport numpy as np\n\nfrom puma import Line2D, Line2DPlot\n\n# This is just some dummy data to make the plot look reasonable\nepochs = np.arange(0, 100)\ntraining_loss = np.exp(-epochs) + np.random.normal(0, 0.01, size=len(epochs)) + 0.8\nvalidation_loss = np.exp(-epochs) + np.random.normal(0, 0.03, size=len(epochs)) + 0.85\n\n# Initialise the plot\nline_plot = Line2DPlot(\n    xlabel=\"Epoch\",\n    ylabel=\"Loss\",\n    atlas_second_tag=\"This is an example of a basic line plot\",\n)\n\n# Add and draw the lines\nline_plot.add(Line2D(epochs, training_loss, label=\"Training loss\"))\nline_plot.add(Line2D(epochs, validation_loss, label=\"Validation loss\"))\nline_plot.draw()\nline_plot.savefig(\"line_plot_example.png\", transparent=False)\n</code></pre>"},{"location":"examples/matrix_plot/","title":"Matrix plot","text":"<p>The class <code>MatshowPlot</code> in <code>puma.matshow</code> is designed to plot matrixes based on <code>matplotlib</code>'s <code>matshow</code>. </p>"},{"location":"examples/matrix_plot/#basic-plot","title":"Basic plot","text":"<p>The class can plot a matrix stored in a <code>np.ndarray</code>:</p> <pre><code>matrix_plotter = MatshowPlot()\nmat = np.random.rand(4, 3)\nmatrix_plotter.draw(mat)\nmatrix_plotter.savefig(\"path/to/save_dir/vanilla_mat.png\")\n</code></pre>"},{"location":"examples/matrix_plot/#plot-customization","title":"Plot customization","text":"<p>Various aspects of the plot appearance can be customized using the class' arguments: - <code>x_ticklabels</code>: Names of the matrix's columns; - <code>x_ticks_rotation</code>: Rotation of the columns' names with respect to the horizontal direction; - <code>y_ticklabels</code>: Names of the matrix's rows; - <code>show_entries</code>: wether to show or not the matrix entries as text over the matrix's pixels (bins); - <code>show_percentage</code>: If <code>True</code>, the entries are formatted as percentages (i.e. numbers in [0,1] are multiplied by 100 and the percentage symbol is appended). - <code>text_color_threshold</code>: threshold on the relative luminance of the background color (i.e. the color of the matrix pixel) after which the overlapped text color switches to black, to allow better readability on lighter background colors. By default is set to 0.408, as per W3C standards; - <code>colormap</code>: <code>pyplot.cm</code> colormap for the plot; - <code>cbar_label</code>: Label of the colorbar;</p>"},{"location":"examples/matrix_plot/#example","title":"Example","text":"<p>Example without any customization:</p> <p></p> <p>Example with some customization:</p> <p></p>"},{"location":"examples/matrix_plot/#matrix-comparison","title":"Matrix Comparison","text":"<p>The <code>MatrixComparison</code> class allows to compare two matrices in a single plot. In the resulting plot, each cell is split into two triangles and each triangle shows the value and color corresponding to one of the matrices. Here is an example:</p> <p></p> <p>Code to obtain previous examples: <pre><code>\"\"\"Created customized matshow plot.\"\"\"\n\nfrom __future__ import annotations\n\nimport numpy as np\nfrom matplotlib import pyplot as plt\n\nfrom puma.matshow import MatrixComparison, MatshowPlot\n\n# seeded PRNG for reproducibility\nprng = np.random.default_rng(seed=0)\n\n# A random matrix\nmat = prng.random(size=(4, 3))\n\n# Declaring the plot class\nmatrix_plotter = MatshowPlot()\nmatrix_plotter.draw(mat)\n# Saving the plot\nmatrix_plotter.savefig(\"vanilla_mat.png\")\n\n# Some possible customizations\n# Matrix's column names\nx_ticks = [\"a\", \"b\", \"c\"]\n# Matrix's rows names\ny_ticks = [\"d\", \"e\", \"f\", \"g\"]\n\n# Declaring the plot class with custom style\nmatrix_plotter_custom = MatshowPlot(\n    x_ticklabels=x_ticks,\n    x_ticks_rotation=45,\n    y_ticklabels=y_ticks,\n    show_entries=True,\n    show_percentage=True,\n    text_color_threshold=0.6,\n    colormap=plt.cm.PiYG,\n    cbar_label=\"Scalar values as percentages\",\n    atlas_tag_outside=True,\n    fontsize=15,\n)\nmatrix_plotter_custom.draw(mat)\n# Saving the plot\nmatrix_plotter_custom.savefig(\"mat_custumized.png\")\n\n# Matrix comparison plot\nmat2 = prng.random(size=(4, 3))\nplot_matrix_comp = MatrixComparison(\n    x_ticklabels=x_ticks,\n    x_ticks_rotation=45,\n    y_ticklabels=y_ticks,\n    show_percentage=True,\n    text_color_threshold=0.6,\n    atlas_tag_outside=True,\n)\nplot_matrix_comp.draw(mat, mat2)\n# Saving the plot\nplot_matrix_comp.savefig(\"mat_comparison.png\")\n</code></pre></p>"},{"location":"examples/pie_charts/","title":"Pie charts","text":"<p>In the following a small example how to plot a pie chart with the <code>puma</code> API.</p> <p>Then we can start the actual plotting part:</p> <p></p> <p></p> <pre><code>\"\"\"Example plotting script for the puma.PiePlot class.\"\"\"\n\nfrom __future__ import annotations\n\nfrom ftag import Flavours\n\nfrom puma.pie import PiePlot\n\nHadrTruthLabel_fracs = [200_000, 34_000, 150_000, 5_000]\nHadrTruthLabel_labels = [\"Light-flavour jets\", \"$c$-jets\", \"$b$-jets\", \"$\\\\tau$-jets\"]\n\n# Basic example with default values only\nexample_plot_1 = PiePlot(\n    wedge_sizes=HadrTruthLabel_fracs,\n    labels=HadrTruthLabel_labels,\n    figsize=(5.5, 3.5),\n    draw_legend=False,\n)\nexample_plot_1.savefig(\"pie_example_1.png\")\n\n\n# Another example with some styling\n\n# Get the flavour colours from the global config\ncolours = [\n    Flavours[\"ujets\"].colour,\n    Flavours[\"cjets\"].colour,\n    Flavours[\"bjets\"].colour,\n    Flavours[\"taujets\"].colour,\n]\n\nexample_plot_2 = PiePlot(\n    wedge_sizes=HadrTruthLabel_fracs,\n    labels=HadrTruthLabel_labels,\n    draw_legend=False,\n    colours=colours,\n    # have a look at the possible kwargs for matplotlib.pyplot.pie here:\n    # https://matplotlib.org/stable/api/_as_gen/matplotlib.pyplot.pie.html\n    mpl_pie_kwargs={\n        \"explode\": [0, 0.2, 0, 0.1],\n        \"shadow\": False,\n        \"startangle\": 90,\n        \"textprops\": {\"fontsize\": 10},\n        \"radius\": 1,\n        \"wedgeprops\": {\"width\": 0.4, \"edgecolor\": \"w\"},\n        \"pctdistance\": 0.4,\n    },\n    # kwargs passed to puma.PlotObject\n    atlas_second_tag=\"Dummy flavour fractions\",\n    figsize=(5.5, 3.5),\n    y_scale=1.3,\n)\nexample_plot_2.savefig(\"pie_example_2.png\")\n</code></pre>"},{"location":"examples/precision_recall/","title":"Precision and Recall","text":"<p>The function <code>precision_recall_scores_per_class</code> in <code>puma.utils.precision_recall_scores</code> computes the per-class precision and recall classification metrics, for a multiclass classification task with N_c classes. The metrics are computed by comparing the classifier's predicted labels array with the target labels array. The function returns two arrays where the entry i is the precision or recall score respectively, related to class i. The scores are defined as follows.</p>"},{"location":"examples/precision_recall/#precision","title":"Precision","text":"<p>Fixed a class i between the N_c possible classes, the precision score (also called purity) for that class measures the ability of the classifier not to label as class i a sample belonging to another class. It is defined as:</p> p = \\frac{tp}{tp+fp} <p>where tp is the true positives count and fp is the false positives count in the test set.</p>"},{"location":"examples/precision_recall/#recall","title":"Recall","text":"<p>Fixed a class i between the N_c possible classes, the recall score for that class measures the ability of the classifier to detect every sample belonging to class i in the set. It is defined as:</p> r = \\frac{tp}{tp+fn} <p>where tp is the true positives count and fn is the false negatives count in the test set.</p>"},{"location":"examples/precision_recall/#example","title":"Example","text":"<pre><code>\"\"\"Calculate and print the precision recall.\"\"\"\n\nfrom __future__ import annotations\n\nimport numpy as np\n\nfrom puma.utils.precision_recall_scores import precision_recall_scores_per_class\n\n# Sample size\nN = 100\n\n# Number of target classes\nNclass = 3\n\n# Dummy target labels\ntargets = np.random.randint(0, Nclass, size=N)\n# Making sure that there is at least one sample for each class\ntargets = np.append(targets, np.array(list(range(Nclass))))\n\n# Dummy predicted labels\npredictions = np.random.randint(0, Nclass, size=(N + Nclass))\n\n\n# Unweighted precision and recall\nuw_precision, uw_recall = precision_recall_scores_per_class(targets, predictions)\nprint(\"Unweighted case:\")\nprint(\"Per-class precision:\")\nprint(uw_precision)\nprint(\"Per-class recall:\")\nprint(uw_recall)\nprint(\" \")\n\n# Weighted precision and recall\n# Dummy sample weights\nsample_weights = np.random.rand(N + Nclass)\n\nw_precision, w_recall = precision_recall_scores_per_class(targets, predictions, sample_weights)\nprint(\"Weighted case:\")\nprint(\"Per-class precision:\")\nprint(w_precision)\nprint(\"Per-class recall:\")\nprint(w_recall)\nprint(\" \")\n</code></pre>"},{"location":"examples/rocs/","title":"ROC curves","text":"<p>In the following a small example how to plot a roc curve with the <code>puma</code> API.</p> <p>Then we can start the actual plotting part:</p> <p></p> <pre><code>\"\"\"Produce roc curves from tagger output and labels.\"\"\"\n\nfrom __future__ import annotations\n\nimport numpy as np\nfrom ftag import Flavours\nfrom ftag.utils import calculate_rejection, get_discriminant\n\nfrom puma import Roc, RocPlot\nfrom puma.utils import get_dummy_2_taggers, logger\n\n# The line below generates dummy data which is similar to a NN output\ndf = get_dummy_2_taggers(add_pt=True)\n\nlogger.info(\"caclulate tagger discriminants\")\ndiscs_dips = get_discriminant(\n    jets=df,\n    tagger=\"dips\",\n    signal=Flavours[\"bjets\"],\n    flavours=Flavours.by_category(\"single-btag\"),\n    fraction_values={\n        \"fc\": 0.018,\n        \"fu\": 0.982,\n        \"ftau\": 0,\n    },\n)\ndiscs_rnnip = get_discriminant(\n    jets=df,\n    tagger=\"rnnip\",\n    signal=Flavours[\"bjets\"],\n    flavours=Flavours.by_category(\"single-btag\"),\n    fraction_values={\n        \"fc\": 0.018,\n        \"fu\": 0.982,\n        \"ftau\": 0,\n    },\n)\n\n# defining target efficiency\nsig_eff = np.linspace(0.49, 1, 20)\n\n# defining boolean arrays to select the different flavour classes\nis_light = df[\"HadronConeExclTruthLabelID\"] == 0\nis_c = df[\"HadronConeExclTruthLabelID\"] == 4\nis_b = df[\"HadronConeExclTruthLabelID\"] == 5\n\nn_jets_light = sum(is_light)\nn_jets_c = sum(is_c)\n\nlogger.info(\"Calculate rejection\")\nrnnip_ujets_rej = calculate_rejection(discs_rnnip[is_b], discs_rnnip[is_light], sig_eff)\nrnnip_cjets_rej = calculate_rejection(discs_rnnip[is_b], discs_rnnip[is_c], sig_eff)\ndips_ujets_rej = calculate_rejection(discs_dips[is_b], discs_dips[is_light], sig_eff)\ndips_cjets_rej = calculate_rejection(discs_dips[is_b], discs_dips[is_c], sig_eff)\n\n# Define now the actual ROC curve objects\nrnnip_ujets_roc = Roc(\n    sig_eff=sig_eff,\n    bkg_rej=rnnip_ujets_rej,\n    n_test=n_jets_light,\n    rej_class=Flavours[\"ujets\"],\n    signal_class=\"bjets\",\n    label=\"RNNIP\",\n)\ndips_ujets_roc = Roc(\n    sig_eff=sig_eff,\n    bkg_rej=dips_ujets_rej,\n    n_test=n_jets_light,\n    rej_class=Flavours[\"ujets\"],\n    signal_class=\"bjets\",\n    label=\"DIPS r22\",\n)\nrnnip_cjets_roc = Roc(\n    sig_eff=sig_eff,\n    bkg_rej=rnnip_cjets_rej,\n    n_test=n_jets_c,\n    rej_class=Flavours[\"cjets\"],\n    signal_class=\"bjets\",\n    label=\"RNNIP\",\n)\ndips_cjets_roc = Roc(\n    sig_eff=sig_eff,\n    bkg_rej=dips_cjets_rej,\n    n_test=n_jets_c,\n    rej_class=Flavours[\"cjets\"],\n    signal_class=\"bjets\",\n    label=\"DIPS r22\",\n)\n\n# ROC curve objects can also be stored as yaml or json files\nrnnip_ujets_roc.save(\"rnnip_ujets_roc.yaml\")\ndips_ujets_roc.save(\"dips_ujets_roc.yaml\")\nrnnip_cjets_roc.save(\"rnnip_cjets_roc.yaml\")\ndips_cjets_roc.save(\"dips_cjets_roc.yaml\")\n\n# here the plotting of the roc starts\nlogger.info(\"Plotting ROC curves.\")\nplot_roc = RocPlot(\n    n_ratio_panels=2,\n    ylabel=\"Background rejection\",\n    xlabel=\"$b$-jet efficiency\",\n    atlas_second_tag=\"$\\\\sqrt{s}=13$ TeV, dummy jets \\ndummy sample, $f_{c}=0.018$\",\n    figsize=(6.5, 6),\n    y_scale=1.4,\n)\n\n# Add the ROC curve objects to the plot\nplot_roc.add_roc(roc_curve=rnnip_ujets_roc, reference=True)\nplot_roc.add_roc(roc_curve=dips_ujets_roc)\nplot_roc.add_roc(roc_curve=rnnip_cjets_roc, reference=True)\nplot_roc.add_roc(roc_curve=dips_cjets_roc)\n\n# setting which flavour rejection ratio is drawn in which ratio panel\nplot_roc.set_ratio_class(1, Flavours[\"ujets\"])\n\n# If you don't have a Label instance for your flavour, you can also\n# use as string but you need to give the label by hand\nplot_roc.set_ratio_class(2, rej_class=\"cjets\", rej_class_label=\"$c$-jets\")\n\nplot_roc.draw()\nplot_roc.savefig(\"roc.png\", transparent=False)\n\n# If you want to load now the ROC curves from file, you can do so\nloaded_rnnip_ujets_roc = Roc.load(\"rnnip_ujets_roc.yaml\")\nloaded_dips_ujets_roc = Roc.load(\"dips_ujets_roc.yaml\")\nloaded_rnnip_cjets_roc = Roc.load(\"rnnip_cjets_roc.yaml\", colour=\"red\")\nloaded_dips_cjets_roc = Roc.load(\"dips_cjets_roc.yaml\", colour=\"red\")\n\n\n# Now init a new plot\nloaded_plot_roc = RocPlot(\n    n_ratio_panels=2,\n    ylabel=\"Background rejection\",\n    xlabel=\"$b$-jet efficiency\",\n    atlas_second_tag=\"$\\\\sqrt{s}=13$ TeV, Loaded ROC Curves\",\n    figsize=(6.5, 6),\n    y_scale=1.4,\n)\n\nloaded_plot_roc.add_roc(roc_curve=rnnip_ujets_roc, reference=True)\nloaded_plot_roc.add_roc(roc_curve=dips_ujets_roc)\nloaded_plot_roc.add_roc(roc_curve=rnnip_cjets_roc, reference=True)\nloaded_plot_roc.add_roc(roc_curve=dips_cjets_roc)\n\n# setting which flavour rejection ratio is drawn in which ratio panel\nloaded_plot_roc.set_ratio_class(1, Flavours[\"ujets\"])\nloaded_plot_roc.set_ratio_class(2, Flavours[\"cjets\"])\n\nloaded_plot_roc.draw()\nloaded_plot_roc.savefig(\"roc_loaded.png\", transparent=False)\n</code></pre>"},{"location":"examples/tutorial-plotting/","title":"Puma Plotting Tutorial","text":""},{"location":"examples/tutorial-plotting/#introduction","title":"Introduction","text":"<p>In this tutorial you will learn how to use <code>puma</code>, the Plotting UMami Api. The idea behind <code>puma</code> is to provide a plotting API that is easy to use but at the same time highly configurable. This means that the user has full control over the plot while things like uncertainties, labels, ratio panels can be added easily.</p> <p>You can find the <code>puma</code> documentation here.</p> <p><code>puma</code> is based on <code>matplotlib</code> and helps you to produce most of the types of plots that are  commonly used in flavour tagging like the ones shown below:</p> ROC curves Histogram plots Variable vs efficiency <p>In this tutorial you will learn how to:</p> <ol> <li>A small introduction to the different metrics used in flavour tagging.</li> <li>Plot histograms with <code>puma</code>, where you will produce plots of both jet- and track-variables.</li> <li>Plot ROC curves of two taggers, with ratio panels that compare the curves.</li> <li>Plot the efficiency/rejection of a tagger as a function of p_\\text{T}.</li> <li>Plot the input variables of the files using Umami.</li> </ol> <p>The tutorial is meant to be followed in a self-guided manner. You will be prompted to do certain tasks by telling you what the desired outcome will be, without telling you how to do it. Using the documentation of <code>puma</code>, you can find out how to achieve your goal. In case you are stuck, you can click on the \"hint\" toggle box to get a hint. If you tried for more than 10 min at a problem, feel free to toggle also the solution with a worked example.</p>"},{"location":"examples/tutorial-plotting/#setting-up-everything-you-need","title":"Setting Up Everything You Need","text":"<p>For the tutorial, you will need <code>puma</code>. Probably the easiest way to get <code>puma</code> is via <code>PYPI</code>. You can install it like any other python package using the following command:</p> <pre><code>pip install puma-hep\n</code></pre> <p>You can also use so-called containers for the tutorial or in general for <code>puma</code>. This is the recommended way to run <code>puma</code> if you have different python versions and dependencies running on your system. You can read more about this in the FTAG Docs.</p> <p>For this tutorial, two <code>.h5</code> files were prepared, one t\\bar{t} and one Z' file. You can download them from the <code>eos</code> directly. The path to the directory where the files are stored is <code>/eos/user/u/umamibot/tutorials/</code>. If you don't have access to <code>eos</code>, you can simply download the files via the following two command:</p> <pre><code>wget https://umami-ci-provider.web.cern.ch/puma/ttbar.h5\nwget https://umami-ci-provider.web.cern.ch/puma/zpext.h5\n</code></pre>"},{"location":"examples/tutorial-plotting/#tutorial-tasks","title":"Tutorial Tasks","text":"<p>The tasks are divided in several sub-tasks. You don't have to do all of them in case you are more interested in the other tasks. However, the sub-tasks depend on each other, so you should finish a subtask before proceeding to the next one (also the solutions assume that you already have the previous subtasks completed).</p>"},{"location":"examples/tutorial-plotting/#task-0-flavour-tagging-metrics","title":"Task 0: Flavour Tagging Metrics","text":"<p>To get started with the plotting, we will first have a quick look into different metrics used in flavour tagging to evaluate the performance.</p>"},{"location":"examples/tutorial-plotting/#task-01-generating-dummy-data","title":"Task 0.1: Generating Dummy Data","text":"<p>The typical output of our ML-based taggers, like DIPS or DL1d, are 3 scores indicating the probabilities of being a light-flavour jet, a c-jet and a b-jet. For example the scores <code>[0.1, 0.3, 0.6]</code> would indicate that we have most probably a b-jet while <code>[0.7, 0.2, 0.1]</code> would indicate a light-flavour jet.</p> <p>Even though we always have MC simulation, it is sometimes useful to have dummy data, for instance if we want to test certain plotting features etc. (and to understand the actual underlying distributions).</p> <p>Now, it is up to you. Generate a dummy multi-class output of a neural network.</p> Hint: Where can I find such a function? <p>You can have a look at the puma documentation and search in the API reference.</p> Hint: Which exact function? <p>The <code>puma.utils</code> module contains the desired functions</p> Solution <p>Dummy data are explained here</p> <pre><code>from puma.utils import get_dummy_multiclass_scores\n\n# Generating 10_000 jets\ndummy_jets, dummy_labels = get_dummy_multiclass_scores()\nprint(dummy_jets)\nprint(dummy_labels)\n</code></pre>"},{"location":"examples/tutorial-plotting/#task-02-defining-working-points-likelihood-ratio","title":"Task 0.2: Defining Working Points - Likelihood Ratio","text":"<p>Since we are not (yet) able to calibrate the entire spectrum of the different multi-class outputs, we need to define so-called working points (or operating points). In the case of ATLAS, we have four/five different b-tagging working points (WPs) which are defined covering various needs of the physics analyses. The efficiency of a specific flavour j (b, c or light) is defined as</p>  \\varepsilon^j = \\frac{N_\\text{pass}^j(\\mathcal{D}&gt;T_f)}{N_\\text{total}^j},  <p>where N_\\text{pass}^j(\\mathcal{D}&gt;T_f) are the number of jets of flavour j passing the cut T_f on the tagger discriminant \\mathcal{D} and N_\\text{total}^j are all jets of flavour j before the cut.</p> <p>The final output score is calculated from the multi-class output and results for the b-tagging discriminant into the log-likelihood</p>  \\mathcal{D}_\\text{b}(f_c) = \\log \\left(  \\frac{p_b}{f_c\\cdot p_c+(1-f_c)\\cdot p_u} \\right),  <p>with p_b, p_c and p_u being the probabilities for the jet to be a b-jet, c-jet or light-flavour jet (often refered to as u-jets), respectively. The c-jet fraction value f_c allows to tune how much emphasis is given to the c-jet or to the light-flavour performance. While the c-jet rejection increases as a function of f_c, the light-flavour jet rejection decreases. This parameter has to be tuned separately for each tagger and depends on the needs of the physics analyses.</p> <p>The advantage of the multi-class output is that this tuning is possible after the training and the c-jet fraction value in the training sample does not have to be adapted. Another advantage of the multi-class output is that one can by changing the log-likelihood to</p>  \\mathcal{D}_\\text{c}(f_b) = \\log \\left(  \\frac{p_c}{f_b\\cdot p_b+(1-f_b)\\cdot p_u} \\right),  <p>perform c-tagging without the need of retraining the tagger. Here f_b is now the b-jet fraction value.</p> <p>Define a function which calculates the log-likelihood, when giving it the 3 scores and the f_c value as input.</p> Hint 1 <p>You can either use a python function <code>def</code> or a <code>lambda</code> function</p> Hint 2 <p>You can find the solution in the atlas-ftag-tools package.</p> Solution <p>This implementation here is hardcoded to explain how it works. In general, it is recommended to use the <code>get_discriminant</code> function from the  atlas-ftag-tools package</p> <pre><code>import numpy as np\ndef disc_fct(arr: np.ndarray, f_c: float = 0.018) -&gt; np.ndarray:\n    \"\"\"Tagger discriminant\n\n    Parameters\n    ----------\n    arr : numpy.ndarray\n        array with with shape (, 3)\n    f_c : float, optional\n        f_c value in the discriminant (weight for $c$-jets rejection)\n\n    Returns\n    -------\n    np.ndarray\n        Array with the discriminant values inside.\n    \"\"\"\n    # you can adapt this for your needs\n    return np.log(arr[2] / (f_c * arr[1] + (1 - f_c) * arr[0]))\n\n\n# you can also use a lambda function\n# fc = 0.018\n# lambda a: np.log(a[2] / (fc * a[1] + (1 - fc) * a[0]))\n</code></pre> <p>Using the <code>dummy data</code> from task 0.1, calculate the log-likelihood with f_c=0.018 and retrieve the working point cut value for 70% b-jet efficiency.</p> Hint: Where to get the Labels from? <p>The <code>labels</code> from task 0.1 have the same values as the <code>HadronConeExclTruthLabelID</code> described in the FTAG algo docs.</p> Hint: Which Function to Use? <p>You can have a look at the <code>percentile</code> function from <code>numpy</code>. Be aware from which site we need to integrate! And the <code>apply_along_axis</code> function to evaluate an entire array.</p> Solution <pre><code>import numpy as np\n\nbjets = dummy_labels == 5\ndummy_jets_2d = np.column_stack((dummy_jets['ujets'], dummy_jets['cjets'], dummy_jets['bjets']))\nscores = np.apply_along_axis(disc_fct, axis=1, arr=dummy_jets_2d)\ntarget_eff = 0.7\ncutvalue = np.percentile(scores[bjets], 100.0 * (1.0 - target_eff))\nprint(\"cut value for 70% $b$-jet efficiency:\", cutvalue)\n</code></pre> <p>The current way to implement this is using the atlas-ftag-tools metrics functions</p>"},{"location":"examples/tutorial-plotting/#task-03-performance-metrics-efficiency-and-rejection","title":"Task 0.3: Performance Metrics - Efficiency and Rejection","text":"<p>To quantify the performance of a tagger at a given working point, the background rejection is a good measure. The rejection is simply the inverse of the efficiency \\frac{1}{\\varepsilon^j}.</p> <p>Calculate the light-flavour jet and c-jet rejection for the 70% working point from task 0.2.</p> Solution <pre><code>ljets = dummy_labels == 0\ncjets = dummy_labels == 4\n\nljets_eff = ((scores &gt; cutvalue) &amp; ljets).sum() / ljets.sum()\nprint(\"light-flavour jets efficiency:\", ljets_eff)\nprint(\"light-flavour jets rejection:\", 1 / ljets_eff)\n\ncjets_eff = ((scores &gt; cutvalue) &amp; cjets).sum() / cjets.sum()\nprint(\"$c$-flavour jets efficiency:\", cjets_eff)\nprint(\"$c$-flavour jets rejection:\", 1 / cjets_eff)\n</code></pre> <p>Alternatively, all this functionality is also provided by the <code>atlas-ftag-tools</code> package. In that case this would simplify to <pre><code>from ftag.utils import calculate_rejection\nljets = dummy_labels == 0\ncjets = dummy_labels == 4\nrej = calculate_rejection(scores[bjets], scores[ljets], target_eff=0.7)\nprint(\"light-flavour jets rejection:\", rej)\n</code></pre></p> <p>Starting from these metrics, we can plot for instance:</p> <ul> <li>ROC curves: which show the background rejection as function of the b-jet efficency</li> <li>Efficiency vs p_\\text{T}: where one fixes a working point and calculates the background rejection in bins of p_\\text{T}</li> </ul>"},{"location":"examples/tutorial-plotting/#task-1-histogram-plots","title":"Task 1: Histogram Plots","text":""},{"location":"examples/tutorial-plotting/#task-11-loading-the-h5-file","title":"Task 1.1: Loading the h5 File","text":"<p>Before starting with the different plotting exercises, you have to load the h5 file that was prepared for this tutorial. The expected outcome of this is that you have access to the jet variables as well as to the track variables. You can put the jet variables in a <code>pandas.DataFrame</code> in case you feel more comfortable with that, but this will not be possible for the tracks, since the <code>tracks_loose</code> dataset in the h5 file has an extra dimension for the tracks (for each jet we store the information of up to 40 tracks).</p> <ol> <li>Write a little python script that loads the jet and track variables.</li> <li>Have a look at how large the dataset is, and what shape the loaded arrays have.</li> </ol> <p>For the following tasks you can re-use the code that loads the h5 file or just extend your python script from this task.</p> Hint: How can I Load a h5 File with Python? <p>You can find the documentation of <code>h5py</code> here.</p> Solution <pre><code>import h5py\n\n# Use directly the eos path or use the path to your downloaded files\nttbar_filepath = \"/eos/user/u/umamibot/tutorials/ttbar.h5\"\n\n# load the \"jets\" and \"tracks_loose\" dataset from the h5 file\nwith h5py.File(ttbar_filepath, \"r\") as h5file:\n    jets = h5file[\"jets\"][:]\n    tracks = h5file[\"tracks_loose\"][:]\n\n# print the shape and the field names of the datasets\nprint(jets.shape)\nprint(jets.dtype.names)\nprint(tracks.shape)\nprint(tracks.dtype.names)\n</code></pre>"},{"location":"examples/tutorial-plotting/#task-12-plotting-the-p_texttp_textt-distribution-for-jets-of-different-flavours","title":"Task 1.2: Plotting the p_\\text{T} Distribution for Jets of Different Flavours","text":"<p>As a next step, you will produce a histogram plot that shows the p_\\text{T} distribution of light-flavour jets, b-jets and b-jets.</p> Hint: How do I Create a Histogram Plot with <code>puma</code>? <p>You can find the examples of histogram plots here and the documentation for histogram plots with <code>puma</code> here.</p> Solution <pre><code>import h5py\nimport numpy as np\nfrom puma import Histogram, HistogramPlot\n\n# Use directly the eos path or use the path to your downloaded files\nttbar_filepath = \"/eos/user/u/umamibot/tutorials/ttbar.h5\"\n\n# load the jets dataset from the h5 file\nwith h5py.File(ttbar_filepath, \"r\") as h5file:\n    jets = h5file[\"jets\"][:]\n\n# defining boolean arrays to select the different flavour classes\nis_light = jets[\"HadronConeExclTruthLabelID\"] == 0\nis_c = jets[\"HadronConeExclTruthLabelID\"] == 4\nis_b = jets[\"HadronConeExclTruthLabelID\"] == 5\n\n# initialise the plot\npt_plot = HistogramPlot(\n    xlabel=r\"$p_\\text{T}$ [GeV]\",\n    ylabel=\"Normalised number of jets\",\n)\n\n# add the histograms (Note that the Histogram objects need to have the same bins!)\npt_plot.add(Histogram(jets[is_light][\"pt_btagJes\"] / 1000, flavour=\"ujets\", bins=np.linspace(0, 250, 50)))\npt_plot.add(Histogram(jets[is_c][\"pt_btagJes\"] / 1000, flavour=\"cjets\", bins=np.linspace(0, 250, 50)))\npt_plot.add(Histogram(jets[is_b][\"pt_btagJes\"] / 1000, flavour=\"bjets\", bins=np.linspace(0, 250, 50)))\n\npt_plot.draw()\npt_plot.savefig(\"tutorial_histogram_pT.png\")\n</code></pre>"},{"location":"examples/tutorial-plotting/#task-13-plot-the-bb-jets-probability-output-of-two-different-taggers","title":"Task 1.3: Plot the b-jets Probability Output of two Different Taggers","text":"<p>In this task you will plot the b-jets probability of two different taggers - RNNIP and DIPS.</p> <ol> <li>Create the histogram plot (similar to the one from the previous task) and the different     histograms. If you plot this for light-flavour jets, c-jets and b-jets, you should have 6     histograms.</li> <li>Make sure that you use a different linestyle for the histgrams of you second tagger.</li> <li>Add a ratio panel to the plot</li> <li>Make your plot look pretty. Have a look at the arguments that are supported by     <code>puma.PlotObject</code>.</li> </ol> Hint 1: Histogram and HistogramPlot Objects <p>After you defined your HistogramPlot object, you can start adding lines to it. This lines are the Histogram objects you need to define.</p> Hint 2: Linestyle <p>The <code>linestyle</code> can be set when the different <code>Histogram</code> lines are initalised.</p> Hint 3: Ratio Panel <p>The ratio for the ratio panel is calculated in this case between the same flavours. But you need to tell the plot which of the Histogram objects is the reference. Try to look up the <code>reference</code> option in the <code>add()</code> function.</p> Solution <pre><code>tagger_output_plot = HistogramPlot(\n    n_ratio_panels=1,\n    xlabel=\"$b$-jets probability\",\n    ylabel=\"Normalised number of jets\",\n    # optional:\n    # figsize=(6, 4.5),\n    # leg_ncol=2,\n    # atlas_second_tag=\"$t\\\\bar{t}$ R22 sample\",\n    # logy=True,\n)\n\n# add the histograms\ntagger_output_plot.add(\n    Histogram(\n        jets[is_light][\"rnnip_pb\"],\n        ratio_group=\"ujets\",\n        flavour=\"ujets\",\n        bins=np.linspace(0, 1, 50),\n    ),\n    reference=True,\n)\ntagger_output_plot.add(\n    Histogram(\n        jets[is_c][\"rnnip_pb\"],\n        ratio_group=\"cjets\",\n        flavour=\"cjets\",\n        bins=np.linspace(0, 1, 50),\n    ),\n    reference=True,\n)\ntagger_output_plot.add(\n    Histogram(\n        jets[is_b][\"rnnip_pb\"],\n        ratio_group=\"bjets\",\n        flavour=\"bjets\",\n        bins=np.linspace(0, 1, 50),\n    ),\n    reference=True,\n)\n\n# add the histograms\ntagger_output_plot.add(\n    Histogram(\n        jets[is_light][\"dipsLoose20220314v2_pb\"],\n        ratio_group=\"ujets\",\n        flavour=\"ujets\",\n        bins=np.linspace(0, 1, 50),\n        linestyle=\"--\"\n    )\n)\ntagger_output_plot.add(\n    Histogram(\n        jets[is_c][\"dipsLoose20220314v2_pb\"],\n        ratio_group=\"cjets\",\n        flavour=\"cjets\",\n        bins=np.linspace(0, 1, 50),\n        linestyle=\"--\"\n    )\n)\ntagger_output_plot.add(\n    Histogram(\n        jets[is_b][\"dipsLoose20220314v2_pb\"],\n        ratio_group=\"bjets\",\n        flavour=\"bjets\",\n        bins=np.linspace(0, 1, 50),\n        linestyle=\"--\"\n    )\n)\n\ntagger_output_plot.draw()\ntagger_output_plot.savefig(\"tutorial_histogram_tagger_pb_comparison.png\")\n</code></pre>"},{"location":"examples/tutorial-plotting/#task-14-plot-a-track-variable-of-your-choice","title":"Task 1.4: Plot a Track Variable of Your Choice","text":"<p>In this task you are asked to make a histogram plot of a track variable. This is slightly more tricky, since the array that you load from the h5 file has a different shape compared to the array storing the jet information. In addition to that, many entries might be filled with <code>nan</code> values, which is challenging here and there.</p> <ol> <li>Choose a track variable that you want to plot.</li> <li>Create a histogram plot (maybe again for multiple flavours, but that is up to you).</li> </ol> Hint 1: NaN-Values in Binning <p>If you encounter an issue with NaN values in the binning, you need to set the <code>bins_range</code> correctly, because with NaN values it cannot be calculated automatically.</p> Hint 2: Difference in Shape <p>Due to the dimensionality of tracks, you need to get rid of one of the dimensions. Try the <code>.flatten()</code> option of <code>numpy.ndarray</code>'s</p> Solution <pre><code>with h5py.File(ttbar_filepath, \"r\") as h5file:\n    tracks = h5file[\"/tracks_loose\"][:, :]\n    print(tracks.shape)\n\nd0_plot = HistogramPlot(\n    xlabel=\"$d_0$ significance\",\n    ylabel=\"Normalised number of tracks\",\n    figsize=(6, 4.5),\n)\n\nd0_plot.add(\n    Histogram(\n        tracks[\"IP3D_signed_d0_significance\"][is_light, :].flatten(),\n        flavour=\"ujets\",\n        bins=np.linspace(-3, 3, 50),\n    )\n)\nd0_plot.add(\n    Histogram(\n        tracks[\"IP3D_signed_d0_significance\"][is_c, :].flatten(),\n        flavour=\"cjets\",\n        bins=np.linspace(-3, 3, 50),\n    )\n)\nd0_plot.add(\n    Histogram(\n        tracks[\"IP3D_signed_d0_significance\"][is_b, :].flatten(),\n        flavour=\"bjets\",\n        bins=np.linspace(-3, 3, 50),\n    )\n)\n\nd0_plot.draw()\nd0_plot.savefig(\"tutorial_histogram_track_variable.png\")\n</code></pre>"},{"location":"examples/tutorial-plotting/#task-2-roc-plots","title":"Task 2: ROC Plots","text":"<p>In this task, you will plot a ROC comparison for the two taggers RNNIP and DIPS.</p>"},{"location":"examples/tutorial-plotting/#task-21-calculate-the-rejections-as-a-function-of-the-bb-jets-efficiency","title":"Task 2.1: Calculate the Rejections as a Function of the b-jets Efficiency","text":"<p>Before you can actually plot the ROC curves, you have to calculate the light-flavour and c-jets rejection for a range of b-jets efficiencies.</p> <ol> <li>Define a function that calculates the b-jets discriminant from the tagger output.</li> <li>Calculate the light-flavour jets rejection as a function of the b-jets efficiency.</li> </ol> Hint: Look at Examples <p>Multiple examples (also for ROCs) are provided in the <code>puma</code> examples.</p> Solution <pre><code>import numpy as np\nimport pandas as pd\nimport h5py\n\nfrom puma import Roc, RocPlot\nfrom ftag.utils import calculate_rejection, get_discriminant\nfrom ftag import Flavours\nfrom ftag.hdf5 import H5Reader\n\nttbar_filepath = \"/eos/user/u/umamibot/tutorials/ttbar.h5\"\n\n# load the jets dataset from the h5 file\nreader = H5Reader(ttbar_filepath, batch_size=100)\ndata = reader.load()\njets = data[\"jets\"]\n\n# Calculate the discriminant for both taggers\ndiscs_dips = get_discriminant(\n    jets=jets,\n    tagger=\"dipsLoose20220314v2\",\n    signal=Flavours[\"bjets\"],\n    flavours=Flavours.by_category(\"single-btag\"),\n    fraction_values={\n        \"fc\": 0.018,\n        \"fu\": 0.982,\n        \"ftau\": 0,\n    },\n)\ndiscs_rnnip = get_discriminant(\n    jets=jets,\n    tagger=\"rnnip\",\n    signal=Flavours[\"bjets\"],\n    flavours=Flavours.by_category(\"single-btag\"),\n    fraction_values={\n        \"fc\": 0.018,\n        \"fu\": 0.982,\n        \"ftau\": 0,\n    },\n)\n\n# defining target efficiency\nsig_eff = np.linspace(0.49, 1, 20)\n\n# defining boolean arrays to select the different flavour classes\nis_light = jets[\"HadronConeExclTruthLabelID\"] == 0\nis_c = jets[\"HadronConeExclTruthLabelID\"] == 4\nis_b = jets[\"HadronConeExclTruthLabelID\"] == 5\n\nn_jets_light = sum(is_light)\nn_jets_c = sum(is_c)\n\nrnnip_ujets_rej = calculate_rejection(discs_rnnip[is_b], discs_rnnip[is_light], sig_eff)\ndips_ujets_rej = calculate_rejection(discs_dips[is_b], discs_dips[is_light], sig_eff)\n</code></pre>"},{"location":"examples/tutorial-plotting/#task-22-plot-the-rejections-as-a-function-of-the-bb-jets-efficiency","title":"Task 2.2: Plot the Rejections as a Function of the b-jets Efficiency","text":"<ol> <li>Plot the light-flavour jets rejection as a function of the b-jets efficiency. Use     <code>n_ratio_panels=1</code> to also get the ratio of the two rejection curves.</li> </ol> Hint 1: How do I Initialise a ROC Curve Plot? <p>Plotting ROC curves with <code>puma</code> is similar to plotting histograms. The main difference is that you are using the <code>puma.RocPlot</code> and <code>puma.Roc</code> classes. Search the [puma docs] for \"roc\" to have a look at an example and the API reference.</p> Hint 2: I Initialised the Plot and Added the ROC Curves - Is there anything else to do? <p>For ROC curves you also have to define the class which is drawn in the ratio panel. The method you need to use here is <code>RocPlot.set_ratio_class()</code>.</p> Solution <p>Add this part under the calculation of the rejection values.</p> <pre><code># Define the ROC class instances\nrnnip_ujets_roc = Roc(\n    sig_eff=sig_eff,\n    bkg_rej=rnnip_ujets_rej,\n    n_test=n_jets_light,\n    rej_class=\"ujets\",\n    signal_class=\"bjets\",\n    label=\"RNNIP\",\n)\ndips_ujets_roc = Roc(\n    sig_eff=sig_eff,\n    bkg_rej=dips_ujets_rej,\n    n_test=n_jets_light,\n    rej_class=\"ujets\",\n    signal_class=\"bjets\",\n    label=\"DIPS r22\",\n)\n\n# Set up a plot\nplot_roc = RocPlot(\n    n_ratio_panels=1,\n    ylabel=\"Background rejection\",\n    xlabel=\"$b$-jet efficiency\",\n    atlas_second_tag=\"$\\\\sqrt{s}=13$ TeV, dummy jets \\ndummy sample, $f_{c}=0.018$\",\n    figsize=(6.5, 6),\n    y_scale=1.4,\n)\n\n# Add the ROC objects to the plot\nplot_roc.add_roc(roc_curve=rnnip_ujets_roc, reference=True)\nplot_roc.add_roc(roc_curve=dips_ujets_roc)\n\n# Set the ratio class for the ratio panels\nplot_roc.set_ratio_class(1, \"ujets\")\n\n# Draw and save the plot\nplot_roc.draw()\nplot_roc.savefig(\"tutorial_roc.png\", transparent=False)\n</code></pre>"},{"location":"examples/tutorial-plotting/#task-23-add-the-cc-rejection-to-your-plot","title":"Task 2.3: Add the c-rejection to Your Plot","text":"<ol> <li>Repeat the calculation of the rejection for c-jets</li> <li>Add the corresponding ROC curves to the plot. Don't forget to increase <code>n_ratio_panels</code>     of your <code>puma.RocPlot</code>.</li> </ol> Solution <pre><code># Add this to the calculation part of the script (place it below or above the other calculate_rejection)\nrnnip_cjets_rej = calculate_rejection(discs_rnnip[is_b], discs_rnnip[is_c], sig_eff)\ndips_cjets_rej = calculate_rejection(discs_dips[is_b], discs_dips[is_c], sig_eff)\n\n# Add this below the definition of the other ROC objects\nrnnip_cjets_roc = Roc(\n    sig_eff=sig_eff,\n    bkg_rej=rnnip_cjets_rej,\n    n_test=n_jets_c,\n    rej_class=\"cjets\",\n    signal_class=\"bjets\",\n    label=\"RNNIP\",\n)\ndips_cjets_roc = Roc(\n    sig_eff=sig_eff,\n    bkg_rej=dips_cjets_rej,\n    n_test=n_jets_c,\n    rej_class=\"cjets\",\n    signal_class=\"bjets\",\n    label=\"DIPS r22\",\n)\n\n# Set the n_ratio_panels in the RocPlot to 2!\n\n# Add this below the add_roc() from the other light jets\nplot_roc.add_roc(roc_curve=rnnip_cjets_roc, reference=True)\nplot_roc.add_roc(roc_curve=dips_cjets_roc)\n\n# Add this to the below the other set_ratio_class\nplot_roc.set_ratio_class(2, \"cjets\")\n</code></pre>"},{"location":"examples/tutorial-plotting/#task-3-p_texttp_textt-vs-efficiency","title":"Task 3: p_\\text{T} vs. Efficiency","text":"<p>In this task, you will plot both the b-jets efficiency and the light-flavour jets rejection for specific bins of p_\\text{T}.</p>"},{"location":"examples/tutorial-plotting/#task-31-calculate-the-discriminant-values","title":"Task 3.1: Calculate the discriminant values","text":"<p>Just like you did in Task 2.1, calculate the discriminant scores for RNNIP and DIPS. You can reuse the code from task 2.1. If you are putting everything in one python script you can just reuse the values that are already calculated.</p>"},{"location":"examples/tutorial-plotting/#task-32-create-a-p_texttp_textt-vs-bb-efficiency-plot","title":"Task 3.2: Create a p_\\text{T} vs. b-efficiency Plot","text":"<p>For a fixed inclusive b-efficiency, you plot the b-efficiency for different bins of p_\\text{T}.</p> Hint 1: I'm not sure which type of Plot I need <p>The plot type you are looking for is <code>VarVsEff</code> and <code>VarVsEffPlot</code>.</p> Solution <pre><code>import numpy as np\nimport pandas as pd\nimport h5py\n\nfrom puma import VarVsEff, VarVsEffPlot\nfrom ftag.utils import get_discriminant\nfrom ftag import Flavours\nfrom ftag.hdf5 import H5Reader\n\nttbar_filepath = \"/eos/user/u/umamibot/tutorials/ttbar.h5\"\n\n# load the jets dataset from the h5 file\nreader = H5Reader(ttbar_filepath, batch_size=100)\ndata = reader.load()\njets = data[\"jets\"]\n\n# Calculate the discriminant for both taggers\ndiscs_dips = get_discriminant(\n    jets=jets,\n    tagger=\"dipsLoose20220314v2\",\n    signal=Flavours[\"bjets\"],\n    flavours=Flavours.by_category(\"single-btag\"),\n    fraction_values={\n        \"fc\": 0.018,\n        \"fu\": 0.982,\n        \"ftau\": 0,\n    },\n)\ndiscs_rnnip = get_discriminant(\n    jets=jets,\n    tagger=\"rnnip\",\n    signal=Flavours[\"bjets\"],\n    flavours=Flavours.by_category(\"single-btag\"),\n    fraction_values={\n        \"fc\": 0.018,\n        \"fu\": 0.982,\n        \"ftau\": 0,\n    },\n)\n\n# Getting jet pt in GeV (in the files, they are stored in MeV)\npt = jets[\"pt\"] / 1e3\n\n# defining target efficiency\nsig_eff = np.linspace(0.49, 1, 20)\n\n# defining boolean arrays to select the different flavour classes\nis_light = jets[\"HadronConeExclTruthLabelID\"] == 0\nis_c = jets[\"HadronConeExclTruthLabelID\"] == 4\nis_b = jets[\"HadronConeExclTruthLabelID\"] == 5\n\n# here the plotting starts\n\n# define the curves\nrnnip_light = VarVsEff(\n    x_var_sig=pt[is_b],\n    disc_sig=discs_rnnip[is_b],\n    x_var_bkg=pt[is_light],\n    disc_bkg=discs_rnnip[is_light],\n    bins=[20, 30, 40, 60, 85, 110, 140, 175, 250],\n    working_point=0.7,\n    disc_cut=None,\n    flat_per_bin=False,\n    label=\"RNNIP\",\n)\ndips_light = VarVsEff(\n    x_var_sig=pt[is_b],\n    disc_sig=discs_dips[is_b],\n    x_var_bkg=pt[is_light],\n    disc_bkg=discs_dips[is_light],\n    bins=[20, 30, 40, 60, 85, 110, 140, 175, 250],\n    working_point=0.7,\n    disc_cut=None,\n    flat_per_bin=False,\n    label=\"DIPS\",\n)\n\n# You can choose between different modes: \"sig_eff\", \"bkg_eff\", \"sig_rej\", \"bkg_rej\"\nplot_sig_eff = VarVsEffPlot(\n    mode=\"sig_eff\",\n    ylabel=\"$b$-jets efficiency\",\n    xlabel=r\"$p_{T}$ [GeV]\",\n    logy=False,\n    atlas_second_tag=\"$\\\\sqrt{s}=13$ TeV, PFlow jets, \\n$t\\\\bar{t}$ sample, $f_{c}=0.018$\",\n    figsize=(6, 4.5),\n    n_ratio_panels=1,\n)\nplot_sig_eff.add(rnnip_light, reference=True)\nplot_sig_eff.add(dips_light)\n\nplot_sig_eff.atlas_second_tag += \"\\n\" + r\"Inclusive $\\epsilon_b=70\\%$\"\n\n# If you want to inverse the discriminant cut you can enable it via\n# plot_sig_eff.set_inverse_cut()\nplot_sig_eff.draw()\n# Drawing a hline indicating inclusive efficiency\nplot_sig_eff.draw_hline(0.7)\nplot_sig_eff.savefig(\"tutorial_pt_b_eff.png\", transparent=False)\n</code></pre>"},{"location":"examples/tutorial-plotting/#task-33-create-a-p_texttp_textt-vs-light-flavour-jets-rejection-plot","title":"Task 3.3: Create a p_\\text{T} vs. light-flavour jets rejection plot","text":"Solution <pre><code># reuse the VarVsEff objects that were defined for the previous exercise\nplot_bkg_rej = VarVsEffPlot(\n    mode=\"bkg_rej\",\n    ylabel=\"Light-flavour jets rejection\",\n    xlabel=r\"$p_{T}$ [GeV]\",\n    logy=False,\n    atlas_second_tag=\"$\\\\sqrt{s}=13$ TeV, PFlow jets \\n$t\\\\bar{t}$ sample, $f_{c}=0.018$\",\n    figsize=(6, 4.5),\n    n_ratio_panels=1,\n)\nplot_sig_eff.atlas_second_tag += \"\\n\" + r\"Inclusive $\\epsilon_b=70\\%$\"\nplot_bkg_rej.add(rnnip_light, reference=True)\nplot_bkg_rej.add(dips_light)\n\nplot_bkg_rej.draw()\nplot_bkg_rej.savefig(\"tutorial_pt_light_rej.png\")\n</code></pre>"},{"location":"examples/tutorial-plotting/#bonus-tasks","title":"Bonus tasks","text":""},{"location":"examples/tutorial-plotting/#run-over-a-run-3-mc-sample-and-compare-the-pileup-distributions","title":"Run over a Run-3 MC Sample and Compare the Pileup Distributions","text":"<p>This task will extend over the simple histogram plotting you already encountered in Task 1. You are asked to compare distributions from two different files: the Run-2 MC for the Z' sample and the Run-3 MC for the Z' sample.</p> <p>For this task, you will:</p> <ol> <li>Download the Z' sample for the Run-3 MC <code>zpext_run3.h5</code> from <code>/eos/user/u/umamibot/tutorials/</code>    or from <code>https://umami-ci-provider.web.cern.ch/puma/zpext_run3.h5</code>.</li> <li>Write a plotting script to compare the <code>averageInteractionsPerCrossing</code> between the two samples.</li> </ol> Solution <p>Copy the Run-3 MC file (assuming you work on lxplus):</p> <pre><code>cp /eos/user/u/umamibot/tutorials/zpext_run3.h5 &lt;/path/to/tutorial/data/&gt;\n</code></pre> <p>If you don't work on lxplus, download it via</p> <pre><code>wget https://umami-ci-provider.web.cern.ch/puma/zpext_run3.h5\n</code></pre> <p>You should provide a path for the dummy <code>&lt;/path/to/tutorial/data/&gt;</code> in the command above and in the python example below:</p> <pre><code>import numpy as np\nimport h5py\nfrom puma import Histogram, HistogramPlot\nfrom ftag.hdf5 import H5Reader\n\n# load the \"jets\" datasets from the h5 files\nfilepath_run2 = \"zpext.h5\"\nreader = H5Reader(filepath_run2, batch_size=100)\ndata = reader.load()\njets_run2 = data[\"jets\"]\n\nfilepath_run3 = \"zpext_run3.h5\"\nreader = H5Reader(filepath_run3, batch_size=100)\ndata = reader.load()\njets_run3 = data[\"jets\"]\n\nvariable = \"averageInteractionsPerCrossing\"\nrun_2 = Histogram(jets_run2[variable], label=\"Run 2 MC\", bins=np.linspace(10, 70, 60), norm=True)\nrun_3 = Histogram(jets_run3[variable], label=\"Run 3 MC\", bins=np.linspace(10, 70, 60), norm=True)\n\n# Initialise histogram plot\nplot_histo = HistogramPlot(\n    ylabel=\"Number of events\",\n    xlabel=r\"average interactions per crossing $\\langle\\mu\\rangle$ [a.u.]\",\n    logy=False,\n    atlas_first_tag=\"Simulation Internal\",\n    atlas_second_tag=\"Example for a comparison plot\",\n    figsize=(6, 5),\n    n_ratio_panels=1,\n)\n\n# Add histograms and plot\nplot_histo.add(run_2, reference=True)\nplot_histo.add(run_3)\nplot_histo.draw()\n\nplot_histo.savefig(\"histogram_pileup.png\", transparent=False)\n</code></pre>"},{"location":"examples/tutorial-plotting/#compare-the-flipped-taggers-to-the-regular-flavour-tagging-algorithms","title":"Compare the \"Flipped Taggers\" to the Regular Flavour Tagging Algorithms","text":"<p>This task further extends over the simple histogram plotting you already encountered in Task 1. You are asked to compare distributions from a regular flavour tagging algorithm and a so-called \"flipped tagger\", which is a modified version of the flavour tagging algorithm used for light-jet mistag calibration. For this version, the sign of d_0/z_0 signed impact parameter is flipped, resulting in a selection of jets with \u201cnegative lifetime\u201d.</p> <p>Consequently, the flipped tagger's b-tagging efficiency is reduced while its light-jet mistag rate is left unchanged.</p> <p>For this task, you will:</p> <ol> <li>Write a plotting script to compare the scores p_b, p_c, and p_u, for the RNNIP tagger to    the flipped version. You should produce three plots, one for each score (such as p_b), which    show the distributions of the RNNIP tagger and the flipped RNNIP tagger overlaid for the three    different jet flavours b-jets, c-jets and light-flavour jets.</li> <li>Next, extend the script to compare also the flavour tagging discriminant based on the flipped    tagger and the regular RNNIP tagger. You should produce one plot which compares the distributions    of the RNNIP tagger and the flipped RNNIP tagger overlaid for the three different jet flavours    b-jets, c-jets and light-flavour jets.</li> </ol> Hint: Names of the RNNIP tagger and the flipped tagger scores and the corresponding b-tagging discriminant <p>The names of the RNNIP tagger scores are</p> <ul> <li><code>rnnip_pu</code></li> <li><code>rnnip_pc</code></li> <li><code>rnnip_pb</code></li> </ul> <p>The names of the flipped version are</p> <ul> <li><code>rnnipflip_pu</code></li> <li><code>rnnipflip_pc</code></li> <li><code>rnnipflip_pb</code></li> </ul> <p>An example how the discriminant can be calculated is provided in one of the puma example scripts.</p> Solution <p>You should provide the path for the dummy <code>&lt;/path/to/tutorial/data/&gt;</code> in the python example below:</p> <pre><code>import numpy as np\nimport h5py\nimport pandas as pd\nfrom puma import Histogram, HistogramPlot\nfrom ftag.utils import get_discriminant\nfrom ftag import Flavours\nfrom ftag.hdf5 import H5Reader\n\n# load the \"jets\" dataset from the h5 file\nfilepath = \"/path/to/tutorial/data/ttbar.h5\"\nreader = H5Reader(filepath, batch_size=100)\ndata = reader.load()\njets = data[\"jets\"]\njets_df = pd.DataFrame(jets)\n\n\n# defining boolean arrays to select the different flavour classes\nis_light = jets[\"HadronConeExclTruthLabelID\"] == 0\nis_c = jets[\"HadronConeExclTruthLabelID\"] == 4\nis_b = jets[\"HadronConeExclTruthLabelID\"] == 5\n\n\n# Calculate discriminant scores for RNNIP and flipped tagger, and add them to the dataframe\n\njets_df[\"disc_rnnip\"] = get_discriminant(\n    jets=jets,\n    tagger=\"rnnip\",\n    signal=Flavours[\"bjets\"],\n    flavours=Flavours.by_category(\"single-btag\"),\n    fraction_values={\n        \"fc\": 0.07,\n        \"fu\": 0.93,\n        \"ftau\": 0,\n    },\n)\n\njets_df[\"disc_rnnipflip\"] = get_discriminant(\n    jets=jets,\n    tagger=\"rnnipflip\",\n    signal=Flavours[\"bjets\"],\n    flavours=Flavours.by_category(\"single-btag\"),\n    fraction_values={\n        \"fc\": 0.07,\n        \"fu\": 0.93,\n        \"ftau\": 0,\n    },\n)\n\nvariables = [\n    ('rnnip_pu', 'rnnipflip_pu'),\n    ('rnnip_pc', 'rnnipflip_pc'),\n    ('rnnip_pb', 'rnnipflip_pb'),\n    ('disc_rnnip', 'disc_rnnipflip'),\n]\n\naxis_labels = {\n    'rnnip_pu': 'RNNIP $p_\\\\mathrm{light}$',\n    'rnnip_pc': 'RNNIP $p_{c}$',\n    'rnnip_pb': 'RNNIP $p_{b}$',\n    'disc_rnnip': 'RNNIP $b$-tagging discriminant',\n}\n\n# plot score and discriminantdistributions\nfor v in variables:\n    rnnip_light = Histogram(\n        jets_df[is_light][v[0]],\n        flavour=\"ujets\",\n        label=\"RNNIP\",\n        ratio_group=\"ujet\",\n        bins=np.linspace(-10, 10, 40) if v[0] == \"disc_rnnip\" else np.linspace(0, 1, 20),\n        norm=False,\n    )\n    rnnip_c = Histogram(\n        jets_df[is_c][v[0]],\n        flavour=\"cjets\",\n        label=\"RNNIP\",\n        ratio_group=\"cjet\",\n        bins=np.linspace(-10, 10, 40) if v[0] == \"disc_rnnip\" else np.linspace(0, 1, 20),\n        norm=False,\n    )\n    rnnip_b = Histogram(\n        jets_df[is_b][v[0]],\n        flavour=\"bjets\",\n        label=\"RNNIP\",\n        ratio_group=\"bjet\",\n        bins=np.linspace(-10, 10, 40) if v[0] == \"disc_rnnip\" else np.linspace(0, 1, 20),\n        norm=False,\n    )\n\n    rnnip_light_flip = Histogram(\n        jets_df[is_light][v[1]],\n        linestyle=\"dashed\",\n        flavour=\"ujets\",\n        label=\"RNNIP (flip)\",\n        ratio_group=\"ujet\",\n        bins=np.linspace(-10, 10, 40) if v[0] == \"disc_rnnip\" else np.linspace(0, 1, 20),\n        norm=False,\n    )\n    rnnip_c_flip = Histogram(\n        jets_df[is_c][v[1]],\n        linestyle=\"dashed\",\n        flavour=\"cjets\",\n        label=\"RNNIP (flip)\",\n        ratio_group=\"cjet\",\n        bins=np.linspace(-10, 10, 40) if v[0] == \"disc_rnnip\" else np.linspace(0, 1, 20),\n        norm=False,\n    )\n    rnnip_b_flip = Histogram(\n        jets_df[is_b][v[1]],\n        linestyle=\"dashed\",\n        flavour=\"bjets\",\n        label=\"RNNIP (flip)\",\n        ratio_group=\"bjet\",\n        bins=np.linspace(-10, 10, 40) if v[0] == \"disc_rnnip\" else np.linspace(0, 1, 20),\n        norm=False,\n    )\n\n    # Initialise histogram plot\n    plot_histo = HistogramPlot(\n        ylabel=\"Number of events\",\n        xlabel=axis_labels[v[0]],\n        logy=True,\n        atlas_first_tag=\"Simulation Internal\",\n        figsize=(6, 5),\n        n_ratio_panels=1,\n    )\n\n    # Add histograms and plot\n    plot_histo.add(rnnip_light, reference=True)\n    plot_histo.add(rnnip_c, reference=True)\n    plot_histo.add(rnnip_b, reference=True)\n    plot_histo.add(rnnip_light_flip)\n    plot_histo.add(rnnip_c_flip)\n    plot_histo.add(rnnip_b_flip)\n    plot_histo.draw()\n\n    plot_histo.savefig(f\"histogram_flip_{v[0]}.png\", transparent=False)\n</code></pre>"},{"location":"examples/var_vs_eff/","title":"Variable vs efficiency plots","text":"<p>In the following a small example how to plot the efficiency vs a specific variable. In this case, we use <code>pt</code> as this variable.</p> <p>Then we can start the actual plotting part</p> <p></p> <p></p> <pre><code>\"\"\"Produce pT vs efficiency plot from tagger output and labels.\"\"\"\n\nfrom __future__ import annotations\n\nimport numpy as np\nfrom ftag import Flavours\nfrom ftag.utils import get_discriminant\n\nfrom puma import VarVsEff, VarVsEffPlot\nfrom puma.utils import get_dummy_2_taggers, logger\n\n# The line below generates dummy data which is similar to a NN output\ndf = get_dummy_2_taggers(add_pt=True)\n\nlogger.info(\"caclulate tagger discriminants\")\ndiscs_dips = get_discriminant(\n    jets=df,\n    tagger=\"dips\",\n    signal=Flavours[\"bjets\"],\n    flavours=Flavours.by_category(\"single-btag\"),\n    fraction_values={\n        \"fc\": 0.018,\n        \"fu\": 0.982,\n        \"ftau\": 0,\n    },\n)\ndiscs_rnnip = get_discriminant(\n    jets=df,\n    tagger=\"rnnip\",\n    signal=Flavours[\"bjets\"],\n    flavours=Flavours.by_category(\"single-btag\"),\n    fraction_values={\n        \"fc\": 0.018,\n        \"fu\": 0.982,\n        \"ftau\": 0,\n    },\n)\n\n# We can also use weights from the H5 files if needed\n# The weights we used here are all ones and simply for the purpose of showing how\n# you need to feed this to the VarVsEff class.\nmc_weights = df[\"mcEventWeight\"]\n\n# Getting jet pt in GeV\npt = df[\"pt\"] / 1e3\n\n# defining target efficiency\nsig_eff = np.linspace(0.49, 1, 20)\n\n# defining boolean arrays to select the different flavour classes\nis_b = Flavours[\"bjets\"].cuts(df).idx\nis_c = Flavours[\"cjets\"].cuts(df).idx\nis_light = Flavours[\"ujets\"].cuts(df).idx\nit_tau = Flavours[\"taujets\"].cuts(df).idx\n\n# here the plotting starts\n\n# Define the curves. The signal is here bjets (so b-tagging) and we want\n# to look a the light-jet rejection (so background is light jets)\nrnnip_light = VarVsEff(\n    x_var_sig=pt[is_b],\n    disc_sig=discs_rnnip[is_b],\n    weights_sig=mc_weights[is_b],\n    x_var_bkg=pt[is_light],\n    disc_bkg=discs_rnnip[is_light],\n    weights_bkg=mc_weights[is_light],\n    bins=[20, 30, 40, 60, 85, 110, 140, 175, 250],\n    working_point=0.7,\n    fixed_bkg_rej=None,\n    disc_cut=None,\n    flat_per_bin=False,\n    label=\"RNNIP\",\n)\ndips_light = VarVsEff(\n    x_var_sig=pt[is_b],\n    disc_sig=discs_dips[is_b],\n    weights_sig=mc_weights[is_b],\n    x_var_bkg=pt[is_light],\n    disc_bkg=discs_dips[is_light],\n    weights_bkg=mc_weights[is_light],\n    bins=[20, 30, 40, 60, 85, 110, 140, 175, 250],\n    working_point=0.7,\n    fixed_bkg_rej=None,\n    disc_cut=None,\n    flat_per_bin=False,\n    label=\"DIPS\",\n)\n\n# You can also store and load now the different VarVsEff curves\n# Supported formats are .yaml and .json, which are human-readable\n# and can be changed before loading them back in.\ndips_light.save(\"dips_light.yaml\")\nrnnip_light.save(\"rnnip_light.yaml\")\n\n# To load them again, you simply call the class with load().\n# Once loaded, you can use them as before. All needed info for plotting are still there\ndips_light_loaded = VarVsEff.load(\"dips_light.yaml\")\nrnnip_light_loaded = VarVsEff.load(\"rnnip_light.yaml\")\n\n# Now to the actual plotting\nlogger.info(\"Plotting bkg rejection for inclusive efficiency as a function of pt.\")\n\n# You can choose between different modes:\n# \"sig_eff\": Plots the signal efficiency as a function of your variable\n# \"bkg_eff\": Plots the background mis-tag efficiency as a function of your variable\n# \"sig_rej\": Plots the signal rejection (how much you miss) as a function of your variable\n# \"bkg_rej\": Plots the background rejection as a function of your variable\n\n# We go for light-flavour rejection here and define the actual plot object\nplot_bkg_rej = VarVsEffPlot(\n    mode=\"bkg_rej\",\n    ylabel=\"Light-flavour jets rejection\",\n    xlabel=r\"$p_{T}$ [GeV]\",\n    logy=False,\n    atlas_second_tag=\"$\\\\sqrt{s}=13$ TeV, dummy jets \\ndummy sample, $f_{c}=0.018$\",\n    n_ratio_panels=1,\n)\n\n# Adding now the two already-defined curves and set RNNIP to be the reference\nplot_bkg_rej.add(rnnip_light, reference=True)\nplot_bkg_rej.add(dips_light)\n\n# Draw the actual curves in the plot object\nplot_bkg_rej.draw()\n\n# Save the plot as png\nplot_bkg_rej.savefig(\"pt_light_rej.png\")\n\n# Now we also want to plot the signal efficiency. Init a new plot object with \"sig_eff\"\nplot_sig_eff = VarVsEffPlot(\n    mode=\"sig_eff\",\n    ylabel=\"$b$-jets efficiency\",\n    xlabel=r\"$p_{T}$ [GeV]\",\n    logy=False,\n    atlas_second_tag=\"$\\\\sqrt{s}=13$ TeV, dummy jets, \\ndummy sample, $f_{c}=0.018$\",\n    n_ratio_panels=1,\n)\n\n# Adding now the two already-defined curves and set RNNIP to be the reference\nplot_sig_eff.add(rnnip_light, reference=True)\nplot_sig_eff.add(dips_light)\n\n# Adapt the text under the ATLAS logo in the plots to say that we used the 70% working point\nplot_sig_eff.atlas_second_tag += \"\\nInclusive $\\\\epsilon_b=70\\\\%$\"\n\n# If you want to inverse the discriminant cut you can enable it via\n# plot_sig_eff.set_inverse_cut()\n\n# Draw the actual curves in the plot object\nplot_sig_eff.draw()\n\n# Drawing a hline indicating the inclusive efficiency working point\nplot_sig_eff.draw_hline(0.7)\n\n# Save the plot as png. Transparent false will colour the background of the plot white\nplot_sig_eff.savefig(\"pt_b_eff.png\", transparent=False)\n\n# We can also plot the performance non-inclusively, so instead of having a global\n# signal efficiency of 70% for the signal, we can enforce a 70% signal efficiency in each bin\n# For that, we need to redefine our curves by setting the option \"flat_per_bin\" to True\nrnnip_light = VarVsEff(\n    x_var_sig=pt[is_b],\n    disc_sig=discs_rnnip[is_b],\n    x_var_bkg=pt[is_light],\n    disc_bkg=discs_rnnip[is_light],\n    bins=[20, 30, 40, 60, 85, 110, 140, 175, 250],\n    working_point=0.7,\n    fixed_bkg_rej=None,\n    disc_cut=None,\n    flat_per_bin=True,\n    label=\"RNNIP\",\n)\ndips_light = VarVsEff(\n    x_var_sig=pt[is_b],\n    disc_sig=discs_dips[is_b],\n    x_var_bkg=pt[is_light],\n    disc_bkg=discs_dips[is_light],\n    bins=[20, 30, 40, 60, 85, 110, 140, 175, 250],\n    working_point=0.7,\n    fixed_bkg_rej=None,\n    disc_cut=None,\n    flat_per_bin=True,\n    label=\"DIPS\",\n)\n\n# Now we can plot the signal efficiency and background rejection\nplot_sig_eff = VarVsEffPlot(\n    mode=\"sig_eff\",\n    ylabel=\"$b$-jets efficiency\",\n    xlabel=r\"$p_{T}$ [GeV]\",\n    logy=False,\n    atlas_second_tag=\"$\\\\sqrt{s}=13$ TeV, dummy jets, \\ndummy sample, $f_{c}=0.018$\",\n    n_ratio_panels=1,\n)\n\n# Adding now the two already-defined curves and set RNNIP to be the reference\nplot_sig_eff.add(rnnip_light, reference=True)\nplot_sig_eff.add(dips_light)\n\n# Adapt the text under the ATLAS logo in the plots to say that we used the 70% working point\nplot_sig_eff.atlas_second_tag += \"\\nFixed $\\\\epsilon_b=70\\\\% per bin$\"\n\n# Draw the actual curves in the plot object\nplot_sig_eff.draw()\n\n# Save the plot as png\nplot_sig_eff.savefig(\"pt_b_eff_fixed_per_bin.png\")\n\n# You will see the plot show now the same signal efficiency for each bin\n# Now to the background rejection\nplot_bkg_rej = VarVsEffPlot(\n    mode=\"bkg_rej\",\n    ylabel=\"Light-flavour jets rejection\",\n    xlabel=r\"$p_{T}$ [GeV]\",\n    logy=False,\n    atlas_second_tag=\"$\\\\sqrt{s}=13$ TeV, dummy jets \\ndummy sample, $f_{c}=0.018$\",\n    n_ratio_panels=1,\n)\n\n# Adding now the two already-defined curves and set RNNIP to be the reference\nplot_bkg_rej.add(rnnip_light, reference=True)\nplot_bkg_rej.add(dips_light)\n\n# Draw the actual curves in the plot object\nplot_bkg_rej.draw()\n\n# Save the plot as png\nplot_bkg_rej.savefig(\"pt_light_rej_fixed_per_bin.png\")\n\n# Instead of fixing the signal efficiency to a working point, like 70%, you can also\n# fix the background rejection. Redefine the curves to enable this\nrnnip_light = VarVsEff(\n    x_var_sig=pt[is_b],\n    disc_sig=discs_rnnip[is_b],\n    x_var_bkg=pt[is_light],\n    disc_bkg=discs_rnnip[is_light],\n    bins=[20, 30, 40, 60, 85, 110, 140, 175, 250],\n    working_point=None,\n    fixed_bkg_rej=100,\n    disc_cut=None,\n    flat_per_bin=False,\n    label=\"RNNIP\",\n)\ndips_light = VarVsEff(\n    x_var_sig=pt[is_b],\n    disc_sig=discs_dips[is_b],\n    x_var_bkg=pt[is_light],\n    disc_bkg=discs_dips[is_light],\n    bins=[20, 30, 40, 60, 85, 110, 140, 175, 250],\n    working_point=None,\n    fixed_bkg_rej=100,\n    disc_cut=None,\n    flat_per_bin=False,\n    label=\"DIPS\",\n)\n\n# Now we can plot the signal efficiency and background rejection\nplot_sig_eff = VarVsEffPlot(\n    mode=\"sig_eff\",\n    ylabel=\"$b$-jets efficiency\",\n    xlabel=r\"$p_{T}$ [GeV]\",\n    logy=False,\n    atlas_second_tag=\"$\\\\sqrt{s}=13$ TeV, dummy jets, \\ndummy sample, $f_{c}=0.018$\",\n    n_ratio_panels=1,\n)\n\n# Adding now the two already-defined curves and set RNNIP to be the reference\nplot_sig_eff.add(rnnip_light, reference=True)\nplot_sig_eff.add(dips_light)\n\n# Adapt the text under the ATLAS logo in the plots to say that we used the 70% working point\nplot_sig_eff.atlas_second_tag += \"\\nFixed Rejection 100$\"\n\n# Draw the actual curves in the plot object\nplot_sig_eff.draw()\n\n# Save the plot as png\nplot_sig_eff.savefig(\"pt_b_eff_rej_100.png\")\n\n# You will see the plot show now the same signal efficiency for each bin\n# Now to the background rejection\nplot_bkg_rej = VarVsEffPlot(\n    mode=\"bkg_rej\",\n    ylabel=\"Light-flavour jets rejection\",\n    xlabel=r\"$p_{T}$ [GeV]\",\n    logy=False,\n    atlas_second_tag=\"$\\\\sqrt{s}=13$ TeV, dummy jets \\ndummy sample, $f_{c}=0.018$\",\n    n_ratio_panels=1,\n)\n\n# Adding now the two already-defined curves and set RNNIP to be the reference\nplot_bkg_rej.add(rnnip_light, reference=True)\nplot_bkg_rej.add(dips_light)\n\n# Draw the actual curves in the plot object\nplot_bkg_rej.draw()\n\n# Save the plot as png\nplot_bkg_rej.savefig(\"pt_light_rej_rej_100.png\")\n\n# Similar to the working point, also a fixed rejection per bin is possible\nrnnip_light = VarVsEff(\n    x_var_sig=pt[is_b],\n    disc_sig=discs_rnnip[is_b],\n    x_var_bkg=pt[is_light],\n    disc_bkg=discs_rnnip[is_light],\n    bins=[20, 30, 40, 60, 85, 110, 140, 175, 250],\n    working_point=None,\n    fixed_bkg_rej=100,\n    disc_cut=None,\n    flat_per_bin=True,\n    label=\"RNNIP\",\n)\ndips_light = VarVsEff(\n    x_var_sig=pt[is_b],\n    disc_sig=discs_dips[is_b],\n    x_var_bkg=pt[is_light],\n    disc_bkg=discs_dips[is_light],\n    bins=[20, 30, 40, 60, 85, 110, 140, 175, 250],\n    working_point=None,\n    fixed_bkg_rej=100,\n    disc_cut=None,\n    flat_per_bin=True,\n    label=\"DIPS\",\n)\n\n# Now we can plot the signal efficiency and background rejection\nplot_sig_eff = VarVsEffPlot(\n    mode=\"sig_eff\",\n    ylabel=\"$b$-jets efficiency\",\n    xlabel=r\"$p_{T}$ [GeV]\",\n    logy=False,\n    atlas_second_tag=\"$\\\\sqrt{s}=13$ TeV, dummy jets, \\ndummy sample, $f_{c}=0.018$\",\n    n_ratio_panels=1,\n)\n\n# Adding now the two already-defined curves and set RNNIP to be the reference\nplot_sig_eff.add(rnnip_light, reference=True)\nplot_sig_eff.add(dips_light)\n\n# Adapt the text under the ATLAS logo in the plots to say that we used the 70% working point\nplot_sig_eff.atlas_second_tag += \"\\nFixed Rejection 100 per bin$\"\n\n# Draw the actual curves in the plot object\nplot_sig_eff.draw()\n\n# Save the plot as png\nplot_sig_eff.savefig(\"pt_b_eff_rej_100_per_bin.png\")\n\n# You will see the plot show now the same signal efficiency for each bin\n# Now to the background rejection\nplot_bkg_rej = VarVsEffPlot(\n    mode=\"bkg_rej\",\n    ylabel=\"Light-flavour jets rejection\",\n    xlabel=r\"$p_{T}$ [GeV]\",\n    logy=False,\n    atlas_second_tag=\"$\\\\sqrt{s}=13$ TeV, dummy jets \\ndummy sample, $f_{c}=0.018$\",\n    n_ratio_panels=1,\n)\n\n# Adding now the two already-defined curves and set RNNIP to be the reference\nplot_bkg_rej.add(rnnip_light, reference=True)\nplot_bkg_rej.add(dips_light)\n\n# Draw the actual curves in the plot object\nplot_bkg_rej.draw()\n\n# Save the plot as png\nplot_bkg_rej.savefig(\"pt_light_rej_rej_100_per_bin.png\")\n\n# Another nice feature for efficiencies where the rejection is fixed, is to show the absolute\n# difference. This can be done with the ratio_method \"subtract\"\nplot_sig_eff = VarVsEffPlot(\n    mode=\"sig_eff\",\n    ylabel=\"$b$-jets efficiency\",\n    xlabel=r\"$p_{T}$ [GeV]\",\n    logy=False,\n    atlas_second_tag=\"$\\\\sqrt{s}=13$ TeV, dummy jets, \\ndummy sample, $f_{c}=0.018$\",\n    n_ratio_panels=1,\n    ratio_method=\"subtract\",\n    ylabel_ratio=\"Difference\",\n)\n\n# Adding now the two already-defined curves and set RNNIP to be the reference\nplot_sig_eff.add(rnnip_light, reference=True)\nplot_sig_eff.add(dips_light)\n\n# Draw the actual curves in the plot object\nplot_sig_eff.draw()\n\n# Save the plot as png\nplot_sig_eff.savefig(\"pt_light_rej_rej_100_per_bin_subtracted.png\")\n</code></pre>"},{"location":"hlapi/","title":"High level API","text":"<p>To set up the inputs for the plots, have a look here.</p> <p>The following examples use the dummy data which is described here</p> <p>All the previous examples show how to use the plotting of individual plots often requiring a fair amount of code to produce ROC curves etc.</p> <p>This high level API facilitates several steps and is designed to quickly plot b- and c-jet performance plots.</p>"},{"location":"hlapi/#initialising-the-taggers","title":"Initialising the taggers","text":"<p>The <code>Results</code> object is initialised with the signal class, by default this is <code>bjets</code> but can be changed to <code>cjets</code> to produce the c-tagging plots, or <code>Hbb</code>/<code>Hcc</code> for Xbb tagging.</p> <pre><code>\"\"\"Produce roc curves from tagger output and labels.\"\"\"\n\nfrom __future__ import annotations\n\nfrom puma.hlplots import Results, Tagger\nfrom puma.utils import get_dummy_2_taggers, logger\n\n# The line below generates dummy data which is similar to a NN output\nfile = get_dummy_2_taggers(add_pt=True, return_file=True)\n\n# define jet selections\ncuts = [(\"n_truth_promptLepton\", \"==\", 0)]\n\n# define the taggers\ndips = Tagger(\n    name=\"dips\",\n    output_flavours=[\"ujets\", \"cjets\", \"bjets\"],\n    label=\"dummy DIPS ($f_{c}=0.005$)\",\n    fxs={\"fc\": 0.005},\n    colour=\"#AA3377\",\n)\nrnnip = Tagger(\n    name=\"rnnip\",\n    output_flavours=[\"ujets\", \"cjets\", \"bjets\"],\n    label=\"dummy RNNIP ($f_{c}=0.07$)\",\n    fxs={\"fc\": 0.07},\n    colour=\"#4477AA\",\n    reference=True,\n)\n\n# create the Results object\n# for c-tagging use signal=\"cjets\"\n# for Xbb/cc-tagging use signal=\"hbb\"/\"hcc\"\nresults = Results(signal=\"bjets\", sample=\"dummy\")\n\n# load taggers from the file object\nlogger.info(\"Loading taggers.\")\nresults.load_taggers_from_file(\n    [dips, rnnip],\n    file.filename,\n    cuts=cuts,\n    num_jets=len(file[\"jets\"]),\n)\n\nresults.atlas_second_tag = (\n    \"$\\\\sqrt{s}=13$ TeV, dummy jets \\n$t\\\\bar{t}$, $20$ GeV $&lt; p_{T} &lt;250$ GeV\"\n</code></pre>"},{"location":"hlapi/#probability-distributions","title":"Probability distributions","text":"<p>You can get the output probability distributions just run <pre><code>)\n</code></pre></p>"},{"location":"hlapi/#discriminant-plots","title":"Discriminant plots","text":"<p>To plot the discriminant, you can now simply call one function and everything else is handled automatically, here for the b-jet discriminant <pre><code>results.plot_probs(logy=True, bins=40)\n\n# tagger discriminant distributions\nlogger.info(\"Plotting tagger discriminant plots.\")\n</code></pre></p>"},{"location":"hlapi/#roc-plots","title":"ROC plots","text":"<p>In the same manner you can plot ROC curves, here for the b-tagging performance <pre><code>results.plot_discs(logy=True, bins=40, bins_range=(-10, 10), wp_vlines=[60, 85], suffix=\"log\")\n\n# ROC curves\n</code></pre></p>"},{"location":"hlapi/#performance-vs-a-variable","title":"Performance vs a variable","text":"<p>In this case we plot the performance as a function of the jet pT with the same syntax as above for an inclusive working point of 70% <pre><code>results.plot_rocs()\n\n# eff/rej vs. variable plots\nlogger.info(\"Plotting efficiency/rejection vs pT curves.\")\nresults.atlas_second_tag = \"$\\\\sqrt{s}=13$ TeV, dummy jets \\n$t\\\\bar{t}$\"\n\n# or alternatively also pass the argument `working_point` to the plot_var_perf function.\n# specifying the `disc_cut` per tagger is also possible.\nresults.plot_var_perf(\n    working_point=0.7,\n    bins=[20, 30, 40, 60, 85, 110, 140, 175, 250],\n</code></pre></p> <p>and similar for a fixed b-efficiency per bin. <pre><code>)\n\n# For the working point, you could also provide a list with two values, which are the\n# edges of efficiencies. For example, the PCFT working points can be plotted for that\nresults.plot_var_perf(\n    working_point=[0.7, 0.77],\n    bins=[20, 30, 40, 60, 85, 110, 140, 175, 250],\n    flat_per_bin=False,\n</code></pre></p> <p>Similar to above you can also do these plots for c-tagging by changing the <code>signal_class</code> to <code>cjets</code>.</p>"},{"location":"hlapi/#fraction-scans","title":"Fraction scans","text":"<p>Plot the two background efficiencies as a function of the f_c or f_b value.</p> <pre><code>    disc_cut=None,\n)\n# flat rej vs. variable plots, a third tag is added relating to the fixed\n#  rejection per bin\n</code></pre>"},{"location":"hlapi/high_level_aux_api/","title":"High level API for aux task plots","text":"<p>To set up the inputs for the plots, have a look here. In general, the input structure is the same for aux task plots, but a separate container with track-level aux task outputs is required to be present in the files (by default \"tracks\"). For now, vertexing and track origin prediction aux tasks are supported.</p> <p>The following examples use the dummy data which is described here</p> <p>The high level API for aux tasks matches the general high level API in terms of structure. It can be used to produce vertexing performance plots.</p>"},{"location":"hlapi/high_level_aux_api/#initialising-the-taggers","title":"Initialising the taggers","text":"<p>Compared to the <code>Results</code> object, an <code>AuxResults</code> object is initialized without definition of a signal class (rather this is passed to the plotting functions directly). Otherwise initialization proceeds in the same fashion. Taggers can be added to these objects in an analogous way to <code>Results</code>, except that each tagger should be initialized with a list of available aux tasks (by default \"vertexing\" and \"track_origin\"). Relevant information for these aux tasks will then be read in from the provided file, assuming the information is available and the specific aux task is properly supported within puma. The <code>AuxResults</code> object also allows for track variables (such as pT, eta, etc.) to be loaded in for each tagger. These are listed out via the <code>aux_perf_vars</code> attribute and allow for calculation of vertex masses. If (track) <code>deta</code> is specified in <code>aux_perf_vars</code> and (jet) <code>eta</code> in <code>perf_vars</code>, (track) <code>eta</code> is automatically calculated and added to <code>aux_perf_vars</code>.</p> <pre><code>\"\"\"Produce aux task plots from tagger output and labels.\"\"\"\n\nfrom __future__ import annotations\n\nfrom puma.hlplots import AuxResults, Tagger\nfrom puma.utils import get_dummy_tagger_aux, logger\n\n# The line below generates dummy data which is similar to a NN output\nfname, file = get_dummy_tagger_aux()\n\n# define jet selections\ncuts = [(\"n_truth_promptLepton\", \"==\", 0)]\n\n# define the tagger\nGN2 = Tagger(\n    name=\"GN2\",\n    label=\"dummy GN2\",\n    colour=\"#4477AA\",\n    reference=True,\n)\n\n# create the AuxResults object\naux_results = AuxResults(\n    sample=\"dummy\",\n    aux_perf_vars=[\"pt\", \"eta\", \"dphi\"],\n)\n\n# load tagger from the file object\nlogger.info(\"Loading taggers.\")\naux_results.load_taggers_from_file(\n    [GN2],\n    fname,\n    cuts=cuts,\n    num_jets=len(file[\"jets\"]),\n)\n</code></pre>"},{"location":"hlapi/high_level_aux_api/#vertexing-performance","title":"Vertexing performance","text":"<p>Vertexing performance plots can be produced for a specified jet flavour as shown in <pre><code># vertexing performance for b-jets\nlogger.info(\"Plotting vertexing performance.\")\naux_results.plot_var_vtx_perf(vtx_flavours=[\"bjets\"], no_vtx_flavours=[\"ujets\"])\n</code></pre> Here <code>vtx_flavours</code> defines a list of flavours for which secondary vertices are expected (e.g. b-jets) and <code>no_vertex_flavours</code> defines a list where secondary vertices are not expected (e.g. l-jets). Different plots are produced in each case (see below). In general, this plotting function handles all considerations for vertexing performance. This includes processing truth vertex indices by removing vertices containing tracks not from HF and reco vertices by removing the vertex most consistent with the reconstructed PV (if a tagger has the capability to identify tracks from a PV via track origin classification). See here for more information about truth track origin and vertex definitions. If inclusive vertexing is enabled, all HF vertices are merged into a single truth vertex. For reconstructed vertices in a tagger with track origin classification, all vertices with at least one HF track are merged and all others are removed. If track origin classification is not available, but inclusive vertexing is enabled, then all vertices are merged. After this cleaning procedure, a 1:1 greedy matching procedure between truth and reconstructed vertices is performed, with which all the relevant performance metrics for plots are calculated. In total, 4 plots are produced for each jet flavour with expected SVs and 1 is produced for each flavour with no expected SVs (all plotted against specific performance variable):</p> <ul> <li>Vertexing efficiency: defined as number of vertices matched divided by number of true vertices (expected SVs)</li> <li>Vertexing purity: defined as number of vertices matched divided by number of reconstructed vertices (expected SVs)</li> <li>Track-vertex association efficiency: defined as number of tracks in matched vertex common between truth and reco vertices divided by number of tracks in true vertex (expected SVs)</li> <li>Track-vertex association purity: defined as number of tracks in matched vertex common between truth and reco vertices divided by number of tracks in reco vertex (expected SVs)</li> <li>Vertexing fake rate: fraction of jets where at least one SV is found (no expected SVs)</li> </ul> <p>Note that by default the vertex matching algorithm enforces purity criteria requiring track association efficiency &gt; 0.65 and purity &gt; 0.5</p>"},{"location":"hlapi/high_level_aux_api/#vertex-mass-reconstruction","title":"Vertex mass reconstruction","text":"<p>Secondary vertex mass histograms can be produced for a specified jet flavour as shown in <pre><code># vertex mass reconstruction performance for b-jets\nlogger.info(\"Plotting secondary vertex masses.\")\naux_results.plot_vertex_mass(vtx_flavours=[\"bjets\"])\n</code></pre> Vertex masses are calculated using a pion hypothesis for all tracks, both for truth and reconstructed vertices with the given values for pT, eta and phi. These plots can be produced for inclusive or exclusive vertexing as defined in the vertexing section. For inclusive vertexing, difference plots are also produced, which show differences in the reco vs. truth mass estimates on a vertex by vertex basis.</p>"},{"location":"hlapi/high_level_aux_api/#track-origin-performances","title":"Track Origin Performances","text":"<p>The Track Origin auxiliary task is a multiclass classification task, in which each track is associated with its most probable belonging origin, chosen between:</p> <ul> <li>Pileup;</li> <li>Fake;</li> <li>Primary;</li> <li>FromB;</li> <li>FromBC;</li> <li>FromC;</li> <li>FromTau;</li> <li>OtherSecondary;</li> </ul> <p>A good metric to evaluate the performances of the classifier is the Confusion Matrix, which can be plotted using the method <code>plot_track_origin_confmat</code>.</p> <p>The normalization of the tagger's confusion matrix can be chosen among the ones allowed by the <code>confusion_matrix</code> possible normalizations, by specifying the argument <code>normalize</code> in the <code>plot_track_origin_confmat</code> function. By default, the matrix's rows are normalized.</p>"},{"location":"hlapi/n_track_origin/","title":"Number of Tracks per Track Origin","text":"<p>To understand the amount of tracks per jet as a function of p_\\mathrm{T}, PUMA provides a high-level function named <code>n_tracks_per_origin</code>. This function can load an <code>.h5</code> from the Training-Dataset-Dumper and extract the number of tracks per jet (and per track origin) as a function of p_\\mathrm{T}.</p> <p>An example of the usage of this function can be found here:</p> <pre><code>\"\"\"Plotting example of the n_tracks_per_origin function.\"\"\"\n\nfrom __future__ import annotations\n\nfrom urllib.request import urlretrieve\n\nimport numpy as np\nfrom ftag import Flavours\n\nfrom puma.hlplots import n_tracks_per_origin\n\n# Download test h5 sample\nurlretrieve(\n    \"https://umami-ci-provider.web.cern.ch/plot_input_vars/plot_input_vars_r22_check.h5\",\n    \"testfile.h5\",\n)\n\n# Define the grouping of the track origins\ntrack_origin_dict = {\n    \"All\": range(8),\n    # \"Fragmentation\": [1, 2],\n    \"HF decay\": [3, 4, 5],\n    # \"From $\\\\tau$\": [6],\n    \"Others\": [0, 1, 2, 6, 7],\n}\n\n# Define a list with all flavours that should be plotted\nflavour_list = [\n    Flavours.bjets,\n    Flavours.cjets,\n    Flavours.ujets,\n]\n\n# Define the dict with all samples that are to be plotted\nfiles_dict = {\n    \"ttbar\": {\n        \"filepath\": \"testfile.h5\",\n        \"n_jets\": 10000,\n        \"tracks_name\": \"tracks_loose\",\n        \"pt_bins\": np.linspace(20_000, 250_000, 20),\n        \"process_label\": \"$t\\\\bar{t}$\",\n        \"jet_pt_variable\": \"pt_btagJes\",\n        \"track_truth_variable\": \"truthOriginLabel\",\n        \"flavour_label_variable\": \"HadronConeExclTruthLabelID\",\n    },\n}\n\n# Plotting all samples for one flavour per plot\nn_tracks_per_origin(\n    flavour_list=flavour_list,\n    files=files_dict,\n    track_origin_dict=track_origin_dict,\n    plot_type=\"all_samples_one_flavour\",\n    plot_path=\"./\",\n    plot_format=\"pdf\",\n    plot_name=\"Test_plots\",\n)\n\n# Plotting all flavour for one sample per plot\nn_tracks_per_origin(\n    flavour_list=flavour_list,\n    files=files_dict,\n    track_origin_dict=track_origin_dict,\n    plot_type=\"one_sample_all_flavour\",\n    plot_path=\"./\",\n    plot_format=\"pdf\",\n    plot_name=\"Test_plots\",\n)\n</code></pre>"},{"location":"hlapi/yuma/","title":"YUMA (Yaml Plotting)","text":"<p>YUMA (Yaml for pUMA) removes boilerplate required for making simple flavour tagging plots, instead moving everything required into yaml config files, and acting as a wrapper around the high-level plotting functionality included in puma. To make plots, two config files are required, a <code>taggers.yaml</code> and <code>plot_cfg.yaml</code>. Examples of these can be found in <code>puma/examples</code>.</p> <p>To create plots, after modifying the two files, run</p> <pre><code>yuma --config examples/plot_cfg.yaml \n</code></pre> <p>Additional arguments can be included:</p> <ul> <li><code>--plots [roc, scan, disc, prob, peff]</code> Select one or more type of plots to produce.</li> <li><code>--signals [bjets, cjets]</code> what signals to plot</li> <li><code>--num_jets [n]</code> number of jets to load per tagger (before cuts are applied)</li> </ul>"},{"location":"hlapi/yuma/#taggersyaml","title":"taggers.yaml","text":"<p>The <code>taggers.yaml</code> file contains required information for taggers we wish to load. Under 'taggers' are the defined taggers. Each should be assigned a tag, which is used as the 'name' of the tagger and its settings. Within in tagger, arguments that can be parsed to the Tagger high-level class can be used. If you wish to plot the same tagger multiple times, for example with different <code>fc</code> values, you can also include a name:</p> <pre><code>GN2_fc0:\n    name: GN2v01\n    [args]\nGN2_fc0p1:\n    name: GN2v01\n    [args]\n</code></pre> <p>In this case, both models will be the GN2v01 from whichever sample is specified. You should add <code>GN2_fc0</code> and <code>GN2_fc0p1</code> as the taggers in the plot config to plot both.</p>"},{"location":"hlapi/yuma/#plot_cfgyaml","title":"plot_cfg.yaml","text":"<p>This file contains info on what taggers to load, what plots to make, and where to save them.</p>"},{"location":"hlapi/yuma/#global-options","title":"Global options","text":"<ul> <li><code>plot_dir:</code> - The base directory to write plots to. The pltos will be saved to a directory of the form <code>plot_dir/plt_cfg</code>.</li> <li><code>timestamp: False</code> - If True, will create a new directory each time the script is run, with a timestamp included in the name. If False, then will save to the default directory, and overwrite any files.</li> <li><code>results_config:</code> - Arguments to parse to the 'Results' class.</li> <li><code>taggers_config:</code> - Path to the <code>taggers.yaml</code> file.</li> <li><code>taggers:</code> - List of tagger names that we wish to plot.</li> <li><code>reference_tagger:</code> - Tagger name that shall be the 'reference' tagger. Any ratios by default are with respect to this tagger.</li> <li><code>sample:</code> - Information on the sample plotted, including the name, any cuts for the sample, and a sample string to include in the plot info.</li> <li><code>all_flavours</code> - A list which defines all the flavours available. If defined, then background flavours are defined as <code>all_flavours - signal</code>, if not defined, then default backgrounds are assigned (e.g, cjets and lightjets if signal=bjets) -<code>label_var</code> - What variable define the class labels. By default <code>HadronConeExclTruthLabelID</code></li> </ul>"},{"location":"hlapi/yuma/#plots","title":"Plots","text":"<p>Each plot type should come under its own section. The allowed plots are:</p> <ul> <li>roc_plots</li> <li>fracscan_plots</li> <li>disc_plots</li> <li>prob_plots</li> <li>eff_vs_var_plots</li> </ul> <p>Within each section, a list of plots should be included. Each plot requires a 'signal'. Additional options that work for all plot types are:</p> <ul> <li>suffix: Allows a custom suffix for the plot name.</li> <li>include_taggers: Only include the specified taggers for this plot</li> <li>exclude_taggers: Plot all taggers, except those in 'exclude_taggers'</li> <li>plot_kwargs: arguments parsed to the base plot object, such as figsize.</li> </ul> <p>Other specific plot types have additional arguments that can be included:</p>"},{"location":"hlapi/yuma/#roc-plots","title":"ROC plots","text":"<ul> <li>x_range: The x-range of the signal efficiency</li> </ul>"},{"location":"hlapi/yuma/#fraction-scan-plots","title":"Fraction Scan plots","text":"<ul> <li>frac_flav: The x in 'f_x', for example 'c' for standard f_c plots</li> <li>efficiency: The signal efficiency to plot at</li> <li>backgrounds: List of two backgrounds to plot the scan over.</li> </ul>"},{"location":"hlapi/yuma/#efficiency-vs-var-plots","title":"Efficiency Vs Var plots","text":"<ul> <li>peff_var: The variable to bin on the x-axis, default is pt bins: The bin edges for the x-axis, default for pT depends on if sample is ttbar/zprime</li> </ul>"}]}